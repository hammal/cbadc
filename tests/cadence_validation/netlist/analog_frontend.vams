// This file was autogenerated using the
// cbadc toolbox, see https://github.com/hammal/cbadc
// and is thereby valid under the
//
// GNU General Public License v3.0
// (see https://github.com/hammal/cbadc/blob/master/LICENCE)
//
// This file was generated at
//
// 2022-11-11T16:55:33.444884
//
// using the cbadc package version
//
// 0.2.2
//
`include "constants.vams"
`include "disciplines.vams"



// observer
// 
// Ports: vdd, vgd, vsgd, clk, s_0, s_1, s_2, s_3, s_4, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_tilde_4, u_0
// 
// Parameters: 
// 
// Functional Description:
// 
// A observer module for capturing signals to file.
//
module observer(vdd, vgd, vsgd, clk, s_0, s_1, s_2, s_3, s_4, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_tilde_4, u_0);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input clk; // clock signal
    input s_0; // control signal 0
    input s_1; // control signal 1
    input s_2; // control signal 2
    input s_3; // control signal 3
    input s_4; // control signal 4
    input s_tilde_0; // control observation 0
    input s_tilde_1; // control observation 1
    input s_tilde_2; // control observation 2
    input s_tilde_3; // control observation 3
    input s_tilde_4; // control observation 4
    input u_0; // input channel 0

    electrical vdd; // positive supply
    electrical vgd; // ground
    electrical vsgd; // signal ground
    electrical clk; // clock signal
    electrical s_0; // control signal 0
    electrical s_1; // control signal 1
    electrical s_2; // control signal 2
    electrical s_3; // control signal 3
    electrical s_4; // control signal 4
    electrical s_tilde_0; // control observation 0
    electrical s_tilde_1; // control observation 1
    electrical s_tilde_2; // control observation 2
    electrical s_tilde_3; // control observation 3
    electrical s_tilde_4; // control observation 4
    electrical u_0; // input channel 0
    integer fp; // For observer

    analog begin
        @(initial_step) begin
        	fp=$fopen("/Users/hammal/Projects/cbadc/tests/cadence_validation/observations.csv","w");
        	$fwrite(fp,"s_0,s_1,s_2,s_3,s_4,s_tilde_0,s_tilde_1,s_tilde_2,s_tilde_3,s_tilde_4,u_0\n");
        end
        
        @(final_step) begin
        	$fclose(fp);
        end
        
        @(cross(V(clk) - V(vsgd), 1)) begin
        	$fstrobe(fp, "%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f", V(s_0), V(s_1), V(s_2), V(s_3), V(s_4), V(s_tilde_0), V(s_tilde_1), V(s_tilde_2), V(s_tilde_3), V(s_tilde_4), V(u_0));
        end
    end

endmodule


// comparator
// 
// Ports: vdd, vgd, vsgd, clk, s_tilde, s
// 
// Parameters: dly, ttime
// 
// Functional Description:
// 
// A comparator implementation where
// the output signal s(t) is updated at the
// falling edge of the V(clk) signal depending
// on the input signal V(s_tilde) is above or
// below a given threshold.
// 
// threshold determines the descision threshold.
// Furthermore, dly and ttime specifies how quickly the
// comparator can switch its output.
//
module comparator(vdd, vgd, vsgd, clk, s_tilde, s);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input clk; // clock signal
    input s_tilde;
    output s;

    parameter real dly = 0.0;
    parameter real ttime = 10p;

    electrical vdd; // positive supply
    electrical vgd; // ground
    electrical vsgd; // signal ground
    electrical clk; // clock signal
    electrical s_tilde;
    electrical s;

    real vout; // Output voltage value

    analog begin
        @(cross(V(clk) - V(vsgd), -1)) begin
        	if(V(s_tilde) > V(vsgd)) begin
        		vout=V(vdd, vgd);
        	end
        	else begin
        		vout = V(vgd);
        	end
        end
        V(s, vgd) <+ vout * transition(1.0, dly, ttime);
    end

endmodule


// digital_control
// 
// Ports: vdd, vgd, vsgd, clk, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_tilde_4, s_0, s_1, s_2, s_3, s_4
// 
// Parameters: 
// 
// Functional Description:
// 
// A digital control which mainly connects
// M comparators to the input and outputs of
// the module itself.
//
module digital_control(vdd, vgd, vsgd, clk, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_tilde_4, s_0, s_1, s_2, s_3, s_4);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input clk; // clock signal
    input s_tilde_0;
    input s_tilde_1;
    input s_tilde_2;
    input s_tilde_3;
    input s_tilde_4;
    output s_0;
    output s_1;
    output s_2;
    output s_3;
    output s_4;

    electrical vdd; // positive supply
    electrical vgd; // ground
    electrical vsgd; // signal ground
    electrical clk; // clock signal
    electrical s_tilde_0;
    electrical s_tilde_1;
    electrical s_tilde_2;
    electrical s_tilde_3;
    electrical s_tilde_4;
    electrical s_0;
    electrical s_1;
    electrical s_2;
    electrical s_3;
    electrical s_4;


    comparator q_0 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_0),
            .s(s_0)
    );

    comparator q_1 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_1),
            .s(s_1)
    );

    comparator q_2 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_2),
            .s(s_2)
    );

    comparator q_3 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_3),
            .s(s_3)
    );

    comparator q_4 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_4),
            .s(s_4)
    );

endmodule


// analog_system
// 
// Ports: vdd, vgd, vsgd, u_0, s_0, s_1, s_2, s_3, s_4, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_tilde_4
// 
// Parameters: 
// 
// Functional Description
// 
// The analog system directly modeled using differential
// equations.
// 
// Specifically, we use the state space model equations
// 
// ddt(x(t)) = A x(t) + B u(t) + Gamma s(t)
// s_tilde(t) = Gamma_tildeT x(t)
// 
// where
// 
// x(t) = [x_0, x_1, x_2, x_3, x_4]^T
// u(t) = [u_0]^T
// s(t) = [s_0, s_1, s_2, s_3, s_4]^T
// s_tilde(t) = [s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_tilde_4]^T
// 
// A ≈
// [0.00e+00, 9.32e+05, 0.00e+00, 0.00e+00, 0.00e+00]
// [-1.06e+07, 0.00e+00, 9.32e+05, 0.00e+00, 0.00e+00]
// [0.00e+00, -1.06e+07, 0.00e+00, 9.32e+05, 0.00e+00]
// [0.00e+00, 0.00e+00, -1.06e+07, 0.00e+00, 9.32e+05]
// [0.00e+00, 0.00e+00, 0.00e+00, -1.06e+07, 0.00e+00]
// 
// B ≈
// [-1.06e+07]
// [0.00e+00]
// [0.00e+00]
// [0.00e+00]
// [0.00e+00]
// 
// Gamma ≈
// [-1.06e+07, -0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00]
// [-0.00e+00, -1.06e+07, -0.00e+00, -0.00e+00, -0.00e+00]
// [-0.00e+00, -0.00e+00, -1.06e+07, -0.00e+00, -0.00e+00]
// [-0.00e+00, -0.00e+00, -0.00e+00, -1.06e+07, -0.00e+00]
// [-0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00, -1.06e+07]
// 
// Gamma_tildeT ≈
// [1.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 1.00e+00, 0.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 1.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 0.00e+00, 1.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 1.00e+00]
//
module analog_system(vdd, vgd, vsgd, u_0, s_0, s_1, s_2, s_3, s_4, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_tilde_4);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input u_0;
    input s_0;
    input s_1;
    input s_2;
    input s_3;
    input s_4;
    output s_tilde_0;
    output s_tilde_1;
    output s_tilde_2;
    output s_tilde_3;
    output s_tilde_4;

    electrical vdd; // positive supply
    electrical vgd; // ground
    electrical vsgd; // signal ground
    electrical u_0;
    electrical s_0;
    electrical s_1;
    electrical s_2;
    electrical s_3;
    electrical s_4;
    electrical s_tilde_0;
    electrical s_tilde_1;
    electrical s_tilde_2;
    electrical s_tilde_3;
    electrical s_tilde_4;
    electrical x_0;
    electrical x_1;
    electrical x_2;
    electrical x_3;
    electrical x_4;

    analog begin
        V(x_0, vsgd) <+ idt(+932155.4165996709*V(x_1, vsgd) -10587938.690622894*V(s_0, vsgd) -10587938.690622894*V(u_0, vsgd));
        V(x_1, vsgd) <+ idt(-10587938.690622894*V(x_0, vsgd) +932155.4165996709*V(x_2, vsgd) -10587938.690622894*V(s_1, vsgd));
        V(x_2, vsgd) <+ idt(-10587938.690622894*V(x_1, vsgd) +932155.4165996709*V(x_3, vsgd) -10587938.690622894*V(s_2, vsgd));
        V(x_3, vsgd) <+ idt(-10587938.690622894*V(x_2, vsgd) +932155.4165996709*V(x_4, vsgd) -10587938.690622894*V(s_3, vsgd));
        V(x_4, vsgd) <+ idt(-10587938.690622894*V(x_3, vsgd) -10587938.690622894*V(s_4, vsgd));
        V(s_tilde_0, vsgd) <+ +1.0*V(x_0, vsgd);
        V(s_tilde_1, vsgd) <+ +1.0*V(x_1, vsgd);
        V(s_tilde_2, vsgd) <+ +1.0*V(x_2, vsgd);
        V(s_tilde_3, vsgd) <+ +1.0*V(x_3, vsgd);
        V(s_tilde_4, vsgd) <+ +1.0*V(x_4, vsgd);
    end

endmodule


// analog_frontend
// 
// Ports: vdd, vgd, vsgd, clk, u_0, s_0, s_1, s_2, s_3, s_4
// 
// Parameters: 
// 
// Functional Description:
// 
// An analog frontend comparise of an analog-system
// and digital control interfaced such that
// control signals can be generated given a clock signal
// and input stimuli.
//
module analog_frontend(vdd, vgd, vsgd, clk, u_0, s_0, s_1, s_2, s_3, s_4);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input clk; // clock signal
    input u_0; // input channel 0
    output s_0; // control signal 0
    output s_1; // control signal 1
    output s_2; // control signal 2
    output s_3; // control signal 3
    output s_4; // control signal 4

    electrical vdd; // positive supply
    electrical vgd; // ground
    electrical vsgd; // signal ground
    electrical clk; // clock signal
    electrical u_0; // input channel 0
    electrical s_0; // control signal 0
    electrical s_1; // control signal 1
    electrical s_2; // control signal 2
    electrical s_3; // control signal 3
    electrical s_4; // control signal 4
    electrical s_tilde_0; // control observation 0
    electrical s_tilde_1; // control observation 1
    electrical s_tilde_2; // control observation 2
    electrical s_tilde_3; // control observation 3
    electrical s_tilde_4; // control observation 4


    analog_system analog_system (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .u_0(u_0),
            .s_0(s_0),
            .s_1(s_1),
            .s_2(s_2),
            .s_3(s_3),
            .s_4(s_4),
            .s_tilde_0(s_tilde_0),
            .s_tilde_1(s_tilde_1),
            .s_tilde_2(s_tilde_2),
            .s_tilde_3(s_tilde_3),
            .s_tilde_4(s_tilde_4)
    );

    digital_control digital_control (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde_0(s_tilde_0),
            .s_tilde_1(s_tilde_1),
            .s_tilde_2(s_tilde_2),
            .s_tilde_3(s_tilde_3),
            .s_tilde_4(s_tilde_4),
            .s_0(s_0),
            .s_1(s_1),
            .s_2(s_2),
            .s_3(s_3),
            .s_4(s_4)
    );

    observer observer (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_0(s_0),
            .s_1(s_1),
            .s_2(s_2),
            .s_3(s_3),
            .s_4(s_4),
            .s_tilde_0(s_tilde_0),
            .s_tilde_1(s_tilde_1),
            .s_tilde_2(s_tilde_2),
            .s_tilde_3(s_tilde_3),
            .s_tilde_4(s_tilde_4),
            .u_0(u_0)
    );

endmodule