
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/c_circuit_level/plot_c_testbench.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_c_circuit_level_plot_c_testbench.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_c_circuit_level_plot_c_testbench.py:


======================
Testbench
======================

In this tutorial we expand on the :doc:`./plot_b_analog_frontend`
tutorial by adding a clock and input signal to the analog frontend.
Together, this makes up a full simulation environment where the
analog frontend can be evaluated through simulation. We refer to
such a setup as a testbench.

.. GENERATED FROM PYTHON SOURCE LINES 12-18

.. code-block:: default


    import cbadc
    import numpy as np
    import matplotlib.pyplot as plt
    import copy








.. GENERATED FROM PYTHON SOURCE LINES 19-21

Analog System
---------------

.. GENERATED FROM PYTHON SOURCE LINES 21-56

.. code-block:: default


    # Fix system parameters such as effective number of bits
    ENOB = 16
    # System order
    N = 4
    # Bandwidth
    BW = 1e6

    # Instantiate leap-frog analog system is created as
    target_analog_system, target_digital_control = cbadc.specification.get_leap_frog(
        ENOB=ENOB, N=N, BW=BW
    )

    verilog_analog_system = cbadc.circuit_level.AnalogSystemStateSpaceEquations(
        target_analog_system
    )

    C = 1e-12
    ideal_op_amp_analog_system = cbadc.circuit_level.AnalogSystemIdealOpAmp(
        target_analog_system, C
    )

    A_DC = 2e2
    omega_p = 2 * np.pi * BW / 2

    finite_gain_op_amp_analog_system = cbadc.circuit_level.AnalogSystemFiniteGainOpAmp(
        target_analog_system, C, A_DC
    )

    first_order_pole_op_amp_analog_system = (
        cbadc.circuit_level.AnalogSystemFirstOrderPoleOpAmp(
            target_analog_system, C, A_DC, omega_p
        )
    )








.. GENERATED FROM PYTHON SOURCE LINES 57-63

Digital Control
-----------------------------

To create a verilog-ams digital control model
we use :py:class:cbadc.circuit_level.digital_control.DigitalControl class
as

.. GENERATED FROM PYTHON SOURCE LINES 63-68

.. code-block:: default


    verilog_digital_control = cbadc.circuit_level.DigitalControl(
        copy.deepcopy(target_digital_control)
    )








.. GENERATED FROM PYTHON SOURCE LINES 69-74

Analog Frontend
------------------

Subsequently, the analog frontend can be pertained by the cbadc.circuit_level.AnalogFrontend
class as

.. GENERATED FROM PYTHON SOURCE LINES 74-91

.. code-block:: default


    verilog_analog_frontend = cbadc.circuit_level.AnalogFrontend(
        verilog_analog_system, copy.deepcopy(verilog_digital_control)
    )

    ideal_op_amp_analog_frontend = cbadc.circuit_level.AnalogFrontend(
        ideal_op_amp_analog_system, copy.deepcopy(verilog_digital_control)
    )

    finite_gain_op_amp_analog_frontend = cbadc.circuit_level.AnalogFrontend(
        finite_gain_op_amp_analog_system, copy.deepcopy(verilog_digital_control)
    )

    first_order_pole_op_amp_analog_frontend = cbadc.circuit_level.AnalogFrontend(
        first_order_pole_op_amp_analog_system, copy.deepcopy(verilog_digital_control)
    )








.. GENERATED FROM PYTHON SOURCE LINES 92-97

Input Signal and Simulation Clock
---------------------------------

As in the high level simulation case, we define an input signal
and simulation clock

.. GENERATED FROM PYTHON SOURCE LINES 97-105

.. code-block:: default


    amplitude = 1.0
    frequency = 1.0 / target_digital_control.clock.T
    while frequency > BW:
        frequency /= 2
    input_signal = cbadc.analog_signal.Sinusoidal(amplitude, frequency)
    simulation_clock = cbadc.analog_signal.Clock(target_digital_control.clock.T)








.. GENERATED FROM PYTHON SOURCE LINES 106-111

Testbench
---------

Instantiating the testbench reminds the simulation setup.


.. GENERATED FROM PYTHON SOURCE LINES 111-132

.. code-block:: default


    # determine simulation endtime after 100000 digital control cycles.
    t_stop = target_digital_control.clock.T * 100000

    verilog_testbench = cbadc.circuit_level.TestBench(
        verilog_analog_frontend, input_signal, simulation_clock, t_stop
    )

    ideal_op_amp_testbench = cbadc.circuit_level.TestBench(
        ideal_op_amp_analog_frontend, input_signal, simulation_clock, t_stop
    )

    finite_gain_op_amp_testbench = cbadc.circuit_level.TestBench(
        finite_gain_op_amp_analog_frontend, input_signal, simulation_clock, t_stop
    )

    first_order_pole_op_amp_testbench = cbadc.circuit_level.TestBench(
        first_order_pole_op_amp_analog_frontend, input_signal, simulation_clock, t_stop
    )









.. GENERATED FROM PYTHON SOURCE LINES 133-139

Spice Scripts and Verilog Modules
---------------------------------

Next, the testbenches can be rendered into a spice testbench script
together with the analog frontend verilog module.


.. GENERATED FROM PYTHON SOURCE LINES 139-148

.. code-block:: default


    verilog_testbench.to_file(filename="verilog_testbench")

    ideal_op_amp_testbench.to_file(filename="ideal_op_amp_analog_testbench")

    finite_gain_op_amp_testbench.to_file(filename="finite_gain_op_amp_testbench")

    first_order_pole_op_amp_testbench.to_file(filename="first_order_pole_op_amp_testbench")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/cbadc/circuit_level/op_amp/resistor_network.py:61: RuntimeWarning: divide by zero encountered in double_scalars
      f"[out_{i}] \u2248 [{', '.join([f'{1/a:.2e}' for a in self.G[i, :]])}] [in_{i}]"




.. GENERATED FROM PYTHON SOURCE LINES 149-162

where each generated file can be downloaded below

:download:`verilog_testbench.txt <verilog_testbench.txt>`,
:download:`verilog_analog_frontend.vams <verilog_analog_frontend.vams>`

:download:`ideal_op_amp_analog_testbench.txt <ideal_op_amp_analog_testbench.txt>`,
:download:`ideal_op_amp_analog_frontend.vams <ideal_op_amp_analog_frontend.vams>`

:download:`finite_gain_op_amp_testbench.txt <finite_gain_op_amp_testbench.txt>`,
:download:`finite_gain_op_amp_analog_frontend.vams <finite_gain_op_amp_analog_frontend.vams>`

:download:`first_order_pole_op_amp_testbench.txt <first_order_pole_op_amp_testbench.txt>`,
:download:`first_order_pole_op_amp_analog_frontend.vams <first_order_pole_op_amp_analog_frontend.vams>`

.. GENERATED FROM PYTHON SOURCE LINES 164-167

Simulation and Verification
---------------------------


.. GENERATED FROM PYTHON SOURCE LINES 167-277

.. code-block:: default



    eta2 = (
        np.linalg.norm(
            target_analog_system.transfer_function_matrix(np.array([2 * np.pi * BW]))
        )
        ** 2
    )
    K1 = 1 << 12
    K2 = K1

    digital_estimator_parameters = [cbadc.digital_estimator.FIRFilter, eta2, K1, K2]
    simulation_type = cbadc.simulator.SimulatorType.full_numerical

    compare_systems = {
        'verilog_ideal': {
            "digital_estimator": verilog_testbench.analog_frontend.get_estimator(
                *digital_estimator_parameters
            ),
            "simulator": verilog_testbench.get_simulator(simulation_type),
        },
        'finite_gain op-amp': {
            "digital_estimator": finite_gain_op_amp_testbench.analog_frontend.get_estimator(
                *digital_estimator_parameters
            ),
            "simulator": finite_gain_op_amp_testbench.get_simulator(simulation_type),
        },
        'single_pole op-amp': {
            "digital_estimator": first_order_pole_op_amp_testbench.analog_frontend.get_estimator(
                *digital_estimator_parameters
            ),
            "simulator": first_order_pole_op_amp_testbench.get_simulator(simulation_type),
        },
    }
    BW_log = np.log10(BW)
    frequencies = np.logspace(BW_log - 2, BW_log + 1, 500)
    omegas = 2 * np.pi * frequencies

    # Plot digital estimators transfer functions

    for key, system in compare_systems.items():
        digital_estimator = system['digital_estimator']
        # Compute STF
        stf = digital_estimator.signal_transfer_function(omegas)
        stf_dB = 20 * np.log10(np.abs(stf.flatten()))

        plt.semilogx(frequencies, stf_dB, label="$|STF(\omega)|$ " + key)

    for key, system in compare_systems.items():
        digital_estimator = system['digital_estimator']
        # Compute NTF
        ntf = digital_estimator.noise_transfer_function(omegas)
        ntf_dB = 20 * np.log10(np.abs(ntf))

        plt.semilogx(
            frequencies,
            20 * np.log10(np.linalg.norm(ntf[0, :, :], axis=0)),
            "--",
            label="$ || NTF(\omega) ||_2 $, " + key,
        )

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which="both")
    plt.title("Signal and noise transfer functions")
    plt.xlabel("frequencies [Hz]")
    plt.ylabel("dB")
    plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()

    size = 1 << 15
    u_hat = np.zeros(size)

    plt.figure()
    for key, system in compare_systems.items():
        # Compute NTF
        digital_estimator = system['digital_estimator']
        simulator = system['simulator']
        digital_estimator(simulator)
        for index in range(size):
            u_hat[index] = next(digital_estimator)
        u_hat_cut = u_hat[K1 + K2 :]
        f, psd = cbadc.utilities.compute_power_spectral_density(
            u_hat_cut[:], fs=1 / target_digital_control.clock.T, nperseg=u_hat_cut.size
        )
        signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
        noise_index = np.ones(psd.size, dtype=bool)
        noise_index[signal_index] = False
        noise_index[f < (BW * 1e-2)] = False
        noise_index[f > BW] = False
        fom = cbadc.utilities.snr_spectrum_computation_extended(
            psd, signal_index, noise_index, fs=1 / target_digital_control.clock.T
        )
        est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
        est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
        plt.semilogx(
            f,
            10 * np.log10(np.abs(psd)),
            label=key + f", est_ENOB={est_ENOB:.1f} bits, est_SNR={est_SNR:.1f} dB",
        )


    plt.title("Power spectral density of input estimate")
    plt.xlabel('Hz')
    plt.ylabel('$V^2$ / Hz dB')
    plt.legend()
    plt.grid(which="both")
    plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /tutorials/c_circuit_level/images/sphx_glr_plot_c_testbench_001.png
         :alt: Signal and noise transfer functions
         :srcset: /tutorials/c_circuit_level/images/sphx_glr_plot_c_testbench_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/c_circuit_level/images/sphx_glr_plot_c_testbench_002.png
         :alt: Power spectral density of input estimate
         :srcset: /tutorials/c_circuit_level/images/sphx_glr_plot_c_testbench_002.png
         :class: sphx-glr-multi-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  6.348 seconds)


.. _sphx_glr_download_tutorials_c_circuit_level_plot_c_testbench.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_c_testbench.py <plot_c_testbench.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_c_testbench.ipynb <plot_c_testbench.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
