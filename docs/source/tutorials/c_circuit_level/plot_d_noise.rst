
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/c_circuit_level/plot_d_noise.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_c_circuit_level_plot_d_noise.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_c_circuit_level_plot_d_noise.py:


=========================================
Thermal Noise Simulations
=========================================

In this tutorial we demonstrate how to account for non-idealities
in the design process.

.. GENERATED FROM PYTHON SOURCE LINES 9-17

.. code-block:: default


    import cbadc
    import numpy as np
    import matplotlib.pyplot as plt
    import copy

    np.set_printoptions(precision=1)








.. GENERATED FROM PYTHON SOURCE LINES 18-20

Estimating the Noise Sensitivity of an Analog Frontend
------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 20-30

.. code-block:: default


    N = 5
    ENOB = 16
    BW = 1e7
    SNR_dB = cbadc.fom.enob_to_snr(ENOB)
    snr = cbadc.fom.snr_from_dB(SNR_dB)
    print(f"for an SNR: {SNR_dB:0.1f} dB")
    input_signal_power = 1 / 2.0






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    for an SNR: 98.1 dB




.. GENERATED FROM PYTHON SOURCE LINES 31-33

Setting up the Analog Frontend and Estimators
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 33-63

.. code-block:: default

    analog_frontend = cbadc.synthesis.get_leap_frog(N=N, ENOB=ENOB, BW=BW)
    analog_system = analog_frontend.analog_system
    digital_control = analog_frontend.digital_control

    analog_frontend_ref = cbadc.synthesis.get_leap_frog(N=N, ENOB=ENOB, BW=BW)
    analog_system_ref = analog_frontend_ref.analog_system
    digital_control_ref = analog_frontend_ref.digital_control

    eta2 = (
        np.linalg.norm(analog_system.transfer_function_matrix(np.array([2 * np.pi * BW])))
        ** 2
    )

    K1 = 1 << 10
    K2 = 1 << 10
    digital_estimator = cbadc.digital_estimator.BatchEstimator(
        analog_system, digital_control, eta2, K1, K2
    )
    digital_estimator_ref = cbadc.digital_estimator.BatchEstimator(
        analog_system_ref, digital_control_ref, eta2, K1, K2
    )

    white_noise_sensitivies = digital_estimator.white_noise_sensitivities(
        (BW * 1e-5, BW), snr, input_power=input_signal_power, spectrum=True
    )

    print(
        f"These are the permissable white noise PSDs:\n{white_noise_sensitivies[0,:]} V^2/Hz\n{np.sqrt(white_noise_sensitivies[0,:])} V/sqrt(Hz)"
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    These are the permissable white noise PSDs:
    [1.6e-18 5.5e-16 1.8e-15 1.8e-13 2.2e-12] V^2/Hz
    [1.2e-09 2.4e-08 4.3e-08 4.3e-07 1.5e-06] V/sqrt(Hz)




.. GENERATED FROM PYTHON SOURCE LINES 64-66

White Noise Limited Simulations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 66-154

.. code-block:: default

    plt.figure()
    size = 1 << 14
    u_hat = np.zeros(size)
    u_hat_ref = np.zeros(size)

    # input_signals = [cbadc.analog_signal.ConstantSignal(0.1)]
    input_signals = [
        cbadc.analog_signal.Sinusoidal(1, 1 / (1024 * digital_control.clock.T))
    ]

    for index, thermal_snr_limit in enumerate(
        np.array(
            [
                1e0,
                1e2,
                1e4,
            ]
        )
    ):
        noise_covariance_matrix = np.diag(
            white_noise_sensitivies[0, :] * BW * thermal_snr_limit
        )

        digital_control.reset()
        simulator = cbadc.simulator.PreComputedControlSignalsSimulator(
            analog_system, digital_control, input_signals, cov_x=noise_covariance_matrix
        )
        digital_estimator(simulator)
        digital_estimator.warm_up(K1 + K2)
        for index in cbadc.utilities.show_status(range(size)):
            u_hat[index] = next(digital_estimator)

        u_hat_cut = u_hat[K1 + K2 :]
        f, psd = cbadc.utilities.compute_power_spectral_density(
            u_hat_cut[:], fs=1 / digital_control.clock.T, nperseg=u_hat_cut.size
        )
        signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
        noise_index = np.ones(psd.size, dtype=bool)
        noise_index[signal_index] = False
        noise_index[f < (BW * 1e-2)] = False
        noise_index[f > BW] = False
        fom = cbadc.utilities.snr_spectrum_computation_extended(
            psd, signal_index, noise_index, fs=1 / digital_control.clock.T
        )
        est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
        est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
        plt.semilogx(
            f,
            10 * np.log10(np.abs(psd)),
            label=f"W_N_Limit={10 * np.log10(snr / thermal_snr_limit):.1f} dB, est_SNR={est_SNR:.1f} dB",
        )

    # Reference Simulation

    simulator_ref = cbadc.simulator.PreComputedControlSignalsSimulator(
        analog_system_ref, digital_control_ref, input_signals
    )
    digital_estimator_ref(simulator_ref)
    for index in cbadc.utilities.show_status(range(size)):
        u_hat_ref[index] = next(digital_estimator_ref)

    u_hat_cut = u_hat_ref[K1 + K2 :]
    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_cut[:], fs=1 / digital_control.clock.T, nperseg=u_hat_cut.size
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"Ref, est_SNR={est_SNR:.1f} dB",
    )
    plt.title("Power spectral density of input estimate")
    plt.xlabel('Hz')
    plt.ylabel('$V^2$ / Hz dB')
    plt.ylim((-210, -40))
    plt.legend()
    plt.grid(which="both")
    plt.gcf().tight_layout()




.. image-sg:: /tutorials/c_circuit_level/images/sphx_glr_plot_d_noise_001.png
   :alt: Power spectral density of input estimate
   :srcset: /tutorials/c_circuit_level/images/sphx_glr_plot_d_noise_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0/16384 [00:00<?, ?it/s]      0%|          | 1/16384 [00:01<6:04:54,  1.34s/it]      6%|6         | 1025/16384 [00:02<00:33, 452.65it/s]     13%|#2        | 2049/16384 [00:03<00:23, 599.23it/s]     19%|#8        | 3073/16384 [00:05<00:19, 669.70it/s]     25%|##5       | 4097/16384 [00:06<00:17, 708.10it/s]     31%|###1      | 5121/16384 [00:07<00:15, 732.11it/s]     38%|###7      | 6145/16384 [00:09<00:13, 744.11it/s]     44%|####3     | 7169/16384 [00:10<00:12, 755.62it/s]     50%|#####     | 8193/16384 [00:11<00:10, 761.66it/s]     56%|#####6    | 9217/16384 [00:13<00:09, 765.90it/s]     63%|######2   | 10241/16384 [00:14<00:07, 770.71it/s]     69%|######8   | 11265/16384 [00:15<00:06, 774.87it/s]     75%|#######5  | 12289/16384 [00:17<00:05, 773.79it/s]     81%|########1 | 13313/16384 [00:18<00:03, 775.87it/s]     88%|########7 | 14337/16384 [00:19<00:02, 777.98it/s]     94%|#########3| 15361/16384 [00:21<00:01, 779.74it/s]    100%|##########| 16384/16384 [00:21<00:00, 776.83it/s]
      0%|          | 0/16384 [00:00<?, ?it/s]      0%|          | 1/16384 [00:01<6:01:36,  1.32s/it]      6%|6         | 1025/16384 [00:02<00:33, 455.74it/s]     13%|#2        | 2049/16384 [00:03<00:23, 602.41it/s]     19%|#8        | 3073/16384 [00:05<00:19, 668.80it/s]     25%|##5       | 4097/16384 [00:06<00:17, 706.78it/s]     31%|###1      | 5121/16384 [00:07<00:15, 729.86it/s]     38%|###7      | 6145/16384 [00:09<00:13, 747.57it/s]     44%|####3     | 7169/16384 [00:10<00:12, 754.18it/s]     50%|#####     | 8193/16384 [00:11<00:10, 746.01it/s]     56%|#####6    | 9217/16384 [00:13<00:09, 752.89it/s]     63%|######2   | 10241/16384 [00:14<00:08, 758.88it/s]     69%|######8   | 11265/16384 [00:15<00:06, 763.98it/s]     75%|#######5  | 12289/16384 [00:17<00:05, 766.47it/s]     81%|########1 | 13313/16384 [00:18<00:03, 771.76it/s]     88%|########7 | 14337/16384 [00:19<00:02, 770.62it/s]     94%|#########3| 15361/16384 [00:21<00:01, 770.94it/s]    100%|##########| 16384/16384 [00:21<00:00, 770.98it/s]
      0%|          | 0/16384 [00:00<?, ?it/s]      0%|          | 1/16384 [00:01<5:56:06,  1.30s/it]      6%|6         | 1025/16384 [00:02<00:33, 457.88it/s]     13%|#2        | 2049/16384 [00:03<00:23, 606.21it/s]     19%|#8        | 3073/16384 [00:05<00:19, 674.61it/s]     25%|##5       | 4097/16384 [00:06<00:17, 709.26it/s]     31%|###1      | 5121/16384 [00:07<00:15, 729.10it/s]     38%|###7      | 6145/16384 [00:09<00:13, 746.17it/s]     44%|####3     | 7169/16384 [00:10<00:12, 758.06it/s]     50%|#####     | 8193/16384 [00:11<00:10, 765.84it/s]     56%|#####6    | 9217/16384 [00:13<00:09, 768.86it/s]     63%|######2   | 10241/16384 [00:14<00:07, 770.77it/s]     69%|######8   | 11265/16384 [00:15<00:06, 773.52it/s]     75%|#######5  | 12289/16384 [00:17<00:05, 773.28it/s]     81%|########1 | 13313/16384 [00:18<00:03, 773.63it/s]     88%|########7 | 14337/16384 [00:19<00:02, 768.59it/s]     94%|#########3| 15361/16384 [00:21<00:01, 764.76it/s]    100%|##########| 16384/16384 [00:21<00:00, 774.73it/s]
      0%|          | 0/16384 [00:00<?, ?it/s]      0%|          | 1/16384 [00:02<11:52:23,  2.61s/it]      6%|6         | 1025/16384 [00:03<00:47, 326.69it/s]     13%|#2        | 2049/16384 [00:05<00:29, 493.38it/s]     19%|#8        | 3073/16384 [00:06<00:22, 594.31it/s]     25%|##5       | 4097/16384 [00:07<00:18, 656.62it/s]     31%|###1      | 5121/16384 [00:09<00:16, 696.30it/s]     38%|###7      | 6145/16384 [00:10<00:14, 724.32it/s]     44%|####3     | 7169/16384 [00:11<00:12, 743.83it/s]     50%|#####     | 8193/16384 [00:13<00:10, 755.84it/s]     56%|#####6    | 9217/16384 [00:14<00:09, 763.27it/s]     63%|######2   | 10241/16384 [00:15<00:08, 762.74it/s]     69%|######8   | 11265/16384 [00:17<00:06, 767.19it/s]     75%|#######5  | 12289/16384 [00:18<00:05, 771.15it/s]     81%|########1 | 13313/16384 [00:19<00:03, 774.52it/s]     88%|########7 | 14337/16384 [00:20<00:02, 776.67it/s]     94%|#########3| 15361/16384 [00:22<00:01, 780.09it/s]    100%|##########| 16384/16384 [00:22<00:00, 734.86it/s]




.. GENERATED FROM PYTHON SOURCE LINES 155-158

Circuit Level Thermal Noise Sizing
----------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 158-204

.. code-block:: default

    analog_frontend = cbadc.synthesis.get_leap_frog(N=N, ENOB=ENOB, BW=BW)
    analog_system = analog_frontend.analog_system
    digital_control = analog_frontend.digital_control

    A_DC = 1e4
    omega_p = 2 * np.pi * BW

    digital_estimator = cbadc.digital_estimator.BatchEstimator(
        analog_system, digital_control, eta2, K1, K2
    )

    verilog_digital_control = cbadc.circuit_level.DigitalControl(
        copy.deepcopy(digital_control)
    )

    first_order_pole_op_amp_analog_system = (
        cbadc.circuit_level.AnalogSystemFirstOrderPoleOpAmp(
            BW=(BW * 1e-5, BW),
            target_snr=snr,
            digital_estimator=digital_estimator,
            A_DC=A_DC,
            omega_p=omega_p,
        )
    )

    first_order_pole_op_amp_analog_frontend = cbadc.circuit_level.AnalogFrontend(
        first_order_pole_op_amp_analog_system, verilog_digital_control
    )

    t_stop = digital_control.clock.T * (size + K1 + K2)
    simulation_clock = cbadc.analog_signal.Clock(digital_control.clock.T)

    first_order_pole_op_amp_testbench = cbadc.circuit_level.TestBench(
        first_order_pole_op_amp_analog_frontend,
        input_signals[0],
        simulation_clock,
        t_stop,
    )

    print(f"Capacitor values:\n{first_order_pole_op_amp_analog_system.C_diag}")
    print(f"\n\nResistor network A: {first_order_pole_op_amp_analog_system._A_G_matrix}")
    print(f"\n\nResistor network B: {first_order_pole_op_amp_analog_system._B_G_matrix}")
    print(
        f"\n\nResistor network Gamma: {first_order_pole_op_amp_analog_system._Gamma_G_matrix}"
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Capacitor values:
    [[2.9e-11 0.0e+00 0.0e+00 0.0e+00 0.0e+00]
     [0.0e+00 8.0e-14 0.0e+00 0.0e+00 0.0e+00]
     [0.0e+00 0.0e+00 2.4e-14 0.0e+00 0.0e+00]
     [0.0e+00 0.0e+00 0.0e+00 2.4e-16 0.0e+00]
     [0.0e+00 0.0e+00 0.0e+00 0.0e+00 2.1e-17]]
    /Users/hammal/miniforge3/lib/python3.9/site-packages/cbadc/circuit_level/op_amp/resistor_network.py:61: RuntimeWarning: divide by zero encountered in double_scalars
      f"[out_{i}] \u2248 [{', '.join([f'{1.0/a:.2e}' for a in self.G[i, :]])}] [in_{i}]"


    Resistor network A: resistor_network_a

    Ports: in_0, in_1, in_2, in_3, in_4, out_0, out_1, out_2, out_3, out_4

    Parameters: 

    Functional Description:

    Resistor network connecting inputs and outputs according to the following matrix

    [out_0] ≈ [-inf, -6.54e+03, -inf, -inf, -inf] [in_0]
    [out_1] ≈ [6.78e+04, -inf, -2.33e+06, -inf, -inf] [in_1]
    [out_2] ≈ [-inf, 2.25e+05, -inf, -7.76e+06, -inf] [in_2]
    [out_3] ≈ [-inf, -inf, 2.23e+07, -inf, -7.69e+08] [in_3]
    [out_4] ≈ [-inf, -inf, -inf, 2.63e+08, -inf] [in_4]

    note the resistors are specified by their resistive values in Ohms


    Resistor network B: resistor_network_b

    Ports: in_0, out_0, out_1, out_2, out_3, out_4

    Parameters: 

    Functional Description:

    Resistor network connecting inputs and outputs according to the following matrix

    [out_0] ≈ [1.90e+02] [in_0]
    [out_1] ≈ [-inf] [in_1]
    [out_2] ≈ [-inf] [in_2]
    [out_3] ≈ [-inf] [in_3]
    [out_4] ≈ [-inf] [in_4]

    note the resistors are specified by their resistive values in Ohms


    Resistor network Gamma: resistor_network_gamma

    Ports: in_0, in_1, in_2, in_3, in_4, out_0, out_1, out_2, out_3, out_4

    Parameters: 

    Functional Description:

    Resistor network connecting inputs and outputs according to the following matrix

    [out_0] ≈ [1.90e+02, -inf, -inf, -inf, -inf] [in_0]
    [out_1] ≈ [-inf, 6.78e+04, -inf, -inf, -inf] [in_1]
    [out_2] ≈ [-inf, -inf, 2.25e+05, -inf, -inf] [in_2]
    [out_3] ≈ [-inf, -inf, -inf, 2.23e+07, -inf] [in_3]
    [out_4] ≈ [-inf, -inf, -inf, -inf, 2.63e+08] [in_4]

    note the resistors are specified by their resistive values in Ohms




.. GENERATED FROM PYTHON SOURCE LINES 205-207

Plotting the Power Spectral Densities
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 207-254

.. code-block:: default


    plt.figure()
    digital_estimator = first_order_pole_op_amp_analog_frontend.get_estimator(
        cbadc.digital_estimator.FIRFilter, eta2, K1, K2
    )
    white_noise_sensitivies = digital_estimator.white_noise_sensitivities(
        (BW * 1e-5, BW), snr, input_power=input_signal_power, spectrum=True
    )
    print(
        f"These are the permissable white noise PSDs:\n{white_noise_sensitivies[0,:]} V^2/Hz\n{np.sqrt(white_noise_sensitivies[0,:])} V/sqrt(Hz)"
    )
    noise_covariance_matrix = np.diag(white_noise_sensitivies[0, :] * BW)
    simulator = first_order_pole_op_amp_testbench.get_simulator(
        cbadc.simulator.SimulatorType.full_numerical, cov_x=noise_covariance_matrix
    )
    digital_estimator(simulator)
    for index in range(size):
        u_hat[index] = next(digital_estimator)
    u_hat_cut = u_hat[K1 + K2 :]
    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_cut[:], fs=1 / digital_control.clock.T, nperseg=u_hat_cut.size
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"est_ENOB={est_ENOB:.1f} bits, est_SNR={est_SNR:.1f} dB",
    )


    plt.title("Power spectral density of input estimate")
    plt.xlabel('Hz')
    plt.ylabel('$V^2$ / Hz dB')
    plt.legend()
    plt.grid(which="both")
    # plt.xlim((f[0], f[-1]))
    plt.gcf().tight_layout()




.. image-sg:: /tutorials/c_circuit_level/images/sphx_glr_plot_d_noise_002.png
   :alt: Power spectral density of input estimate
   :srcset: /tutorials/c_circuit_level/images/sphx_glr_plot_d_noise_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    These are the permissable white noise PSDs:
    [7.8e-19 2.8e-16 9.2e-16 9.1e-14 1.1e-12 7.8e-19 2.8e-16 9.2e-16 9.1e-14
     1.1e-12] V^2/Hz
    [8.8e-10 1.7e-08 3.0e-08 3.0e-07 1.0e-06 8.8e-10 1.7e-08 3.0e-08 3.0e-07
     1.0e-06] V/sqrt(Hz)





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 17 minutes  11.884 seconds)


.. _sphx_glr_download_tutorials_c_circuit_level_plot_d_noise.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_d_noise.py <plot_d_noise.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_d_noise.ipynb <plot_d_noise.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
