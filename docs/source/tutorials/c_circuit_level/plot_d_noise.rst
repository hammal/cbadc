
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/c_circuit_level/plot_d_noise.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_c_circuit_level_plot_d_noise.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_c_circuit_level_plot_d_noise.py:


=========================================
Thermal Noise Simulations
=========================================

In this tutorial we demonstrate how to account for non-idealities
in the design process.

.. GENERATED FROM PYTHON SOURCE LINES 9-17

.. code-block:: default


    import cbadc
    import numpy as np
    import matplotlib.pyplot as plt
    import copy

    np.set_printoptions(precision=1)








.. GENERATED FROM PYTHON SOURCE LINES 18-20

Estimating the Noise Sensitivity of an Analog Frontend
------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 20-30

.. code-block:: default


    N = 5
    ENOB = 16
    BW = 1e7
    SNR_dB = cbadc.fom.enob_to_snr(ENOB)
    snr = cbadc.fom.snr_from_dB(SNR_dB)
    print(f"for an SNR: {SNR_dB:0.1f} dB")
    input_signal_power = 1 / 2.0






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    for an SNR: 98.1 dB




.. GENERATED FROM PYTHON SOURCE LINES 31-33

Setting up the Analog Frontend and Estimators
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 33-63

.. code-block:: default

    analog_frontend = cbadc.synthesis.get_leap_frog(N=N, ENOB=ENOB, BW=BW)
    analog_system = analog_frontend.analog_system
    digital_control = analog_frontend.digital_control

    analog_frontend_ref = cbadc.synthesis.get_leap_frog(N=N, ENOB=ENOB, BW=BW)
    analog_system_ref = analog_frontend_ref.analog_system
    digital_control_ref = analog_frontend_ref.digital_control

    eta2 = (
        np.linalg.norm(analog_system.transfer_function_matrix(np.array([2 * np.pi * BW])))
        ** 2
    )

    K1 = 1 << 10
    K2 = 1 << 10
    digital_estimator = cbadc.digital_estimator.BatchEstimator(
        analog_system, digital_control, eta2, K1, K2
    )
    digital_estimator_ref = cbadc.digital_estimator.BatchEstimator(
        analog_system_ref, digital_control_ref, eta2, K1, K2
    )

    white_noise_sensitivies = digital_estimator.white_noise_sensitivities(
        (BW * 1e-5, BW), snr, input_power=input_signal_power, spectrum=True
    )

    print(
        f"These are the permissable white noise PSDs:\n{white_noise_sensitivies[0,:]} V^2/Hz\n{np.sqrt(white_noise_sensitivies[0,:])} V/sqrt(Hz)"
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    These are the permissable white noise PSDs:
    [1.6e-18 5.5e-16 1.8e-15 1.8e-13 2.2e-12] V^2/Hz
    [1.2e-09 2.4e-08 4.3e-08 4.3e-07 1.5e-06] V/sqrt(Hz)




.. GENERATED FROM PYTHON SOURCE LINES 64-66

White Noise Limited Simulations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 66-154

.. code-block:: default

    plt.figure()
    size = 1 << 14
    u_hat = np.zeros(size)
    u_hat_ref = np.zeros(size)

    # input_signals = [cbadc.analog_signal.ConstantSignal(0.1)]
    input_signals = [
        cbadc.analog_signal.Sinusoidal(1, 1 / (1024 * digital_control.clock.T))
    ]

    for index, thermal_snr_limit in enumerate(
        np.array(
            [
                1e0,
                1e2,
                1e4,
            ]
        )
    ):
        noise_covariance_matrix = np.diag(
            white_noise_sensitivies[0, :] * BW * thermal_snr_limit
        )

        digital_control.reset()
        simulator = cbadc.simulator.FullSimulator(
            analog_system, digital_control, input_signals, cov_x=noise_covariance_matrix
        )
        digital_estimator(simulator)
        digital_estimator.warm_up(K1 + K2)
        for index in cbadc.utilities.show_status(range(size)):
            u_hat[index] = next(digital_estimator)

        u_hat_cut = u_hat[K1 + K2 :]
        f, psd = cbadc.utilities.compute_power_spectral_density(
            u_hat_cut[:], fs=1 / digital_control.clock.T, nperseg=u_hat_cut.size
        )
        signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
        noise_index = np.ones(psd.size, dtype=bool)
        noise_index[signal_index] = False
        noise_index[f < (BW * 1e-2)] = False
        noise_index[f > BW] = False
        fom = cbadc.utilities.snr_spectrum_computation_extended(
            psd, signal_index, noise_index, fs=1 / digital_control.clock.T
        )
        est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
        est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
        plt.semilogx(
            f,
            10 * np.log10(np.abs(psd)),
            label=f"W_N_Limit={10 * np.log10(snr / thermal_snr_limit):.1f} dB, est_SNR={est_SNR:.1f} dB",
        )

    # Reference Simulation

    simulator_ref = cbadc.simulator.FullSimulator(
        analog_system_ref, digital_control_ref, input_signals
    )
    digital_estimator_ref(simulator_ref)
    for index in cbadc.utilities.show_status(range(size)):
        u_hat_ref[index] = next(digital_estimator_ref)

    u_hat_cut = u_hat_ref[K1 + K2 :]
    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_cut[:], fs=1 / digital_control.clock.T, nperseg=u_hat_cut.size
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"Ref, est_SNR={est_SNR:.1f} dB",
    )
    plt.title("Power spectral density of input estimate")
    plt.xlabel('Hz')
    plt.ylabel('$V^2$ / Hz dB')
    plt.ylim((-210, -40))
    plt.legend()
    plt.grid(which="both")
    plt.gcf().tight_layout()




.. image-sg:: /tutorials/c_circuit_level/images/sphx_glr_plot_d_noise_001.png
   :alt: Power spectral density of input estimate
   :srcset: /tutorials/c_circuit_level/images/sphx_glr_plot_d_noise_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0/16384 [00:00<?, ?it/s]      0%|          | 1/16384 [00:03<14:28:47,  3.18s/it]      6%|6         | 1025/16384 [00:06<01:21, 188.92it/s]     13%|#2        | 2049/16384 [00:09<00:58, 246.19it/s]     19%|#8        | 3073/16384 [00:12<00:48, 274.63it/s]     25%|##5       | 4097/16384 [00:16<00:42, 291.08it/s]     31%|###1      | 5121/16384 [00:19<00:37, 301.17it/s]     38%|###7      | 6145/16384 [00:22<00:33, 306.94it/s]     44%|####3     | 7169/16384 [00:25<00:29, 310.65it/s]     50%|#####     | 8193/16384 [00:28<00:26, 313.10it/s]     56%|#####6    | 9217/16384 [00:32<00:22, 313.55it/s]     63%|######2   | 10241/16384 [00:35<00:19, 314.55it/s]     69%|######8   | 11265/16384 [00:38<00:16, 315.41it/s]     75%|#######5  | 12289/16384 [00:41<00:12, 316.12it/s]     81%|########1 | 13313/16384 [00:45<00:09, 316.65it/s]     88%|########7 | 14337/16384 [00:48<00:06, 317.31it/s]     94%|#########3| 15361/16384 [00:51<00:03, 317.40it/s]    100%|##########| 16384/16384 [00:51<00:00, 318.18it/s]
      0%|          | 0/16384 [00:00<?, ?it/s]      0%|          | 1/16384 [00:03<14:30:49,  3.19s/it]      6%|6         | 1025/16384 [00:06<01:21, 189.01it/s]     13%|#2        | 2049/16384 [00:09<00:57, 248.48it/s]     19%|#8        | 3073/16384 [00:12<00:48, 275.70it/s]     25%|##5       | 4097/16384 [00:16<00:42, 288.39it/s]     31%|###1      | 5121/16384 [00:19<00:37, 298.79it/s]     38%|###7      | 6145/16384 [00:22<00:33, 304.96it/s]     44%|####3     | 7169/16384 [00:25<00:29, 310.10it/s]     50%|#####     | 8193/16384 [00:28<00:26, 313.84it/s]     56%|#####6    | 9217/16384 [00:32<00:22, 316.24it/s]     63%|######2   | 10241/16384 [00:35<00:19, 318.00it/s]     69%|######8   | 11265/16384 [00:38<00:16, 319.18it/s]     75%|#######5  | 12289/16384 [00:41<00:12, 320.27it/s]     81%|########1 | 13313/16384 [00:44<00:09, 321.00it/s]     88%|########7 | 14337/16384 [00:47<00:06, 321.01it/s]     94%|#########3| 15361/16384 [00:51<00:03, 320.54it/s]    100%|##########| 16384/16384 [00:51<00:00, 319.97it/s]
      0%|          | 0/16384 [00:00<?, ?it/s]      0%|          | 1/16384 [00:03<13:45:27,  3.02s/it]      6%|6         | 1025/16384 [00:06<01:17, 197.56it/s]     13%|#2        | 2049/16384 [00:09<00:54, 260.91it/s]     19%|#8        | 3073/16384 [00:12<00:45, 291.13it/s]     25%|##5       | 4097/16384 [00:15<00:39, 307.87it/s]     31%|###1      | 5121/16384 [00:18<00:35, 318.87it/s]     38%|###7      | 6145/16384 [00:21<00:31, 325.92it/s]     44%|####3     | 7169/16384 [00:24<00:27, 330.91it/s]     50%|#####     | 8193/16384 [00:27<00:24, 333.67it/s]     56%|#####6    | 9217/16384 [00:30<00:21, 335.84it/s]     63%|######2   | 10241/16384 [00:33<00:18, 336.98it/s]     69%|######8   | 11265/16384 [00:36<00:15, 337.51it/s]     75%|#######5  | 12289/16384 [00:39<00:12, 337.79it/s]     81%|########1 | 13313/16384 [00:42<00:09, 338.11it/s]     88%|########7 | 14337/16384 [00:45<00:06, 338.77it/s]     94%|#########3| 15361/16384 [00:48<00:03, 339.20it/s]    100%|##########| 16384/16384 [00:48<00:00, 338.93it/s]
      0%|          | 0/16384 [00:00<?, ?it/s]      0%|          | 1/16384 [00:06<28:56:53,  6.36s/it]      6%|6         | 1025/16384 [00:09<01:54, 133.97it/s]     13%|#2        | 2049/16384 [00:12<01:10, 203.87it/s]     19%|#8        | 3073/16384 [00:15<00:54, 244.36it/s]     25%|##5       | 4097/16384 [00:19<00:45, 269.75it/s]     31%|###1      | 5121/16384 [00:22<00:39, 286.72it/s]     38%|###7      | 6145/16384 [00:25<00:34, 297.45it/s]     44%|####3     | 7169/16384 [00:28<00:30, 304.08it/s]     50%|#####     | 8193/16384 [00:31<00:26, 308.80it/s]     56%|#####6    | 9217/16384 [00:35<00:22, 312.76it/s]     63%|######2   | 10241/16384 [00:38<00:19, 315.36it/s]     69%|######8   | 11265/16384 [00:41<00:16, 317.08it/s]     75%|#######5  | 12289/16384 [00:44<00:12, 316.98it/s]     81%|########1 | 13313/16384 [00:47<00:09, 318.43it/s]     88%|########7 | 14337/16384 [00:51<00:06, 319.17it/s]     94%|#########3| 15361/16384 [00:54<00:03, 319.56it/s]    100%|##########| 16384/16384 [00:54<00:00, 301.84it/s]




.. GENERATED FROM PYTHON SOURCE LINES 155-158

Circuit Level Thermal Noise Sizing
----------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 158-204

.. code-block:: default

    analog_frontend = cbadc.synthesis.get_leap_frog(N=N, ENOB=ENOB, BW=BW)
    analog_system = analog_frontend.analog_system
    digital_control = analog_frontend.digital_control

    A_DC = 1e4
    omega_p = 2 * np.pi * BW

    digital_estimator = cbadc.digital_estimator.BatchEstimator(
        analog_system, digital_control, eta2, K1, K2
    )

    verilog_digital_control = cbadc.circuit_level.DigitalControl(
        copy.deepcopy(digital_control)
    )

    first_order_pole_op_amp_analog_system = (
        cbadc.circuit_level.AnalogSystemFirstOrderPoleOpAmp(
            BW=(BW * 1e-5, BW),
            target_snr=snr,
            digital_estimator=digital_estimator,
            A_DC=A_DC,
            omega_p=omega_p,
        )
    )

    first_order_pole_op_amp_analog_frontend = cbadc.circuit_level.AnalogFrontend(
        first_order_pole_op_amp_analog_system, verilog_digital_control
    )

    t_stop = digital_control.clock.T * (size + K1 + K2)
    simulation_clock = cbadc.analog_signal.Clock(digital_control.clock.T)

    first_order_pole_op_amp_testbench = cbadc.circuit_level.TestBench(
        first_order_pole_op_amp_analog_frontend,
        input_signals[0],
        simulation_clock,
        t_stop,
    )

    print(f"Capacitor values:\n{first_order_pole_op_amp_analog_system.C_diag}")
    print(f"\n\nResistor network A: {first_order_pole_op_amp_analog_system._A_G_matrix}")
    print(f"\n\nResistor network B: {first_order_pole_op_amp_analog_system._B_G_matrix}")
    print(
        f"\n\nResistor network Gamma: {first_order_pole_op_amp_analog_system._Gamma_G_matrix}"
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Capacitor values:
    [[2.9e-11 0.0e+00 0.0e+00 0.0e+00 0.0e+00]
     [0.0e+00 8.0e-14 0.0e+00 0.0e+00 0.0e+00]
     [0.0e+00 0.0e+00 2.4e-14 0.0e+00 0.0e+00]
     [0.0e+00 0.0e+00 0.0e+00 2.4e-16 0.0e+00]
     [0.0e+00 0.0e+00 0.0e+00 0.0e+00 2.1e-17]]
    /Users/hammal/miniforge3/lib/python3.9/site-packages/cbadc/circuit_level/op_amp/resistor_network.py:61: RuntimeWarning: divide by zero encountered in true_divide
      f"[out_{i}] \u2248 [{', '.join([f'{np.divide(1, a):.2e}' for a in self.G[i, :]])}] [in_{i}]"


    Resistor network A: resistor_network_a

    Ports: in_0, in_1, in_2, in_3, in_4, out_0, out_1, out_2, out_3, out_4

    Parameters: 

    Functional Description:

    Resistor network connecting inputs and outputs according to the following matrix

    [out_0] ≈ [-inf, -6.54e+03, -inf, -inf, -inf] [in_0]
    [out_1] ≈ [6.78e+04, -inf, -2.33e+06, -inf, -inf] [in_1]
    [out_2] ≈ [-inf, 2.25e+05, -inf, -7.76e+06, -inf] [in_2]
    [out_3] ≈ [-inf, -inf, 2.23e+07, -inf, -7.69e+08] [in_3]
    [out_4] ≈ [-inf, -inf, -inf, 2.63e+08, -inf] [in_4]

    note the resistors are specified by their resistive values in Ohms


    Resistor network B: resistor_network_b

    Ports: in_0, out_0, out_1, out_2, out_3, out_4

    Parameters: 

    Functional Description:

    Resistor network connecting inputs and outputs according to the following matrix

    [out_0] ≈ [1.90e+02] [in_0]
    [out_1] ≈ [-inf] [in_1]
    [out_2] ≈ [-inf] [in_2]
    [out_3] ≈ [-inf] [in_3]
    [out_4] ≈ [-inf] [in_4]

    note the resistors are specified by their resistive values in Ohms


    Resistor network Gamma: resistor_network_gamma

    Ports: in_0, in_1, in_2, in_3, in_4, out_0, out_1, out_2, out_3, out_4

    Parameters: 

    Functional Description:

    Resistor network connecting inputs and outputs according to the following matrix

    [out_0] ≈ [1.90e+02, -inf, -inf, -inf, -inf] [in_0]
    [out_1] ≈ [-inf, 6.78e+04, -inf, -inf, -inf] [in_1]
    [out_2] ≈ [-inf, -inf, 2.25e+05, -inf, -inf] [in_2]
    [out_3] ≈ [-inf, -inf, -inf, 2.23e+07, -inf] [in_3]
    [out_4] ≈ [-inf, -inf, -inf, -inf, 2.63e+08] [in_4]

    note the resistors are specified by their resistive values in Ohms




.. GENERATED FROM PYTHON SOURCE LINES 205-207

Plotting the Power Spectral Densities
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 207-254

.. code-block:: default


    plt.figure()
    digital_estimator = first_order_pole_op_amp_analog_frontend.get_estimator(
        cbadc.digital_estimator.FIRFilter, eta2, K1, K2
    )
    white_noise_sensitivies = digital_estimator.white_noise_sensitivities(
        (BW * 1e-5, BW), snr, input_power=input_signal_power, spectrum=True
    )
    print(
        f"These are the permissable white noise PSDs:\n{white_noise_sensitivies[0,:]} V^2/Hz\n{np.sqrt(white_noise_sensitivies[0,:])} V/sqrt(Hz)"
    )
    noise_covariance_matrix = np.diag(white_noise_sensitivies[0, :] * BW)
    simulator = first_order_pole_op_amp_testbench.get_simulator(
        cbadc.simulator.SimulatorType.full_numerical, cov_x=noise_covariance_matrix
    )
    digital_estimator(simulator)
    for index in range(size):
        u_hat[index] = next(digital_estimator)
    u_hat_cut = u_hat[K1 + K2 :]
    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_cut[:], fs=1 / digital_control.clock.T, nperseg=u_hat_cut.size
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"est_ENOB={est_ENOB:.1f} bits, est_SNR={est_SNR:.1f} dB",
    )


    plt.title("Power spectral density of input estimate")
    plt.xlabel('Hz')
    plt.ylabel('$V^2$ / Hz dB')
    plt.legend()
    plt.grid(which="both")
    # plt.xlim((f[0], f[-1]))
    plt.gcf().tight_layout()




.. image-sg:: /tutorials/c_circuit_level/images/sphx_glr_plot_d_noise_002.png
   :alt: Power spectral density of input estimate
   :srcset: /tutorials/c_circuit_level/images/sphx_glr_plot_d_noise_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    These are the permissable white noise PSDs:
    [7.8e-19 2.8e-16 9.2e-16 9.1e-14 1.1e-12 7.8e-19 2.8e-16 9.2e-16 9.1e-14
     1.1e-12] V^2/Hz
    [8.8e-10 1.7e-08 3.0e-08 3.0e-07 1.0e-06 8.8e-10 1.7e-08 3.0e-08 3.0e-07
     1.0e-06] V/sqrt(Hz)





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 19 minutes  17.856 seconds)


.. _sphx_glr_download_tutorials_c_circuit_level_plot_d_noise.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_d_noise.py <plot_d_noise.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_d_noise.ipynb <plot_d_noise.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
