
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/c_circuit_level/plot_d_noise.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_c_circuit_level_plot_d_noise.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_c_circuit_level_plot_d_noise.py:


=========================================
Thermal Noise Simulations
=========================================

In this tutorial we demonstrate how to account for non-idealities
in the design process.

.. GENERATED FROM PYTHON SOURCE LINES 9-17

.. code-block:: default


    import cbadc
    import numpy as np
    import matplotlib.pyplot as plt
    import copy

    np.set_printoptions(precision=1)








.. GENERATED FROM PYTHON SOURCE LINES 18-20

Estimating the Noise Sensitivity of an Analog Frontend
------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 20-30

.. code-block:: default


    N = 5
    ENOB = 16
    BW = 1e7
    SNR_dB = cbadc.fom.enob_to_snr(ENOB)
    snr = cbadc.fom.snr_from_dB(SNR_dB)
    print(f"for an SNR: {SNR_dB:0.1f} dB")
    input_signal_power = 1 / 2.0






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    for an SNR: 98.1 dB




.. GENERATED FROM PYTHON SOURCE LINES 31-33

Setting up the Analog Frontend and Estimators
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 33-63

.. code-block:: default

    analog_frontend = cbadc.synthesis.get_leap_frog(N=N, ENOB=ENOB, BW=BW)
    analog_system = analog_frontend.analog_system
    digital_control = analog_frontend.digital_control

    analog_frontend_ref = cbadc.synthesis.get_leap_frog(N=N, ENOB=ENOB, BW=BW)
    analog_system_ref = analog_frontend_ref.analog_system
    digital_control_ref = analog_frontend_ref.digital_control

    eta2 = (
        np.linalg.norm(analog_system.transfer_function_matrix(np.array([2 * np.pi * BW])))
        ** 2
    )

    K1 = 1 << 10
    K2 = 1 << 10
    digital_estimator = cbadc.digital_estimator.BatchEstimator(
        analog_system, digital_control, eta2, K1, K2
    )
    digital_estimator_ref = cbadc.digital_estimator.BatchEstimator(
        analog_system_ref, digital_control_ref, eta2, K1, K2
    )

    white_noise_sensitivies = digital_estimator.white_noise_sensitivities(
        (BW * 1e-5, BW), snr, input_power=input_signal_power, spectrum=True
    )

    print(
        f"These are the permissable white noise PSDs:\n{white_noise_sensitivies[0,:]} V^2/Hz\n{np.sqrt(white_noise_sensitivies[0,:])} V/sqrt(Hz)"
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    These are the permissable white noise PSDs:
    [1.6e-18 5.5e-16 1.8e-15 1.8e-13 2.2e-12] V^2/Hz
    [1.2e-09 2.4e-08 4.3e-08 4.3e-07 1.5e-06] V/sqrt(Hz)




.. GENERATED FROM PYTHON SOURCE LINES 64-66

White Noise Limited Simulations
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 66-154

.. code-block:: default

    plt.figure()
    size = 1 << 14
    u_hat = np.zeros(size)
    u_hat_ref = np.zeros(size)

    # input_signals = [cbadc.analog_signal.ConstantSignal(0.1)]
    input_signals = [
        cbadc.analog_signal.Sinusoidal(1, 1 / (1024 * digital_control.clock.T))
    ]

    for index, thermal_snr_limit in enumerate(
        np.array(
            [
                1e0,
                1e2,
                1e4,
            ]
        )
    ):
        noise_covariance_matrix = np.diag(
            white_noise_sensitivies[0, :] * BW * thermal_snr_limit
        )

        digital_control.reset()
        simulator = cbadc.simulator.FullSimulator(
            analog_system, digital_control, input_signals, cov_x=noise_covariance_matrix
        )
        digital_estimator(simulator)
        digital_estimator.warm_up(K1 + K2)
        for index in cbadc.utilities.show_status(range(size)):
            u_hat[index] = next(digital_estimator)

        u_hat_cut = u_hat[K1 + K2 :]
        f, psd = cbadc.utilities.compute_power_spectral_density(
            u_hat_cut[:], fs=1 / digital_control.clock.T, nperseg=u_hat_cut.size
        )
        signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
        noise_index = np.ones(psd.size, dtype=bool)
        noise_index[signal_index] = False
        noise_index[f < (BW * 1e-2)] = False
        noise_index[f > BW] = False
        fom = cbadc.utilities.snr_spectrum_computation_extended(
            psd, signal_index, noise_index, fs=1 / digital_control.clock.T
        )
        est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
        est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
        plt.semilogx(
            f,
            10 * np.log10(np.abs(psd)),
            label=f"W_N_Limit={10 * np.log10(snr / thermal_snr_limit):.1f} dB, est_SNR={est_SNR:.1f} dB",
        )

    # Reference Simulation

    simulator_ref = cbadc.simulator.FullSimulator(
        analog_system_ref, digital_control_ref, input_signals
    )
    digital_estimator_ref(simulator_ref)
    for index in cbadc.utilities.show_status(range(size)):
        u_hat_ref[index] = next(digital_estimator_ref)

    u_hat_cut = u_hat_ref[K1 + K2 :]
    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_cut[:], fs=1 / digital_control.clock.T, nperseg=u_hat_cut.size
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"Ref, est_SNR={est_SNR:.1f} dB",
    )
    plt.title("Power spectral density of input estimate")
    plt.xlabel('Hz')
    plt.ylabel('$V^2$ / Hz dB')
    plt.ylim((-210, -40))
    plt.legend()
    plt.grid(which="both")
    plt.gcf().tight_layout()




.. image-sg:: /tutorials/c_circuit_level/images/sphx_glr_plot_d_noise_001.png
   :alt: Power spectral density of input estimate
   :srcset: /tutorials/c_circuit_level/images/sphx_glr_plot_d_noise_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0/16384 [00:00<?, ?it/s]      0%|          | 1/16384 [00:03<14:54:32,  3.28s/it]      6%|6         | 1025/16384 [00:06<01:23, 184.68it/s]     13%|#2        | 2049/16384 [00:09<00:58, 243.67it/s]     19%|#8        | 3073/16384 [00:13<00:48, 271.97it/s]     25%|##5       | 4097/16384 [00:16<00:42, 287.37it/s]     31%|###1      | 5121/16384 [00:19<00:37, 296.54it/s]     38%|###7      | 6145/16384 [00:22<00:33, 302.55it/s]     44%|####3     | 7169/16384 [00:26<00:30, 306.53it/s]     50%|#####     | 8193/16384 [00:29<00:26, 309.13it/s]     56%|#####6    | 9217/16384 [00:32<00:23, 311.06it/s]     63%|######2   | 10241/16384 [00:35<00:19, 312.02it/s]     69%|######8   | 11265/16384 [00:39<00:16, 312.57it/s]     75%|#######5  | 12289/16384 [00:42<00:13, 312.94it/s]     81%|########1 | 13313/16384 [00:45<00:09, 313.31it/s]     88%|########7 | 14337/16384 [00:48<00:06, 313.81it/s]     94%|#########3| 15361/16384 [00:52<00:03, 314.14it/s]    100%|##########| 16384/16384 [00:52<00:00, 314.48it/s]
      0%|          | 0/16384 [00:00<?, ?it/s]      0%|          | 1/16384 [00:03<14:45:42,  3.24s/it]      6%|6         | 1025/16384 [00:06<01:22, 185.71it/s]     13%|#2        | 2049/16384 [00:09<00:58, 244.86it/s]     19%|#8        | 3073/16384 [00:12<00:48, 272.80it/s]     25%|##5       | 4097/16384 [00:16<00:42, 288.56it/s]     31%|###1      | 5121/16384 [00:19<00:37, 297.73it/s]     38%|###7      | 6145/16384 [00:22<00:33, 303.49it/s]     44%|####3     | 7169/16384 [00:25<00:29, 307.99it/s]     50%|#####     | 8193/16384 [00:29<00:26, 310.89it/s]     56%|#####6    | 9217/16384 [00:32<00:23, 301.66it/s]     63%|######2   | 10241/16384 [00:36<00:20, 292.59it/s]     69%|######8   | 11265/16384 [00:39<00:17, 299.35it/s]     75%|#######5  | 12289/16384 [00:43<00:13, 303.04it/s]     81%|########1 | 13313/16384 [00:46<00:10, 305.41it/s]     88%|########7 | 14337/16384 [00:49<00:06, 307.65it/s]     94%|#########3| 15361/16384 [00:52<00:03, 309.62it/s]    100%|##########| 16384/16384 [00:52<00:00, 309.94it/s]
      0%|          | 0/16384 [00:00<?, ?it/s]      0%|          | 1/16384 [00:03<14:27:46,  3.18s/it]      6%|6         | 1025/16384 [00:06<01:20, 190.37it/s]     13%|#2        | 2049/16384 [00:09<00:57, 251.42it/s]     19%|#8        | 3073/16384 [00:12<00:47, 279.38it/s]     25%|##5       | 4097/16384 [00:15<00:41, 295.01it/s]     31%|###1      | 5121/16384 [00:19<00:37, 302.90it/s]     38%|###7      | 6145/16384 [00:22<00:32, 310.48it/s]     44%|####3     | 7169/16384 [00:25<00:29, 314.46it/s]     50%|#####     | 8193/16384 [00:28<00:25, 318.33it/s]     56%|#####6    | 9217/16384 [00:31<00:22, 320.43it/s]     63%|######2   | 10241/16384 [00:34<00:19, 322.97it/s]     69%|######8   | 11265/16384 [00:37<00:15, 325.19it/s]     75%|#######5  | 12289/16384 [00:40<00:12, 326.69it/s]     81%|########1 | 13313/16384 [00:44<00:09, 328.32it/s]     88%|########7 | 14337/16384 [00:47<00:06, 329.29it/s]     94%|#########3| 15361/16384 [00:50<00:03, 328.34it/s]    100%|##########| 16384/16384 [00:50<00:00, 325.82it/s]
      0%|          | 0/16384 [00:00<?, ?it/s]      0%|          | 1/16384 [00:06<29:56:32,  6.58s/it]      6%|6         | 1025/16384 [00:09<01:58, 129.93it/s]     13%|#2        | 2049/16384 [00:13<01:12, 197.70it/s]     19%|#8        | 3073/16384 [00:16<00:56, 236.52it/s]     25%|##5       | 4097/16384 [00:19<00:46, 261.48it/s]     31%|###1      | 5121/16384 [00:23<00:40, 278.18it/s]     38%|###7      | 6145/16384 [00:26<00:35, 288.78it/s]     44%|####3     | 7169/16384 [00:29<00:31, 295.90it/s]     50%|#####     | 8193/16384 [00:32<00:27, 300.18it/s]     56%|#####6    | 9217/16384 [00:36<00:23, 298.88it/s]     63%|######2   | 10241/16384 [00:39<00:20, 298.91it/s]     69%|######8   | 11265/16384 [00:43<00:16, 303.49it/s]     75%|#######5  | 12289/16384 [00:46<00:13, 306.14it/s]     81%|########1 | 13313/16384 [00:49<00:09, 307.58it/s]     88%|########7 | 14337/16384 [00:52<00:06, 307.35it/s]     94%|#########3| 15361/16384 [00:56<00:03, 305.84it/s]    100%|##########| 16384/16384 [00:56<00:00, 290.90it/s]




.. GENERATED FROM PYTHON SOURCE LINES 155-158

Circuit Level Thermal Noise Sizing
----------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 158-204

.. code-block:: default

    analog_frontend = cbadc.synthesis.get_leap_frog(N=N, ENOB=ENOB, BW=BW)
    analog_system = analog_frontend.analog_system
    digital_control = analog_frontend.digital_control

    A_DC = 1e4
    omega_p = 2 * np.pi * BW

    digital_estimator = cbadc.digital_estimator.BatchEstimator(
        analog_system, digital_control, eta2, K1, K2
    )

    verilog_digital_control = cbadc.circuit_level.DigitalControl(
        copy.deepcopy(digital_control)
    )

    first_order_pole_op_amp_analog_system = (
        cbadc.circuit_level.AnalogSystemFirstOrderPoleOpAmp(
            BW=(BW * 1e-5, BW),
            target_snr=snr,
            digital_estimator=digital_estimator,
            A_DC=A_DC,
            omega_p=omega_p,
        )
    )

    first_order_pole_op_amp_analog_frontend = cbadc.circuit_level.AnalogFrontend(
        first_order_pole_op_amp_analog_system, verilog_digital_control
    )

    t_stop = digital_control.clock.T * (size + K1 + K2)
    simulation_clock = cbadc.analog_signal.Clock(digital_control.clock.T)

    first_order_pole_op_amp_testbench = cbadc.circuit_level.TestBench(
        first_order_pole_op_amp_analog_frontend,
        input_signals[0],
        simulation_clock,
        t_stop,
    )

    print(f"Capacitor values = {first_order_pole_op_amp_analog_system.C_diag}")
    print(f"\n\nResistor network A: {first_order_pole_op_amp_analog_system._A_G_matrix}")
    print(f"\n\nResistor network B: {first_order_pole_op_amp_analog_system._B_G_matrix}")
    print(
        f"\n\nResistor network Gamma: {first_order_pole_op_amp_analog_system._Gamma_G_matrix}"
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Capacitor values = [[2.9e-11 0.0e+00 0.0e+00 0.0e+00 0.0e+00]
     [0.0e+00 8.0e-14 0.0e+00 0.0e+00 0.0e+00]
     [0.0e+00 0.0e+00 2.4e-14 0.0e+00 0.0e+00]
     [0.0e+00 0.0e+00 0.0e+00 2.4e-16 0.0e+00]
     [0.0e+00 0.0e+00 0.0e+00 0.0e+00 2.1e-17]]
    /Users/hammal/miniforge3/lib/python3.9/site-packages/cbadc/circuit_level/op_amp/resistor_network.py:61: RuntimeWarning: divide by zero encountered in true_divide
      f"[out_{i}] \u2248 [{', '.join([f'{np.divide(1, a):.2e}' for a in self.G[i, :]])}] [in_{i}]"


    Resistor network A: resistor_network_a

    Ports: in_0, in_1, in_2, in_3, in_4, out_0, out_1, out_2, out_3, out_4

    Parameters: 

    Functional Description:

    Resistor network connecting inputs and outputs according to the following matrix

    [out_0] ≈ [-inf, -6.54e+03, -inf, -inf, -inf] [in_0]
    [out_1] ≈ [6.78e+04, -inf, -2.33e+06, -inf, -inf] [in_1]
    [out_2] ≈ [-inf, 2.25e+05, -inf, -7.76e+06, -inf] [in_2]
    [out_3] ≈ [-inf, -inf, 2.23e+07, -inf, -7.69e+08] [in_3]
    [out_4] ≈ [-inf, -inf, -inf, 2.63e+08, -inf] [in_4]

    note the resistors are specified by their resistive values in Ohms


    Resistor network B: resistor_network_b

    Ports: in_0, out_0, out_1, out_2, out_3, out_4

    Parameters: 

    Functional Description:

    Resistor network connecting inputs and outputs according to the following matrix

    [out_0] ≈ [1.90e+02] [in_0]
    [out_1] ≈ [-inf] [in_1]
    [out_2] ≈ [-inf] [in_2]
    [out_3] ≈ [-inf] [in_3]
    [out_4] ≈ [-inf] [in_4]

    note the resistors are specified by their resistive values in Ohms


    Resistor network Gamma: resistor_network_gamma

    Ports: in_0, in_1, in_2, in_3, in_4, out_0, out_1, out_2, out_3, out_4

    Parameters: 

    Functional Description:

    Resistor network connecting inputs and outputs according to the following matrix

    [out_0] ≈ [1.90e+02, -inf, -inf, -inf, -inf] [in_0]
    [out_1] ≈ [-inf, 6.78e+04, -inf, -inf, -inf] [in_1]
    [out_2] ≈ [-inf, -inf, 2.25e+05, -inf, -inf] [in_2]
    [out_3] ≈ [-inf, -inf, -inf, 2.23e+07, -inf] [in_3]
    [out_4] ≈ [-inf, -inf, -inf, -inf, 2.63e+08] [in_4]

    note the resistors are specified by their resistive values in Ohms




.. GENERATED FROM PYTHON SOURCE LINES 205-207

Plotting the Power Spectral Densities
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. GENERATED FROM PYTHON SOURCE LINES 207-251

.. code-block:: default


    plt.figure()
    digital_estimator = first_order_pole_op_amp_analog_frontend.get_estimator(
        cbadc.digital_estimator.FIRFilter, eta2, K1, K2
    )
    white_noise_sensitivies = digital_estimator.white_noise_sensitivities(
        (BW * 1e-5, BW), snr, input_power=input_signal_power, spectrum=True
    )
    noise_covariance_matrix = np.diag(white_noise_sensitivies[0, :] * BW)
    simulator = first_order_pole_op_amp_testbench.get_simulator(
        cbadc.simulator.SimulatorType.full_numerical, cov_x=noise_covariance_matrix
    )
    digital_estimator(simulator)
    for index in range(size):
        u_hat[index] = next(digital_estimator)
    u_hat_cut = u_hat[K1 + K2 :]
    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_cut[:], fs=1 / digital_control.clock.T, nperseg=u_hat_cut.size
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"est_ENOB={est_ENOB:.1f} bits, est_SNR={est_SNR:.1f} dB",
    )


    plt.title("Power spectral density of input estimate")
    plt.xlabel('Hz')
    plt.ylabel('$V^2$ / Hz dB')
    plt.legend()
    plt.grid(which="both")
    # plt.xlim((f[0], f[-1]))
    plt.gcf().tight_layout()




.. image-sg:: /tutorials/c_circuit_level/images/sphx_glr_plot_d_noise_002.png
   :alt: Power spectral density of input estimate
   :srcset: /tutorials/c_circuit_level/images/sphx_glr_plot_d_noise_002.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 19 minutes  52.793 seconds)


.. _sphx_glr_download_tutorials_c_circuit_level_plot_d_noise.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_d_noise.py <plot_d_noise.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_d_noise.ipynb <plot_d_noise.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
