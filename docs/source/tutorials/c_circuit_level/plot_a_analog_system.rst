
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/c_circuit_level/plot_a_analog_system.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_c_circuit_level_plot_a_analog_system.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_c_circuit_level_plot_a_analog_system.py:


======================
Analog System
======================

We demonstrate how an analog system can be transformed into a boilerplate
verilog-ams circuit model.

.. GENERATED FROM PYTHON SOURCE LINES 9-14

.. code-block:: default


    import cbadc
    import numpy as np
    import matplotlib.pyplot as plt








.. GENERATED FROM PYTHON SOURCE LINES 15-22

Setting up an Analog System
-----------------------------

We start by instantiating an analag system. In this case we use
high level utilities functions from the :py:mod:`cbadc.specification`
module.


.. GENERATED FROM PYTHON SOURCE LINES 22-54

.. code-block:: default


    # Fix system parameters such as effective number of bits
    ENOB = 16
    # System order
    N = 4
    # Bandwidth
    BW = 1e6

    # Instantiate leap-frog analog system is created as
    analog_system, _ = cbadc.specification.get_leap_frog(ENOB=ENOB, N=N, BW=BW)

    # Visualize the analog system's transfer functions
    BW_log = np.log10(BW)
    frequencies = np.logspace(BW_log - 2, BW_log + 1, 500)
    omegas = 2 * np.pi * frequencies
    transfer_function = analog_system.transfer_function_matrix(omegas)
    plt.semilogx(
        frequencies,
        20 * np.log10(np.linalg.norm(transfer_function[:, 0, :], axis=0)),
        label="leap-frog $ ||\mathbf{G}(\omega)||_2 $",
    )

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which="both")
    plt.title("Analog system transfer function")
    plt.xlabel("$f$ [Hz]")
    plt.ylabel("dB")
    plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()
    plt.show()




.. image-sg:: /tutorials/c_circuit_level/images/sphx_glr_plot_a_analog_system_001.png
   :alt: Analog system transfer function
   :srcset: /tutorials/c_circuit_level/images/sphx_glr_plot_a_analog_system_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 55-66

Instantiating a Circuit Level Model
-----------------------------------

Using the :py:mod:`cbadc.circuit_level` module we can now start turning our
nominal analog system into a circuit level system model.

We will start with the highest layer of abstraction. Namely, the state space
equations modeled directly using the verilog-ams language. This can
be done using the class :py:class:`cbadc.circuit_level.AnalogSystemStateSpaceEquations`
as


.. GENERATED FROM PYTHON SOURCE LINES 66-78

.. code-block:: default



    verilog_analog_system = cbadc.circuit_level.AnalogSystemStateSpaceEquations(
        analog_system
    )

    # The verilog module description can be accessed by
    print("\n\n\n".join(verilog_analog_system.render()[0]))

    # Alternatively, we can create a corresponding verilog-ams file as
    verilog_analog_system.to_file(filename="verilog_analog_system.vams")



.. rst-class:: sphx-glr-script-out

.. code-block:: pytb

    Traceback (most recent call last):
      File "/Users/hammal/Projects/cbadc/docs/code_examples/c_circuit_level/plot_a_analog_system.py", line 68, in <module>
        verilog_analog_system = cbadc.circuit_level.AnalogSystemStateSpaceEquations(
      File "/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/cbadc/circuit_level/state_space_equations.py", line 216, in __init__
        super().__init__(
      File "/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/cbadc/circuit_level/module.py", line 324, in __init__
        super().__init__(
      File "/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/cbadc/circuit_level/module.py", line 119, in __init__
        loader=PackageLoader("cbadc", package_path="circuit_level/templates"),
      File "/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/jinja2/loaders.py", line 319, in __init__
        raise ValueError(
    ValueError: The 'cbadc' package was not installed in a way that PackageLoader understands.




.. GENERATED FROM PYTHON SOURCE LINES 79-81

:download:`verilog_analog_system.vams <verilog_analog_system.vams>`


.. GENERATED FROM PYTHON SOURCE LINES 84-90

Ideal Op-amp Implementation
----------------------------

Next we realize the same analog system using an ideal op-amp configuration
with capacitive feedback.


.. GENERATED FROM PYTHON SOURCE LINES 90-102

.. code-block:: default


    C = 1e-12
    ideal_op_amp_analog_system = cbadc.circuit_level.AnalogSystemIdealOpAmp(
        analog_system, C
    )

    # The verilog module description can be accessed by
    print("\n\n\n".join(ideal_op_amp_analog_system.render()[0]))

    # Alternatively, we can create a corresponding verilog-ams file as
    ideal_op_amp_analog_system.to_file(filename="ideal_op_amp_analog_system.vams")


.. GENERATED FROM PYTHON SOURCE LINES 103-105

:download:`ideal_op_amp_analog_system.vams <ideal_op_amp_analog_system.vams>`


.. GENERATED FROM PYTHON SOURCE LINES 107-109

Similarly, we can instantiate op-amp realizations that account for
imperfections such as finite gain and first order pole.

.. GENERATED FROM PYTHON SOURCE LINES 110-123

.. code-block:: default


    C = 1e-12
    A_DC = 1e2
    omega_p = 2 * np.pi * BW / 8

    finite_gain_op_amp_analog_system = cbadc.circuit_level.AnalogSystemFiniteGainOpAmp(
        analog_system, C, A_DC
    )

    first_order_pole_op_amp_analog_system = (
        cbadc.circuit_level.AnalogSystemFirstOrderPoleOpAmp(analog_system, C, A_DC, omega_p)
    )


.. GENERATED FROM PYTHON SOURCE LINES 124-131

again the corresponding verilog files can be found below

:download:`finite_gain_op_amp_analog_system.vams <finite_gain_op_amp_analog_system.vams>`,
:download:`first_order_pole_op_amp_analog_system.vams <first_order_pole_op_amp_analog_system.vams>`

and are generated using the :py:func:`cbadc.circuit_level.AnalogSystemFirstOrderPoleOpAmp.to_file`.


.. GENERATED FROM PYTHON SOURCE LINES 132-141

.. code-block:: default


    finite_gain_op_amp_analog_system.to_file(
        filename="finite_gain_op_amp_analog_system.vams"
    )

    first_order_pole_op_amp_analog_system.to_file(
        filename="first_order_pole_op_amp_analog_system.vams"
    )


.. GENERATED FROM PYTHON SOURCE LINES 142-159

Reference Simulation
---------------------

The primary intention of the :py:mod:`cbadc.circuit_level` module is to
provide golden models, correctly parameterized and instantiated in the
circuit level simulation domain. However, it might for some purposes be
interesting to see the effects of circuit imperfections directly within
the cbadc design tool itself.

For this purpose each circuit level analog system, like the ones we
have seen above, have an associated :py:class:`cbadc.analog_system.AnalogSystem`
that also any discrepancies from the target analog system with which it
was instantiated.

Tom demonstarte this second use case we will next compare the transfer
functions of the analog systems we covered previously.


.. GENERATED FROM PYTHON SOURCE LINES 159-188

.. code-block:: default


    # We don't consider the ideal_op_amp_analog_system and verilog_analog_system
    # instances as these will result in identical analog systems as our target
    # system.

    compare_systems = {
        'target': analog_system,
        f'finite_gain, A_DC={A_DC:.0e}': finite_gain_op_amp_analog_system.analog_system,
        f'single_pole, A_DC={A_DC:.0e}, f_p={omega_p/(2 * np.pi):.0e} Hz': first_order_pole_op_amp_analog_system.analog_system,
    }

    for key, system in compare_systems.items():
        print(system)
        transfer_function = system.transfer_function_matrix(omegas)
        plt.semilogx(
            frequencies,
            20 * np.log10(np.linalg.norm(transfer_function[:, 0, :], axis=0)),
            label=f"{key}, " + "$ ||\mathbf{G}(\omega)||_2 $",
        )

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which="both")
    plt.title("Analog system transfer function")
    plt.xlabel("$f$ [Hz]")
    plt.ylabel("dB")
    plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.246 seconds)


.. _sphx_glr_download_tutorials_c_circuit_level_plot_a_analog_system.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_a_analog_system.py <plot_a_analog_system.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_a_analog_system.ipynb <plot_a_analog_system.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
