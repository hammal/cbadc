
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/c_circuit_level/plot_b_analog_frontend.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_c_circuit_level_plot_b_analog_frontend.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_c_circuit_level_plot_b_analog_frontend.py:


======================
Analog Frontend
======================

In this tutorial we will combine analog systems and digital controls
to which we refer to as an analog frontend. The analog frontend, in
contrast to the digital estimator, contains mixed signals (analog and digital)
and is therefore fundamentally different to model compared to the
digital estimator itself.

To create a analog fronted we require an analog system
to that end we use a similair specification as in
:doc:`./plot_a_analog_system`.

.. GENERATED FROM PYTHON SOURCE LINES 16-21

.. code-block:: default


    import cbadc
    import numpy as np
    import matplotlib.pyplot as plt








.. GENERATED FROM PYTHON SOURCE LINES 22-24

Analog System
---------------

.. GENERATED FROM PYTHON SOURCE LINES 24-59

.. code-block:: default


    # Fix system parameters such as effective number of bits
    ENOB = 16
    # System order
    N = 4
    # Bandwidth
    BW = 1e6

    # Instantiate leap-frog analog system is created as
    analog_frontend_target = cbadc.synthesis.get_leap_frog(ENOB=ENOB, N=N, BW=BW)
    target_analog_system = analog_frontend_target.analog_system
    target_digital_control = analog_frontend_target.digital_control

    verilog_analog_system = cbadc.circuit_level.AnalogSystemStateSpaceEquations(
        target_analog_system
    )

    C = 1e-12
    ideal_op_amp_analog_system = cbadc.circuit_level.AnalogSystemIdealOpAmp(
        analog_system=target_analog_system, C=C
    )

    A_DC = 1e2
    omega_p = 2 * np.pi * BW

    finite_gain_op_amp_analog_system = cbadc.circuit_level.AnalogSystemFiniteGainOpAmp(
        analog_system=target_analog_system, C=C, A_DC=A_DC
    )

    first_order_pole_op_amp_analog_system = (
        cbadc.circuit_level.AnalogSystemFirstOrderPoleOpAmp(
            analog_system=target_analog_system, C=C, A_DC=A_DC, omega_p=omega_p
        )
    )








.. GENERATED FROM PYTHON SOURCE LINES 60-66

Digital Control
-----------------------------

To create a verilog-ams digital control model
we use :py:class:`cbadc.circuit_level.digital_control.DigitalControl` class
as

.. GENERATED FROM PYTHON SOURCE LINES 66-69

.. code-block:: default


    verilog_digital_control = cbadc.circuit_level.DigitalControl(target_digital_control)








.. GENERATED FROM PYTHON SOURCE LINES 70-75

Analog Frontend
------------------

Subsequently, the analog frontend can be pertained by the cbadc.circuit_level.AnalogFrontend
class as

.. GENERATED FROM PYTHON SOURCE LINES 75-92

.. code-block:: default


    verilog_analog_frontend = cbadc.circuit_level.AnalogFrontend(
        verilog_analog_system, verilog_digital_control
    )

    ideal_op_amp_analog_frontend = cbadc.circuit_level.AnalogFrontend(
        ideal_op_amp_analog_system, verilog_digital_control
    )

    finite_gain_op_amp_analog_frontend = cbadc.circuit_level.AnalogFrontend(
        finite_gain_op_amp_analog_system, verilog_digital_control
    )

    first_order_pole_op_amp_analog_frontend = cbadc.circuit_level.AnalogFrontend(
        first_order_pole_op_amp_analog_system, verilog_digital_control
    )








.. GENERATED FROM PYTHON SOURCE LINES 93-98

Verilog Modules
------------------

These analog frontends can now be converted directly into verilog-ams
modules as

.. GENERATED FROM PYTHON SOURCE LINES 98-111

.. code-block:: default


    verilog_analog_frontend.to_file(filename="verilog_analog_frontend.vams")

    ideal_op_amp_analog_frontend.to_file(filename="ideal_op_amp_analog_frontend.vams")

    finite_gain_op_amp_analog_frontend.to_file(
        filename="finite_gain_op_amp_analog_frontend.vams"
    )

    first_order_pole_op_amp_analog_frontend.to_file(
        filename="first_order_pole_op_amp_analog_frontend.vams"
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /Users/hammal/miniforge3/lib/python3.9/site-packages/cbadc/circuit_level/op_amp/resistor_network.py:61: RuntimeWarning: divide by zero encountered in double_scalars
      f"[out_{i}] \u2248 [{', '.join([f'{1/a:.2e}' for a in self.G[i, :]])}] [in_{i}]"




.. GENERATED FROM PYTHON SOURCE LINES 112-117

where each generated file can be downloaded below
:download:`verilog_analog_frontend.vams <./verilog_analog_frontend.vams>`
:download:`ideal_op_amp_analog_frontend.vams <./ideal_op_amp_analog_frontend.vams>`
:download:`finite_gain_op_amp_analog_frontend.vams <./finite_gain_op_amp_analog_frontend.vams>`
:download:`first_order_pole_op_amp_analog_frontend.vams <./first_order_pole_op_amp_analog_frontend.vams>`

.. GENERATED FROM PYTHON SOURCE LINES 120-130

Transfer Functions
------------------

As we did for the analog systems we plot the digital estimators corresponding
noise and signal transfer functions

To get the resulting digital estimator from an analog frontend we use the
function :py:func:`cbadc.circuit_level.analog_frontend.AnalogFrontend.get_estimator`
Which requires us to pass an digital estimator class together with an eta2, K1, and
K2 value.

.. GENERATED FROM PYTHON SOURCE LINES 130-187

.. code-block:: default


    eta2 = (
        np.linalg.norm(
            target_analog_system.transfer_function_matrix(np.array([2 * np.pi * BW]))
        )
        ** 2
    )
    K1 = 1 << 8
    K2 = K1

    digital_estimator_parameters = [cbadc.digital_estimator.FIRFilter, eta2, K1, K2]

    compare_systems = {
        'verilog_ideal': verilog_analog_frontend.get_estimator(
            *digital_estimator_parameters
        ),
        'finite_gain op-amp': finite_gain_op_amp_analog_frontend.get_estimator(
            *digital_estimator_parameters
        ),
        'single_pole op-amp': first_order_pole_op_amp_analog_frontend.get_estimator(
            *digital_estimator_parameters
        ),
    }
    BW_log = np.log10(BW)
    frequencies = np.logspace(BW_log - 2, BW_log + 1, 500)
    omegas = 2 * np.pi * frequencies

    for key, digital_estimator in compare_systems.items():

        # Compute STF
        stf = digital_estimator.signal_transfer_function(omegas)
        stf_dB = 20 * np.log10(np.abs(stf.flatten()))

        plt.semilogx(frequencies, stf_dB, label="$|STF(\omega)|$ " + key)

    for key, digital_estimator in compare_systems.items():
        # Compute NTF
        ntf = digital_estimator.noise_transfer_function(omegas)
        ntf_dB = 20 * np.log10(np.abs(ntf))

        plt.semilogx(
            frequencies,
            20 * np.log10(np.linalg.norm(ntf[0, :, :], axis=0)),
            "--",
            label="$ || NTF(\omega) ||_2 $, " + key,
        )

    # Add labels and legends to figure

    plt.legend()
    plt.grid(which="both")
    plt.title("Signal and noise transfer functions")
    plt.xlabel("frequencies [Hz]")
    plt.ylabel("dB")
    plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()




.. image-sg:: /tutorials/c_circuit_level/images/sphx_glr_plot_b_analog_frontend_001.png
   :alt: Signal and noise transfer functions
   :srcset: /tutorials/c_circuit_level/images/sphx_glr_plot_b_analog_frontend_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 188-192

Impulse Responses
------------------

We also compare the resulting filters impulse responses

.. GENERATED FROM PYTHON SOURCE LINES 192-218

.. code-block:: default


    for key, digital_estimator in compare_systems.items():
        plt.plot(
            np.arange(-K1, K2),
            np.array(digital_estimator.h[0, :, 0])[:],
            label=key,
        )
    plt.legend()
    plt.xlabel("filter tap k")
    plt.ylabel("$ h_1 [k] $")
    plt.xlim((-K1, K2))
    plt.grid(which="both")

    plt.figure()
    for key, digital_estimator in compare_systems.items():
        plt.semilogy(
            np.arange(-K1, K2),
            np.abs(np.array(digital_estimator.h[0, :, 0]))[:],
            label=key,
        )
    plt.legend()
    plt.xlabel("filter tap k")
    plt.ylabel("$| h_1 [k] \|$")
    plt.xlim((-K1, K2))
    plt.grid(which="both")




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /tutorials/c_circuit_level/images/sphx_glr_plot_b_analog_frontend_002.png
         :alt: plot b analog frontend
         :srcset: /tutorials/c_circuit_level/images/sphx_glr_plot_b_analog_frontend_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/c_circuit_level/images/sphx_glr_plot_b_analog_frontend_003.png
         :alt: plot b analog frontend
         :srcset: /tutorials/c_circuit_level/images/sphx_glr_plot_b_analog_frontend_003.png
         :class: sphx-glr-multi-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  28.805 seconds)


.. _sphx_glr_download_tutorials_c_circuit_level_plot_b_analog_frontend.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_b_analog_frontend.py <plot_b_analog_frontend.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_b_analog_frontend.ipynb <plot_b_analog_frontend.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
