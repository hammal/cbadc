
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/b_high_level_simulation/plot_i_simulating_a_delta_sigma_modulator.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_b_high_level_simulation_plot_i_simulating_a_delta_sigma_modulator.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_b_high_level_simulation_plot_i_simulating_a_delta_sigma_modulator.py:


Simulating a Continuous-Time Delta-Sigma Modulator
==================================================

.. GENERATED FROM PYTHON SOURCE LINES 5-17

.. code-block:: default

    import cbadc
    import numpy as np
    import matplotlib.pyplot as plt
    import json

    T = 0.1e-8
    N = 5
    K1 = 1 << 9
    K2 = K1
    OSR = 16
    BW = 1 / (2 * T * OSR)








.. GENERATED FROM PYTHON SOURCE LINES 18-24

Instantiating the Analog System and Digital Control
---------------------------------------------------

We start by loading a delta sigma modulator constructed
using [www.sigma-delta.de](www.sigma-delta.de) framework.


.. GENERATED FROM PYTHON SOURCE LINES 24-47

.. code-block:: default


    with open('CTSD_N5_OSR16_Q32_CRFF_OPT1_HINF600.json') as f:
        analog_frontend_ctsd = cbadc.synthesis.ctsd_dict2af(json.load(f), T)

    eta2_ctsd = (
        np.linalg.norm(
            analog_frontend_ctsd.analog_system.transfer_function_matrix(
                np.array([2 * np.pi * BW])
            )
        )
        ** 2
    )

    digital_estimator_ctsd = cbadc.digital_estimator.BatchEstimator(
        analog_frontend_ctsd.analog_system,
        analog_frontend_ctsd.digital_control,
        eta2_ctsd,
        K1,
        K2,
    )

    print(analog_frontend_ctsd.analog_system)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    initial digital control [0.5] [0.]
    The analog system is parameterized as:
    A =
    [[ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 1.95e+09  0.00e+00 -1.03e+07  0.00e+00  0.00e+00]
     [ 0.00e+00  1.09e+09  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  9.63e+08  0.00e+00 -5.34e+07]
     [ 0.00e+00  0.00e+00  0.00e+00  5.93e+08  0.00e+00]],
    B =
    [[ 1.69e+08]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]],
    CT = 
    [[ 1.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  1.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  1.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  1.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  1.00e+00]],
    Gamma =
    [[-1.69e+08]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]],
    Gamma_tildeT =
    [[ 1.07e+01  6.74e+00  5.08e+00  2.69e+00  9.61e-01]], and D=[[ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]]




.. GENERATED FROM PYTHON SOURCE LINES 48-51

Leap Frog
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 51-93

.. code-block:: default


    analog_frontend_leap_frog = cbadc.synthesis.get_leap_frog(
        OSR=OSR, N=N, BW=BW, opt=False
    )

    analog_frontend_leap_frog.digital_control = (
        cbadc.digital_control.MultiLevelDigitalControl(
            analog_frontend_leap_frog.digital_control.clock, N, [1] * N
        )
    )

    # Scale B
    # analog_frontend_leap_frog.analog_system.B = (
    #     2 * analog_frontend_leap_frog.analog_system.B
    # )


    # Scale Gamma
    # analog_frontend_leap_frog.analog_system.Gamma = np.dot(
    #     np.diag(np.array([0.5 ** (x + 1) for x in range(N)])),
    #     analog_frontend_leap_frog.analog_system.Gamma,
    # )

    eta2_leap_frog = (
        np.linalg.norm(
            analog_frontend_leap_frog.analog_system.transfer_function_matrix(
                np.array([2 * np.pi * BW])
            )
        )
        ** 2
    )

    digital_estimator_leap_frog = cbadc.digital_estimator.BatchEstimator(
        analog_frontend_leap_frog.analog_system,
        analog_frontend_leap_frog.digital_control,
        eta2_leap_frog,
        K1,
        K2,
    )

    print(analog_frontend_leap_frog.analog_system)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    initial digital control [ 1.00e+00  1.00e+00  1.00e+00  1.00e+00  1.00e+00] [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
    The analog system is parameterized as:
    A =
    [[ 0.00e+00 -1.93e+07  0.00e+00  0.00e+00  0.00e+00]
     [ 5.00e+08  0.00e+00 -1.93e+07  0.00e+00  0.00e+00]
     [ 0.00e+00  5.00e+08  0.00e+00 -1.93e+07  0.00e+00]
     [ 0.00e+00  0.00e+00  5.00e+08  0.00e+00 -1.93e+07]
     [ 0.00e+00  0.00e+00  0.00e+00  5.00e+08  0.00e+00]],
    B =
    [[ 5.00e+08]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]],
    CT = 
    [[ 1.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  1.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  1.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  1.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  1.00e+00]],
    Gamma =
    [[ 5.00e+08  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  5.00e+08  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  5.00e+08  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  5.00e+08  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  5.00e+08]],
    Gamma_tildeT =
    [[-1.00e+00 -0.00e+00 -0.00e+00 -0.00e+00 -0.00e+00]
     [-0.00e+00 -1.00e+00 -0.00e+00 -0.00e+00 -0.00e+00]
     [-0.00e+00 -0.00e+00 -1.00e+00 -0.00e+00 -0.00e+00]
     [-0.00e+00 -0.00e+00 -0.00e+00 -1.00e+00 -0.00e+00]
     [-0.00e+00 -0.00e+00 -0.00e+00 -0.00e+00 -1.00e+00]], and D=[[ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]]




.. GENERATED FROM PYTHON SOURCE LINES 94-97

Input Signal
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 97-107

.. code-block:: default

    amplitude = 0.25e-0
    phase = 0.0
    offset = 0.0
    frequency = 1.0 / analog_frontend_ctsd.digital_control.clock.T

    while frequency > BW:
        frequency /= 2
    input_signal = cbadc.analog_signal.Sinusoidal(amplitude, frequency, phase, offset)
    # input_signal = cbadc.analog_signal.ConstantSignal(amplitude)








.. GENERATED FROM PYTHON SOURCE LINES 108-111

Transfer Functions
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 111-176

.. code-block:: default


    # Logspace frequencies
    frequencies = np.logspace(3, 8, 1000)
    omega = 2 * np.pi * frequencies

    # Compute transfer functions for each frequency in frequencies
    transfer_function_ctsd = analog_frontend_ctsd.analog_system.transfer_function_matrix(
        omega
    )
    transfer_function_ctsd_dB = 20 * np.log10(np.abs(transfer_function_ctsd))

    transfer_function_leap_frog = (
        analog_frontend_leap_frog.analog_system.transfer_function_matrix(omega)
    )
    transfer_function_leap_frog_dB = 20 * np.log10(np.abs(transfer_function_leap_frog))

    G_omega = 20 * np.log10(np.linalg.norm(transfer_function_ctsd[:, 0, :], axis=0))

    plt.semilogx([BW, BW], [np.min(G_omega), np.max(G_omega)], '--', label="BW")

    # Add the norm ||G(omega)||_2
    plt.semilogx(
        frequencies,
        20 * np.log10(np.linalg.norm(transfer_function_leap_frog[:, 0, :], axis=0)),
        label="LF $ ||\mathbf{G}(\omega)||_2 $",
    )
    plt.semilogx(
        frequencies,
        G_omega,
        label="CTSD $ ||\mathbf{G}(\omega)||_2 $",
    )


    # Add labels and legends to figure
    plt.legend()
    plt.grid(which="both")
    plt.xlabel("$f$ [Hz]")
    plt.ylabel("dB")
    plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()


    for n in range(N):
        plt.figure()
        #     color = next(plt.gca()._get_lines.prop_cycler)["color"]
        plt.semilogx(
            frequencies,
            transfer_function_leap_frog_dB[n, 0, :],
            label="LF $G_" + f"{n+1}" + "(f)$",
            # color = color
        )
        plt.semilogx(
            frequencies,
            transfer_function_ctsd_dB[n, 0, :],
            '--',
            label="CTSD $G_" + f"{n+1}" + "(f)$",
            #     # color = color
        )
        plt.legend()
        plt.grid(which="both")
        plt.xlabel("$f$ [Hz]")
        plt.ylabel("dB")
        plt.xlim((frequencies[0], frequencies[-1]))
        plt.gcf().tight_layout()




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_001.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_002.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_003.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_004.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_005.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_005.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_006.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_006.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 177-180

Simulation Setup
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 180-196

.. code-block:: default


    simulator_ctsd = cbadc.simulator.get_simulator(
        analog_frontend_ctsd.analog_system,
        analog_frontend_ctsd.digital_control,
        [input_signal],
    )
    digital_estimator_ctsd(simulator_ctsd)

    simulator_leap_frog = cbadc.simulator.get_simulator(
        analog_frontend_leap_frog.analog_system,
        analog_frontend_leap_frog.digital_control,
        [input_signal],
    )
    digital_estimator_leap_frog(simulator_leap_frog)









.. GENERATED FROM PYTHON SOURCE LINES 197-200

Simulate State Trajectories
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 200-261

.. code-block:: default


    # Simulate for 65536 control cycles.
    size = 1 << 14

    time_vector = np.arange(size)
    states = np.zeros((N, size, 2))
    control_signals = np.zeros((N, size, 2), dtype=np.double)

    # Iterate through and store states and control_signals.
    simulator_ctsd = cbadc.simulator.extended_simulation_result(simulator_ctsd)
    simulator_leap_frog = cbadc.simulator.extended_simulation_result(simulator_leap_frog)
    for index in cbadc.utilities.show_status(range(size)):
        res_ctsd = next(simulator_ctsd)
        states[:, index, 0] = res_ctsd["analog_state"]
        control_signals[:, index, 0] = res_ctsd["control_signal"]
        res_leap_frog = next(simulator_leap_frog)
        states[:, index, 1] = res_leap_frog["analog_state"]
        control_signals[:, index, 1] = res_leap_frog["control_signal"]

    xlim = 1 << 12
    # Plot all analog state evolutions.
    plt.figure()
    plt.title("Analog state vectors")
    for index in range(N):
        plt.plot(time_vector, states[index, :, 1], label=f"LF $x_{index + 1}(t)$")
        plt.plot(time_vector, states[index, :, 0], label=f"CTSD $x_{index + 1}(t)$")
    plt.grid(visible=True, which="major", color="gray", alpha=0.6, lw=1.5)
    plt.xlabel("$t/T$")
    plt.xlim((0, xlim))
    plt.legend()


    # reset figure size and plot individual results.
    plt.rcParams["figure.figsize"] = [6.40, 6.40 * 2]
    fig, ax = plt.subplots(N, 2)
    for index in range(N):
        color = next(ax[0, 0]._get_lines.prop_cycler)["color"]
        color2 = next(ax[0, 0]._get_lines.prop_cycler)["color"]
        ax[index, 0].grid(visible=True, which="major", color="gray", alpha=0.6, lw=1.5)
        ax[index, 1].grid(visible=True, which="major", color="gray", alpha=0.6, lw=1.5)
        ax[index, 0].plot(time_vector, states[index, :, 1], color=color2, label="LF")
        ax[index, 0].plot(time_vector, states[index, :, 0], color=color, label="CTSD")
        ax[index, 1].plot(
            time_vector, control_signals[0, :, 1], "--", color=color2, label="LF"
        )
        if index == (N - 1):
            ax[index, 1].plot(
                time_vector, control_signals[0, :, 0], "--", color=color, label="CTSD"
            )
        ax[index, 0].set_ylabel(f"$x_{index + 1}(t)$")
        ax[index, 1].set_ylabel(f"$s_{index + 1}(t)$")
        ax[index, 0].set_xlim((0, xlim))
        ax[index, 1].set_xlim((0, xlim))
        ax[index, 0].set_ylim((-1, 1))
        ax[index, 0].legend()
    fig.suptitle("Analog state and control contribution evolution")
    ax[-1, 0].set_xlabel("$t / T$")
    ax[-1, 1].set_xlabel("$t / T$")
    fig.tight_layout()





.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_007.png
         :alt: Analog state vectors
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_007.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_008.png
         :alt: Analog state and control contribution evolution
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_008.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0/16384 [00:00<?, ?it/s]      1%|          | 116/16384 [00:00<00:14, 1154.94it/s]      1%|1         | 233/16384 [00:00<00:13, 1163.28it/s]      2%|2         | 352/16384 [00:00<00:13, 1173.70it/s]      3%|2         | 470/16384 [00:00<00:13, 1175.36it/s]      4%|3         | 588/16384 [00:00<00:13, 1168.97it/s]      4%|4         | 705/16384 [00:00<00:13, 1166.81it/s]      5%|5         | 822/16384 [00:00<00:13, 1161.42it/s]      6%|5         | 940/16384 [00:00<00:13, 1164.84it/s]      6%|6         | 1057/16384 [00:00<00:13, 1162.60it/s]      7%|7         | 1174/16384 [00:01<00:13, 1160.65it/s]      8%|7         | 1291/16384 [00:01<00:13, 1147.88it/s]      9%|8         | 1406/16384 [00:01<00:13, 1143.68it/s]      9%|9         | 1521/16384 [00:01<00:12, 1143.55it/s]     10%|9         | 1637/16384 [00:01<00:12, 1146.12it/s]     11%|#         | 1753/16384 [00:01<00:12, 1148.21it/s]     11%|#1        | 1870/16384 [00:01<00:12, 1153.42it/s]     12%|#2        | 1986/16384 [00:01<00:12, 1150.16it/s]     13%|#2        | 2102/16384 [00:01<00:12, 1149.98it/s]     14%|#3        | 2221/16384 [00:01<00:12, 1160.69it/s]     14%|#4        | 2341/16384 [00:02<00:11, 1170.57it/s]     15%|#5        | 2461/16384 [00:02<00:11, 1176.52it/s]     16%|#5        | 2580/16384 [00:02<00:11, 1178.73it/s]     16%|#6        | 2699/16384 [00:02<00:11, 1181.81it/s]     17%|#7        | 2818/16384 [00:02<00:11, 1171.37it/s]     18%|#7        | 2937/16384 [00:02<00:11, 1174.18it/s]     19%|#8        | 3057/16384 [00:02<00:11, 1180.31it/s]     19%|#9        | 3177/16384 [00:02<00:11, 1183.30it/s]     20%|##        | 3296/16384 [00:02<00:11, 1184.35it/s]     21%|##        | 3416/16384 [00:02<00:10, 1186.41it/s]     22%|##1       | 3535/16384 [00:03<00:10, 1186.08it/s]     22%|##2       | 3654/16384 [00:03<00:10, 1182.09it/s]     23%|##3       | 3773/16384 [00:03<00:10, 1179.24it/s]     24%|##3       | 3891/16384 [00:03<00:10, 1174.16it/s]     24%|##4       | 4010/16384 [00:03<00:10, 1178.10it/s]     25%|##5       | 4128/16384 [00:03<00:10, 1175.66it/s]     26%|##5       | 4246/16384 [00:03<00:10, 1176.39it/s]     27%|##6       | 4365/16384 [00:03<00:10, 1180.05it/s]     27%|##7       | 4485/16384 [00:03<00:10, 1184.93it/s]     28%|##8       | 4605/16384 [00:03<00:09, 1186.68it/s]     29%|##8       | 4724/16384 [00:04<00:09, 1181.23it/s]     30%|##9       | 4843/16384 [00:04<00:09, 1180.36it/s]     30%|###       | 4963/16384 [00:04<00:09, 1184.79it/s]     31%|###1      | 5082/16384 [00:04<00:09, 1183.06it/s]     32%|###1      | 5201/16384 [00:04<00:09, 1182.90it/s]     32%|###2      | 5320/16384 [00:04<00:09, 1182.16it/s]     33%|###3      | 5439/16384 [00:04<00:09, 1183.35it/s]     34%|###3      | 5559/16384 [00:04<00:09, 1186.31it/s]     35%|###4      | 5678/16384 [00:04<00:09, 1186.73it/s]     35%|###5      | 5797/16384 [00:04<00:08, 1181.31it/s]     36%|###6      | 5916/16384 [00:05<00:08, 1176.72it/s]     37%|###6      | 6034/16384 [00:05<00:08, 1173.00it/s]     38%|###7      | 6152/16384 [00:05<00:08, 1168.55it/s]     38%|###8      | 6269/16384 [00:05<00:08, 1163.88it/s]     39%|###8      | 6386/16384 [00:05<00:08, 1163.90it/s]     40%|###9      | 6505/16384 [00:05<00:08, 1168.73it/s]     40%|####      | 6624/16384 [00:05<00:08, 1172.88it/s]     41%|####1     | 6743/16384 [00:05<00:08, 1176.00it/s]     42%|####1     | 6861/16384 [00:05<00:08, 1176.07it/s]     43%|####2     | 6979/16384 [00:05<00:08, 1175.02it/s]     43%|####3     | 7097/16384 [00:06<00:07, 1174.76it/s]     44%|####4     | 7215/16384 [00:06<00:07, 1174.05it/s]     45%|####4     | 7334/16384 [00:06<00:07, 1176.11it/s]     45%|####5     | 7453/16384 [00:06<00:07, 1179.93it/s]     46%|####6     | 7572/16384 [00:06<00:07, 1180.76it/s]     47%|####6     | 7691/16384 [00:06<00:07, 1179.21it/s]     48%|####7     | 7810/16384 [00:06<00:07, 1179.96it/s]     48%|####8     | 7929/16384 [00:06<00:07, 1181.33it/s]     49%|####9     | 8049/16384 [00:06<00:07, 1185.82it/s]     50%|####9     | 8169/16384 [00:06<00:06, 1187.13it/s]     51%|#####     | 8288/16384 [00:07<00:06, 1185.72it/s]     51%|#####1    | 8408/16384 [00:07<00:06, 1187.05it/s]     52%|#####2    | 8527/16384 [00:07<00:06, 1187.29it/s]     53%|#####2    | 8647/16384 [00:07<00:06, 1190.52it/s]     54%|#####3    | 8767/16384 [00:07<00:06, 1187.47it/s]     54%|#####4    | 8887/16384 [00:07<00:06, 1188.57it/s]     55%|#####4    | 9006/16384 [00:07<00:06, 1188.59it/s]     56%|#####5    | 9126/16384 [00:07<00:06, 1189.75it/s]     56%|#####6    | 9245/16384 [00:07<00:06, 1189.02it/s]     57%|#####7    | 9365/16384 [00:07<00:05, 1191.22it/s]     58%|#####7    | 9485/16384 [00:08<00:05, 1188.33it/s]     59%|#####8    | 9605/16384 [00:08<00:05, 1189.61it/s]     59%|#####9    | 9724/16384 [00:08<00:05, 1188.45it/s]     60%|######    | 9844/16384 [00:08<00:05, 1190.26it/s]     61%|######    | 9964/16384 [00:08<00:05, 1188.54it/s]     62%|######1   | 10083/16384 [00:08<00:05, 1182.74it/s]     62%|######2   | 10202/16384 [00:08<00:05, 1175.43it/s]     63%|######2   | 10320/16384 [00:08<00:05, 1173.89it/s]     64%|######3   | 10439/16384 [00:08<00:05, 1178.46it/s]     64%|######4   | 10558/16384 [00:08<00:04, 1180.11it/s]     65%|######5   | 10677/16384 [00:09<00:04, 1182.79it/s]     66%|######5   | 10796/16384 [00:09<00:04, 1184.79it/s]     67%|######6   | 10916/16384 [00:09<00:04, 1187.85it/s]     67%|######7   | 11035/16384 [00:09<00:04, 1181.19it/s]     68%|######8   | 11154/16384 [00:09<00:04, 1179.91it/s]     69%|######8   | 11273/16384 [00:09<00:04, 1180.85it/s]     70%|######9   | 11392/16384 [00:09<00:04, 1182.44it/s]     70%|#######   | 11512/16384 [00:09<00:04, 1185.12it/s]     71%|#######   | 11631/16384 [00:09<00:04, 1186.31it/s]     72%|#######1  | 11750/16384 [00:09<00:03, 1182.68it/s]     72%|#######2  | 11869/16384 [00:10<00:03, 1172.15it/s]     73%|#######3  | 11988/16384 [00:10<00:03, 1176.99it/s]     74%|#######3  | 12107/16384 [00:10<00:03, 1179.59it/s]     75%|#######4  | 12227/16384 [00:10<00:03, 1183.80it/s]     75%|#######5  | 12347/16384 [00:10<00:03, 1185.66it/s]     76%|#######6  | 12467/16384 [00:10<00:03, 1187.40it/s]     77%|#######6  | 12586/16384 [00:10<00:03, 1186.32it/s]     78%|#######7  | 12705/16384 [00:10<00:03, 1186.71it/s]     78%|#######8  | 12824/16384 [00:10<00:03, 1180.76it/s]     79%|#######8  | 12943/16384 [00:10<00:02, 1177.88it/s]     80%|#######9  | 13062/16384 [00:11<00:02, 1179.21it/s]     80%|########  | 13181/16384 [00:11<00:02, 1179.60it/s]     81%|########1 | 13301/16384 [00:11<00:02, 1183.67it/s]     82%|########1 | 13420/16384 [00:11<00:02, 1184.36it/s]     83%|########2 | 13540/16384 [00:11<00:02, 1186.77it/s]     83%|########3 | 13659/16384 [00:11<00:02, 1185.07it/s]     84%|########4 | 13778/16384 [00:11<00:02, 1186.36it/s]     85%|########4 | 13897/16384 [00:11<00:02, 1184.72it/s]     86%|########5 | 14017/16384 [00:11<00:01, 1187.72it/s]     86%|########6 | 14136/16384 [00:11<00:01, 1185.45it/s]     87%|########7 | 14255/16384 [00:12<00:01, 1178.58it/s]     88%|########7 | 14373/16384 [00:12<00:01, 1163.70it/s]     88%|########8 | 14490/16384 [00:12<00:01, 1164.33it/s]     89%|########9 | 14608/16384 [00:12<00:01, 1168.88it/s]     90%|########9 | 14727/16384 [00:12<00:01, 1172.31it/s]     91%|######### | 14846/16384 [00:12<00:01, 1176.77it/s]     91%|#########1| 14965/16384 [00:12<00:01, 1177.81it/s]     92%|#########2| 15084/16384 [00:12<00:01, 1178.47it/s]     93%|#########2| 15202/16384 [00:12<00:01, 1176.31it/s]     94%|#########3| 15320/16384 [00:13<00:00, 1174.80it/s]     94%|#########4| 15440/16384 [00:13<00:00, 1179.88it/s]     95%|#########4| 15559/16384 [00:13<00:00, 1181.77it/s]     96%|#########5| 15678/16384 [00:13<00:00, 1183.98it/s]     96%|#########6| 15798/16384 [00:13<00:00, 1186.81it/s]     97%|#########7| 15917/16384 [00:13<00:00, 1187.46it/s]     98%|#########7| 16037/16384 [00:13<00:00, 1189.26it/s]     99%|#########8| 16156/16384 [00:13<00:00, 1188.52it/s]     99%|#########9| 16276/16384 [00:13<00:00, 1189.91it/s]    100%|##########| 16384/16384 [00:13<00:00, 1178.37it/s]




.. GENERATED FROM PYTHON SOURCE LINES 262-265

Simulation
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 265-277

.. code-block:: default


    size = 1 << 14
    u_hat_ctsd = np.zeros(size)
    u_hat_leap_frog = np.zeros(size)

    for index in range(size):
        u_hat_ctsd[index] = next(digital_estimator_ctsd)
        u_hat_leap_frog[index] = next(digital_estimator_leap_frog)

    u_hat_ctsd = u_hat_ctsd[K1 + K2 :]
    u_hat_leap_frog = u_hat_leap_frog[K1 + K2 :]








.. GENERATED FROM PYTHON SOURCE LINES 278-281

Visualize Results
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 281-334

.. code-block:: default


    plt.rcParams["figure.figsize"] = [6.40 * 1.34, 6.40]

    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_ctsd[:],
        fs=1 / analog_frontend_ctsd.digital_control.clock.T,
        nperseg=u_hat_ctsd.size,
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / analog_frontend_ctsd.digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"CTSD, OSR={1/(2 * analog_frontend_ctsd.digital_control.clock.T * BW):.0f}, est_ENOB={est_ENOB:.1f} bits, est_SNR={est_SNR:.1f} dB",
    )

    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_leap_frog[:],
        fs=1 / analog_frontend_ctsd.digital_control.clock.T,
        nperseg=u_hat_leap_frog.size,
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / analog_frontend_ctsd.digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"LF, OSR={1/(2 * analog_frontend_ctsd.digital_control.clock.T * BW):.0f}, est_ENOB={est_ENOB:.1f} bits, est_SNR={est_SNR:.1f} dB",
    )

    plt.title("Power spectral density of input estimate")
    plt.xlabel('Hz')
    plt.ylabel('$V^2$ / Hz dB')
    plt.legend()
    plt.grid(which="both")
    plt.gcf().tight_layout()





.. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_009.png
   :alt: Power spectral density of input estimate
   :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_009.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 335-338

Time
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 338-349

.. code-block:: default


    t = np.arange(u_hat_ctsd.size)
    plt.plot(t, u_hat_ctsd, label="CTSD")
    plt.plot(t, u_hat_leap_frog, label="LF")
    plt.xlabel("$t / T$")
    plt.ylabel("$\hat{u}(t)$")
    plt.title("Estimated input signal")
    plt.grid()
    plt.xlim((0, 1500))
    plt.ylim((-1, 1))
    plt.tight_layout()



.. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_010.png
   :alt: Estimated input signal
   :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_010.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  39.405 seconds)


.. _sphx_glr_download_tutorials_b_high_level_simulation_plot_i_simulating_a_delta_sigma_modulator.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_i_simulating_a_delta_sigma_modulator.py <plot_i_simulating_a_delta_sigma_modulator.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_i_simulating_a_delta_sigma_modulator.ipynb <plot_i_simulating_a_delta_sigma_modulator.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
