
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/b_high_level_simulation/plot_i_simulating_a_delta_sigma_modulator.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_b_high_level_simulation_plot_i_simulating_a_delta_sigma_modulator.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_b_high_level_simulation_plot_i_simulating_a_delta_sigma_modulator.py:


Simulating a CTDS Modulator
==================================================

.. GENERATED FROM PYTHON SOURCE LINES 5-17

.. code-block:: default

    import cbadc
    import numpy as np
    import matplotlib.pyplot as plt
    import json

    T = 0.1e-8
    N = 5
    K1 = 1 << 9
    K2 = K1
    OSR = 16
    BW = 1 / (2 * T * OSR)








.. GENERATED FROM PYTHON SOURCE LINES 18-24

Instantiating the Analog System and Digital Control
---------------------------------------------------

We start by loading a delta sigma modulator constructed
using the `www.sigma-delta.de <www.sigma-delta.de>`_ framework.


.. GENERATED FROM PYTHON SOURCE LINES 24-47

.. code-block:: default


    with open('CTSD_N5_OSR16_Q32_CRFF_OPT1_HINF600.json') as f:
        analog_frontend_ctsd = cbadc.synthesis.ctsd_dict2af(json.load(f), T)

    eta2_ctsd = (
        np.linalg.norm(
            analog_frontend_ctsd.analog_system.transfer_function_matrix(
                np.array([2 * np.pi * BW])
            )
        )
        ** 2
    )

    digital_estimator_ctsd = cbadc.digital_estimator.BatchEstimator(
        analog_frontend_ctsd.analog_system,
        analog_frontend_ctsd.digital_control,
        eta2_ctsd,
        K1,
        K2,
    )

    print(analog_frontend_ctsd.analog_system)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 1.95e+09  0.00e+00 -1.03e+07  0.00e+00  0.00e+00]
     [ 0.00e+00  1.09e+09  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  9.63e+08  0.00e+00 -5.34e+07]
     [ 0.00e+00  0.00e+00  0.00e+00  5.93e+08  0.00e+00]],
    B =
    [[ 1.69e+08]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]],
    CT = 
    [[ 1.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  1.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  1.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  1.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  1.00e+00]],
    Gamma =
    [[-1.69e+08]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]],
    Gamma_tildeT =
    [[ 1.07e+01  6.74e+00  5.08e+00  2.69e+00  9.61e-01]], and D=[[ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]]




.. GENERATED FROM PYTHON SOURCE LINES 48-51

Leap Frog
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 51-93

.. code-block:: default


    analog_frontend_leap_frog = cbadc.synthesis.get_leap_frog(
        OSR=OSR, N=N, BW=BW, opt=False
    )

    analog_frontend_leap_frog.digital_control = (
        cbadc.digital_control.MultiLevelDigitalControl(
            analog_frontend_leap_frog.digital_control.clock, N, [1] * N
        )
    )

    # Scale B
    # analog_frontend_leap_frog.analog_system.B = (
    #     2 * analog_frontend_leap_frog.analog_system.B
    # )


    # Scale Gamma
    # analog_frontend_leap_frog.analog_system.Gamma = np.dot(
    #     np.diag(np.array([0.5 ** (x + 1) for x in range(N)])),
    #     analog_frontend_leap_frog.analog_system.Gamma,
    # )

    eta2_leap_frog = (
        np.linalg.norm(
            analog_frontend_leap_frog.analog_system.transfer_function_matrix(
                np.array([2 * np.pi * BW])
            )
        )
        ** 2
    )

    digital_estimator_leap_frog = cbadc.digital_estimator.BatchEstimator(
        analog_frontend_leap_frog.analog_system,
        analog_frontend_leap_frog.digital_control,
        eta2_leap_frog,
        K1,
        K2,
    )

    print(analog_frontend_leap_frog.analog_system)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ 0.00e+00 -1.93e+07  0.00e+00  0.00e+00  0.00e+00]
     [ 5.00e+08  0.00e+00 -1.93e+07  0.00e+00  0.00e+00]
     [ 0.00e+00  5.00e+08  0.00e+00 -1.93e+07  0.00e+00]
     [ 0.00e+00  0.00e+00  5.00e+08  0.00e+00 -1.93e+07]
     [ 0.00e+00  0.00e+00  0.00e+00  5.00e+08  0.00e+00]],
    B =
    [[ 5.00e+08]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]],
    CT = 
    [[ 1.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  1.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  1.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  1.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  1.00e+00]],
    Gamma =
    [[ 5.00e+08  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  5.00e+08  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  5.00e+08  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  5.00e+08  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  5.00e+08]],
    Gamma_tildeT =
    [[-1.00e+00 -0.00e+00 -0.00e+00 -0.00e+00 -0.00e+00]
     [-0.00e+00 -1.00e+00 -0.00e+00 -0.00e+00 -0.00e+00]
     [-0.00e+00 -0.00e+00 -1.00e+00 -0.00e+00 -0.00e+00]
     [-0.00e+00 -0.00e+00 -0.00e+00 -1.00e+00 -0.00e+00]
     [-0.00e+00 -0.00e+00 -0.00e+00 -0.00e+00 -1.00e+00]], and D=[[ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]]




.. GENERATED FROM PYTHON SOURCE LINES 94-97

Input Signal
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 97-107

.. code-block:: default

    amplitude = 0.25e-0
    phase = 0.0
    offset = 0.0
    frequency = 1.0 / analog_frontend_ctsd.digital_control.clock.T

    while frequency > BW:
        frequency /= 2
    input_signal = cbadc.analog_signal.Sinusoidal(amplitude, frequency, phase, offset)
    # input_signal = cbadc.analog_signal.ConstantSignal(amplitude)








.. GENERATED FROM PYTHON SOURCE LINES 108-111

Transfer Functions
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 111-176

.. code-block:: default


    # Logspace frequencies
    frequencies = np.logspace(3, 8, 1000)
    omega = 2 * np.pi * frequencies

    # Compute transfer functions for each frequency in frequencies
    transfer_function_ctsd = analog_frontend_ctsd.analog_system.transfer_function_matrix(
        omega
    )
    transfer_function_ctsd_dB = 20 * np.log10(np.abs(transfer_function_ctsd))

    transfer_function_leap_frog = (
        analog_frontend_leap_frog.analog_system.transfer_function_matrix(omega)
    )
    transfer_function_leap_frog_dB = 20 * np.log10(np.abs(transfer_function_leap_frog))

    G_omega = 20 * np.log10(np.linalg.norm(transfer_function_ctsd[:, 0, :], axis=0))

    plt.semilogx([BW, BW], [np.min(G_omega), np.max(G_omega)], '--', label="BW")

    # Add the norm ||G(omega)||_2
    plt.semilogx(
        frequencies,
        20 * np.log10(np.linalg.norm(transfer_function_leap_frog[:, 0, :], axis=0)),
        label="LF $ ||\mathbf{G}(\omega)||_2 $",
    )
    plt.semilogx(
        frequencies,
        G_omega,
        label="CTSD $ ||\mathbf{G}(\omega)||_2 $",
    )


    # Add labels and legends to figure
    plt.legend()
    plt.grid(which="both")
    plt.xlabel("$f$ [Hz]")
    plt.ylabel("dB")
    plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()


    for n in range(N):
        plt.figure()
        #     color = next(plt.gca()._get_lines.prop_cycler)["color"]
        plt.semilogx(
            frequencies,
            transfer_function_leap_frog_dB[n, 0, :],
            label="LF $G_" + f"{n+1}" + "(f)$",
            # color = color
        )
        plt.semilogx(
            frequencies,
            transfer_function_ctsd_dB[n, 0, :],
            '--',
            label="CTSD $G_" + f"{n+1}" + "(f)$",
            #     # color = color
        )
        plt.legend()
        plt.grid(which="both")
        plt.xlabel("$f$ [Hz]")
        plt.ylabel("dB")
        plt.xlim((frequencies[0], frequencies[-1]))
        plt.gcf().tight_layout()




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_001.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_002.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_003.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_004.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_005.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_005.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_006.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_006.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 177-180

Simulation Setup
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 180-196

.. code-block:: default


    simulator_ctsd = cbadc.simulator.get_simulator(
        analog_frontend_ctsd.analog_system,
        analog_frontend_ctsd.digital_control,
        [input_signal],
    )
    digital_estimator_ctsd(simulator_ctsd)

    simulator_leap_frog = cbadc.simulator.get_simulator(
        analog_frontend_leap_frog.analog_system,
        analog_frontend_leap_frog.digital_control,
        [input_signal],
    )
    digital_estimator_leap_frog(simulator_leap_frog)









.. GENERATED FROM PYTHON SOURCE LINES 197-200

Simulate State Trajectories
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 200-261

.. code-block:: default


    # Simulate for 65536 control cycles.
    size = 1 << 14

    time_vector = np.arange(size)
    states = np.zeros((N, size, 2))
    control_signals = np.zeros((N, size, 2), dtype=np.double)

    # Iterate through and store states and control_signals.
    simulator_ctsd = cbadc.simulator.extended_simulation_result(simulator_ctsd)
    simulator_leap_frog = cbadc.simulator.extended_simulation_result(simulator_leap_frog)
    for index in cbadc.utilities.show_status(range(size)):
        res_ctsd = next(simulator_ctsd)
        states[:, index, 0] = res_ctsd["analog_state"]
        control_signals[:, index, 0] = res_ctsd["control_signal"]
        res_leap_frog = next(simulator_leap_frog)
        states[:, index, 1] = res_leap_frog["analog_state"]
        control_signals[:, index, 1] = res_leap_frog["control_signal"]

    xlim = 1 << 12
    # Plot all analog state evolutions.
    plt.figure()
    plt.title("Analog state vectors")
    for index in range(N):
        plt.plot(time_vector, states[index, :, 1], label=f"LF $x_{index + 1}(t)$")
        plt.plot(time_vector, states[index, :, 0], label=f"CTSD $x_{index + 1}(t)$")
    plt.grid(visible=True, which="major", color="gray", alpha=0.6, lw=1.5)
    plt.xlabel("$t/T$")
    plt.xlim((0, xlim))
    plt.legend()


    # reset figure size and plot individual results.
    plt.rcParams["figure.figsize"] = [6.40, 6.40 * 2]
    fig, ax = plt.subplots(N, 2)
    for index in range(N):
        color = next(ax[0, 0]._get_lines.prop_cycler)["color"]
        color2 = next(ax[0, 0]._get_lines.prop_cycler)["color"]
        ax[index, 0].grid(visible=True, which="major", color="gray", alpha=0.6, lw=1.5)
        ax[index, 1].grid(visible=True, which="major", color="gray", alpha=0.6, lw=1.5)
        ax[index, 0].plot(time_vector, states[index, :, 1], color=color2, label="LF")
        ax[index, 0].plot(time_vector, states[index, :, 0], color=color, label="CTSD")
        ax[index, 1].plot(
            time_vector, control_signals[0, :, 1], "--", color=color2, label="LF"
        )
        if index == (N - 1):
            ax[index, 1].plot(
                time_vector, control_signals[0, :, 0], "--", color=color, label="CTSD"
            )
        ax[index, 0].set_ylabel(f"$x_{index + 1}(t)$")
        ax[index, 1].set_ylabel(f"$s_{index + 1}(t)$")
        ax[index, 0].set_xlim((0, xlim))
        ax[index, 1].set_xlim((0, xlim))
        ax[index, 0].set_ylim((-1, 1))
        ax[index, 0].legend()
    fig.suptitle("Analog state and control contribution evolution")
    ax[-1, 0].set_xlabel("$t / T$")
    ax[-1, 1].set_xlabel("$t / T$")
    fig.tight_layout()





.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_007.png
         :alt: Analog state vectors
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_007.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_008.png
         :alt: Analog state and control contribution evolution
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_008.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0/16384 [00:00<?, ?it/s]      1%|          | 120/16384 [00:00<00:13, 1193.06it/s]      1%|1         | 242/16384 [00:00<00:13, 1204.27it/s]      2%|2         | 364/16384 [00:00<00:13, 1207.62it/s]      3%|2         | 486/16384 [00:00<00:13, 1208.48it/s]      4%|3         | 608/16384 [00:00<00:13, 1210.67it/s]      4%|4         | 730/16384 [00:00<00:12, 1211.03it/s]      5%|5         | 852/16384 [00:00<00:12, 1211.80it/s]      6%|5         | 974/16384 [00:00<00:12, 1210.55it/s]      7%|6         | 1096/16384 [00:00<00:12, 1212.01it/s]      7%|7         | 1218/16384 [00:01<00:12, 1208.63it/s]      8%|8         | 1339/16384 [00:01<00:12, 1203.17it/s]      9%|8         | 1462/16384 [00:01<00:12, 1208.24it/s]     10%|9         | 1584/16384 [00:01<00:12, 1210.51it/s]     10%|#         | 1706/16384 [00:01<00:12, 1210.33it/s]     11%|#1        | 1828/16384 [00:01<00:12, 1208.95it/s]     12%|#1        | 1949/16384 [00:01<00:12, 1200.64it/s]     13%|#2        | 2070/16384 [00:01<00:11, 1203.25it/s]     13%|#3        | 2191/16384 [00:01<00:11, 1205.14it/s]     14%|#4        | 2312/16384 [00:01<00:11, 1193.16it/s]     15%|#4        | 2432/16384 [00:02<00:11, 1183.71it/s]     16%|#5        | 2553/16384 [00:02<00:11, 1190.73it/s]     16%|#6        | 2675/16384 [00:02<00:11, 1198.33it/s]     17%|#7        | 2797/16384 [00:02<00:11, 1201.81it/s]     18%|#7        | 2919/16384 [00:02<00:11, 1206.29it/s]     19%|#8        | 3041/16384 [00:02<00:11, 1208.21it/s]     19%|#9        | 3163/16384 [00:02<00:10, 1208.84it/s]     20%|##        | 3285/16384 [00:02<00:10, 1209.28it/s]     21%|##        | 3406/16384 [00:02<00:10, 1208.15it/s]     22%|##1       | 3529/16384 [00:02<00:10, 1212.04it/s]     22%|##2       | 3652/16384 [00:03<00:10, 1216.10it/s]     23%|##3       | 3775/16384 [00:03<00:10, 1217.82it/s]     24%|##3       | 3898/16384 [00:03<00:10, 1219.88it/s]     25%|##4       | 4021/16384 [00:03<00:10, 1222.64it/s]     25%|##5       | 4144/16384 [00:03<00:10, 1223.07it/s]     26%|##6       | 4267/16384 [00:03<00:09, 1223.69it/s]     27%|##6       | 4391/16384 [00:03<00:09, 1225.55it/s]     28%|##7       | 4514/16384 [00:03<00:09, 1225.55it/s]     28%|##8       | 4637/16384 [00:03<00:09, 1224.82it/s]     29%|##9       | 4760/16384 [00:03<00:09, 1226.31it/s]     30%|##9       | 4883/16384 [00:04<00:09, 1225.73it/s]     31%|###       | 5006/16384 [00:04<00:09, 1223.63it/s]     31%|###1      | 5129/16384 [00:04<00:09, 1223.54it/s]     32%|###2      | 5252/16384 [00:04<00:09, 1224.51it/s]     33%|###2      | 5375/16384 [00:04<00:08, 1223.71it/s]     34%|###3      | 5498/16384 [00:04<00:08, 1221.27it/s]     34%|###4      | 5621/16384 [00:04<00:08, 1213.97it/s]     35%|###5      | 5743/16384 [00:04<00:08, 1213.52it/s]     36%|###5      | 5865/16384 [00:04<00:08, 1214.45it/s]     37%|###6      | 5988/16384 [00:04<00:08, 1216.95it/s]     37%|###7      | 6110/16384 [00:05<00:08, 1216.06it/s]     38%|###8      | 6232/16384 [00:05<00:08, 1205.47it/s]     39%|###8      | 6353/16384 [00:05<00:08, 1202.96it/s]     40%|###9      | 6474/16384 [00:05<00:08, 1204.48it/s]     40%|####      | 6596/16384 [00:05<00:08, 1207.41it/s]     41%|####1     | 6718/16384 [00:05<00:07, 1208.62it/s]     42%|####1     | 6839/16384 [00:05<00:07, 1207.59it/s]     42%|####2     | 6960/16384 [00:05<00:07, 1202.93it/s]     43%|####3     | 7081/16384 [00:05<00:07, 1202.59it/s]     44%|####3     | 7203/16384 [00:05<00:07, 1206.71it/s]     45%|####4     | 7324/16384 [00:06<00:07, 1201.17it/s]     45%|####5     | 7445/16384 [00:06<00:07, 1202.10it/s]     46%|####6     | 7567/16384 [00:06<00:07, 1206.66it/s]     47%|####6     | 7689/16384 [00:06<00:07, 1209.73it/s]     48%|####7     | 7812/16384 [00:06<00:07, 1214.47it/s]     48%|####8     | 7935/16384 [00:06<00:06, 1216.89it/s]     49%|####9     | 8058/16384 [00:06<00:06, 1218.96it/s]     50%|####9     | 8180/16384 [00:06<00:06, 1218.73it/s]     51%|#####     | 8302/16384 [00:06<00:06, 1216.21it/s]     51%|#####1    | 8424/16384 [00:06<00:06, 1215.17it/s]     52%|#####2    | 8546/16384 [00:07<00:06, 1213.44it/s]     53%|#####2    | 8668/16384 [00:07<00:06, 1212.83it/s]     54%|#####3    | 8790/16384 [00:07<00:06, 1214.05it/s]     54%|#####4    | 8912/16384 [00:07<00:06, 1213.38it/s]     55%|#####5    | 9034/16384 [00:07<00:06, 1213.65it/s]     56%|#####5    | 9156/16384 [00:07<00:05, 1214.66it/s]     57%|#####6    | 9278/16384 [00:07<00:05, 1213.79it/s]     57%|#####7    | 9400/16384 [00:07<00:05, 1214.99it/s]     58%|#####8    | 9522/16384 [00:07<00:05, 1215.40it/s]     59%|#####8    | 9644/16384 [00:07<00:05, 1215.04it/s]     60%|#####9    | 9766/16384 [00:08<00:05, 1216.35it/s]     60%|######    | 9888/16384 [00:08<00:05, 1207.59it/s]     61%|######1   | 10010/16384 [00:08<00:05, 1209.76it/s]     62%|######1   | 10132/16384 [00:08<00:05, 1212.07it/s]     63%|######2   | 10254/16384 [00:08<00:05, 1209.67it/s]     63%|######3   | 10377/16384 [00:08<00:04, 1212.92it/s]     64%|######4   | 10499/16384 [00:08<00:04, 1211.66it/s]     65%|######4   | 10621/16384 [00:08<00:04, 1209.24it/s]     66%|######5   | 10743/16384 [00:08<00:04, 1211.95it/s]     66%|######6   | 10865/16384 [00:08<00:04, 1213.49it/s]     67%|######7   | 10987/16384 [00:09<00:04, 1214.07it/s]     68%|######7   | 11109/16384 [00:09<00:04, 1214.37it/s]     69%|######8   | 11231/16384 [00:09<00:04, 1211.15it/s]     69%|######9   | 11353/16384 [00:09<00:04, 1211.92it/s]     70%|#######   | 11475/16384 [00:09<00:04, 1206.41it/s]     71%|#######   | 11596/16384 [00:09<00:03, 1202.31it/s]     72%|#######1  | 11718/16384 [00:09<00:03, 1206.98it/s]     72%|#######2  | 11840/16384 [00:09<00:03, 1208.27it/s]     73%|#######3  | 11961/16384 [00:09<00:03, 1208.67it/s]     74%|#######3  | 12083/16384 [00:09<00:03, 1209.21it/s]     74%|#######4  | 12204/16384 [00:10<00:03, 1200.02it/s]     75%|#######5  | 12327/16384 [00:10<00:03, 1206.01it/s]     76%|#######5  | 12448/16384 [00:10<00:03, 1181.73it/s]     77%|#######6  | 12567/16384 [00:10<00:03, 1164.60it/s]     77%|#######7  | 12684/16384 [00:10<00:03, 1153.00it/s]     78%|#######8  | 12800/16384 [00:10<00:03, 1152.39it/s]     79%|#######8  | 12921/16384 [00:10<00:02, 1168.75it/s]     80%|#######9  | 13043/16384 [00:10<00:02, 1182.45it/s]     80%|########  | 13162/16384 [00:10<00:02, 1180.35it/s]     81%|########1 | 13281/16384 [00:11<00:02, 1160.06it/s]     82%|########1 | 13398/16384 [00:11<00:02, 1155.61it/s]     82%|########2 | 13515/16384 [00:11<00:02, 1158.49it/s]     83%|########3 | 13637/16384 [00:11<00:02, 1174.00it/s]     84%|########3 | 13757/16384 [00:11<00:02, 1181.42it/s]     85%|########4 | 13879/16384 [00:11<00:02, 1191.91it/s]     85%|########5 | 14002/16384 [00:11<00:01, 1201.57it/s]     86%|########6 | 14124/16384 [00:11<00:01, 1204.57it/s]     87%|########6 | 14247/16384 [00:11<00:01, 1209.38it/s]     88%|########7 | 14370/16384 [00:11<00:01, 1212.94it/s]     88%|########8 | 14493/16384 [00:12<00:01, 1215.54it/s]     89%|########9 | 14616/16384 [00:12<00:01, 1218.40it/s]     90%|########9 | 14739/16384 [00:12<00:01, 1220.76it/s]     91%|######### | 14862/16384 [00:12<00:01, 1197.69it/s]     91%|#########1| 14982/16384 [00:12<00:01, 1195.34it/s]     92%|#########2| 15102/16384 [00:12<00:01, 1185.84it/s]     93%|#########2| 15225/16384 [00:12<00:00, 1197.55it/s]     94%|#########3| 15348/16384 [00:12<00:00, 1206.87it/s]     94%|#########4| 15470/16384 [00:12<00:00, 1208.75it/s]     95%|#########5| 15593/16384 [00:12<00:00, 1213.81it/s]     96%|#########5| 15717/16384 [00:13<00:00, 1218.61it/s]     97%|#########6| 15840/16384 [00:13<00:00, 1221.26it/s]     97%|#########7| 15963/16384 [00:13<00:00, 1223.27it/s]     98%|#########8| 16086/16384 [00:13<00:00, 1224.15it/s]     99%|#########8| 16209/16384 [00:13<00:00, 1224.29it/s]    100%|#########9| 16332/16384 [00:13<00:00, 1222.02it/s]    100%|##########| 16384/16384 [00:13<00:00, 1207.23it/s]




.. GENERATED FROM PYTHON SOURCE LINES 262-265

Simulation
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 265-277

.. code-block:: default


    size = 1 << 14
    u_hat_ctsd = np.zeros(size)
    u_hat_leap_frog = np.zeros(size)

    for index in range(size):
        u_hat_ctsd[index] = next(digital_estimator_ctsd)
        u_hat_leap_frog[index] = next(digital_estimator_leap_frog)

    u_hat_ctsd = u_hat_ctsd[K1 + K2 :]
    u_hat_leap_frog = u_hat_leap_frog[K1 + K2 :]








.. GENERATED FROM PYTHON SOURCE LINES 278-281

Visualize Results
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 281-334

.. code-block:: default


    plt.rcParams["figure.figsize"] = [6.40 * 1.34, 6.40]

    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_ctsd[:],
        fs=1 / analog_frontend_ctsd.digital_control.clock.T,
        nperseg=u_hat_ctsd.size,
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / analog_frontend_ctsd.digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"CTSD, OSR={1/(2 * analog_frontend_ctsd.digital_control.clock.T * BW):.0f}, est_ENOB={est_ENOB:.1f} bits, est_SNR={est_SNR:.1f} dB",
    )

    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_leap_frog[:],
        fs=1 / analog_frontend_ctsd.digital_control.clock.T,
        nperseg=u_hat_leap_frog.size,
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / analog_frontend_ctsd.digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"LF, OSR={1/(2 * analog_frontend_ctsd.digital_control.clock.T * BW):.0f}, est_ENOB={est_ENOB:.1f} bits, est_SNR={est_SNR:.1f} dB",
    )

    plt.title("Power spectral density of input estimate")
    plt.xlabel('Hz')
    plt.ylabel('$V^2$ / Hz dB')
    plt.legend()
    plt.grid(which="both")
    plt.gcf().tight_layout()





.. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_009.png
   :alt: Power spectral density of input estimate
   :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_009.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 335-338

Time
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 338-349

.. code-block:: default


    t = np.arange(u_hat_ctsd.size)
    plt.plot(t, u_hat_ctsd, label="CTSD")
    plt.plot(t, u_hat_leap_frog, label="LF")
    plt.xlabel("$t / T$")
    plt.ylabel("$\hat{u}(t)$")
    plt.title("Estimated input signal")
    plt.grid()
    plt.xlim((0, 1500))
    plt.ylim((-1, 1))
    plt.tight_layout()



.. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_010.png
   :alt: Estimated input signal
   :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_010.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  7.984 seconds)


.. _sphx_glr_download_tutorials_b_high_level_simulation_plot_i_simulating_a_delta_sigma_modulator.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_i_simulating_a_delta_sigma_modulator.py <plot_i_simulating_a_delta_sigma_modulator.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_i_simulating_a_delta_sigma_modulator.ipynb <plot_i_simulating_a_delta_sigma_modulator.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
