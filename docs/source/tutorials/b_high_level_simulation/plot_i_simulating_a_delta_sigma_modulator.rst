
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/b_high_level_simulation/plot_i_simulating_a_delta_sigma_modulator.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_b_high_level_simulation_plot_i_simulating_a_delta_sigma_modulator.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_b_high_level_simulation_plot_i_simulating_a_delta_sigma_modulator.py:


Simulating a CTDS Modulator
==================================================

.. GENERATED FROM PYTHON SOURCE LINES 5-17

.. code-block:: default

    import cbadc
    import numpy as np
    import matplotlib.pyplot as plt
    import json

    T = 0.1e-8
    N = 5
    K1 = 1 << 9
    K2 = K1
    OSR = 16
    BW = 1 / (2 * T * OSR)








.. GENERATED FROM PYTHON SOURCE LINES 18-24

Instantiating the Analog System and Digital Control
---------------------------------------------------

We start by loading a delta sigma modulator constructed
using the `www.sigma-delta.de <www.sigma-delta.de>`_ framework.


.. GENERATED FROM PYTHON SOURCE LINES 24-47

.. code-block:: default


    with open('CTSD_N5_OSR16_Q32_CRFF_OPT1_HINF600.json') as f:
        analog_frontend_ctsd = cbadc.synthesis.ctsd_dict2af(json.load(f), T)

    eta2_ctsd = (
        np.linalg.norm(
            analog_frontend_ctsd.analog_system.transfer_function_matrix(
                np.array([2 * np.pi * BW])
            )
        )
        ** 2
    )

    digital_estimator_ctsd = cbadc.digital_estimator.BatchEstimator(
        analog_frontend_ctsd.analog_system,
        analog_frontend_ctsd.digital_control,
        eta2_ctsd,
        K1,
        K2,
    )

    print(analog_frontend_ctsd.analog_system)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 1.95e+09  0.00e+00 -1.03e+07  0.00e+00  0.00e+00]
     [ 0.00e+00  1.09e+09  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  9.63e+08  0.00e+00 -5.34e+07]
     [ 0.00e+00  0.00e+00  0.00e+00  5.93e+08  0.00e+00]],
    B =
    [[ 1.69e+08]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]],
    CT = 
    [[ 1.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  1.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  1.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  1.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  1.00e+00]],
    Gamma =
    [[-1.69e+08]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]],
    Gamma_tildeT =
    [[ 1.07e+01  6.74e+00  5.08e+00  2.69e+00  9.61e-01]], and D=[[ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]]




.. GENERATED FROM PYTHON SOURCE LINES 48-51

Leap Frog
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 51-93

.. code-block:: default


    analog_frontend_leap_frog = cbadc.synthesis.get_leap_frog(
        OSR=OSR, N=N, BW=BW, opt=False
    )

    analog_frontend_leap_frog.digital_control = (
        cbadc.digital_control.MultiLevelDigitalControl(
            analog_frontend_leap_frog.digital_control.clock, N, [1] * N
        )
    )

    # Scale B
    # analog_frontend_leap_frog.analog_system.B = (
    #     2 * analog_frontend_leap_frog.analog_system.B
    # )


    # Scale Gamma
    # analog_frontend_leap_frog.analog_system.Gamma = np.dot(
    #     np.diag(np.array([0.5 ** (x + 1) for x in range(N)])),
    #     analog_frontend_leap_frog.analog_system.Gamma,
    # )

    eta2_leap_frog = (
        np.linalg.norm(
            analog_frontend_leap_frog.analog_system.transfer_function_matrix(
                np.array([2 * np.pi * BW])
            )
        )
        ** 2
    )

    digital_estimator_leap_frog = cbadc.digital_estimator.BatchEstimator(
        analog_frontend_leap_frog.analog_system,
        analog_frontend_leap_frog.digital_control,
        eta2_leap_frog,
        K1,
        K2,
    )

    print(analog_frontend_leap_frog.analog_system)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ 0.00e+00 -1.93e+07  0.00e+00  0.00e+00  0.00e+00]
     [ 5.00e+08  0.00e+00 -1.93e+07  0.00e+00  0.00e+00]
     [ 0.00e+00  5.00e+08  0.00e+00 -1.93e+07  0.00e+00]
     [ 0.00e+00  0.00e+00  5.00e+08  0.00e+00 -1.93e+07]
     [ 0.00e+00  0.00e+00  0.00e+00  5.00e+08  0.00e+00]],
    B =
    [[ 5.00e+08]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]],
    CT = 
    [[ 1.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  1.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  1.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  1.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  1.00e+00]],
    Gamma =
    [[ 5.00e+08  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  5.00e+08  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  5.00e+08  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  5.00e+08  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  5.00e+08]],
    Gamma_tildeT =
    [[-1.00e+00 -0.00e+00 -0.00e+00 -0.00e+00 -0.00e+00]
     [-0.00e+00 -1.00e+00 -0.00e+00 -0.00e+00 -0.00e+00]
     [-0.00e+00 -0.00e+00 -1.00e+00 -0.00e+00 -0.00e+00]
     [-0.00e+00 -0.00e+00 -0.00e+00 -1.00e+00 -0.00e+00]
     [-0.00e+00 -0.00e+00 -0.00e+00 -0.00e+00 -1.00e+00]], and D=[[ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]]




.. GENERATED FROM PYTHON SOURCE LINES 94-97

Input Signal
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 97-107

.. code-block:: default

    amplitude = 0.25e-0
    phase = 0.0
    offset = 0.0
    frequency = 1.0 / analog_frontend_ctsd.digital_control.clock.T

    while frequency > BW:
        frequency /= 2
    input_signal = cbadc.analog_signal.Sinusoidal(amplitude, frequency, phase, offset)
    # input_signal = cbadc.analog_signal.ConstantSignal(amplitude)








.. GENERATED FROM PYTHON SOURCE LINES 108-111

Transfer Functions
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 111-176

.. code-block:: default


    # Logspace frequencies
    frequencies = np.logspace(3, 8, 1000)
    omega = 2 * np.pi * frequencies

    # Compute transfer functions for each frequency in frequencies
    transfer_function_ctsd = analog_frontend_ctsd.analog_system.transfer_function_matrix(
        omega
    )
    transfer_function_ctsd_dB = 20 * np.log10(np.abs(transfer_function_ctsd))

    transfer_function_leap_frog = (
        analog_frontend_leap_frog.analog_system.transfer_function_matrix(omega)
    )
    transfer_function_leap_frog_dB = 20 * np.log10(np.abs(transfer_function_leap_frog))

    G_omega = 20 * np.log10(np.linalg.norm(transfer_function_ctsd[:, 0, :], axis=0))

    plt.semilogx([BW, BW], [np.min(G_omega), np.max(G_omega)], '--', label="BW")

    # Add the norm ||G(omega)||_2
    plt.semilogx(
        frequencies,
        20 * np.log10(np.linalg.norm(transfer_function_leap_frog[:, 0, :], axis=0)),
        label="LF $ ||\mathbf{G}(\omega)||_2 $",
    )
    plt.semilogx(
        frequencies,
        G_omega,
        label="CTSD $ ||\mathbf{G}(\omega)||_2 $",
    )


    # Add labels and legends to figure
    plt.legend()
    plt.grid(which="both")
    plt.xlabel("$f$ [Hz]")
    plt.ylabel("dB")
    plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()


    for n in range(N):
        plt.figure()
        #     color = next(plt.gca()._get_lines.prop_cycler)["color"]
        plt.semilogx(
            frequencies,
            transfer_function_leap_frog_dB[n, 0, :],
            label="LF $G_" + f"{n+1}" + "(f)$",
            # color = color
        )
        plt.semilogx(
            frequencies,
            transfer_function_ctsd_dB[n, 0, :],
            '--',
            label="CTSD $G_" + f"{n+1}" + "(f)$",
            #     # color = color
        )
        plt.legend()
        plt.grid(which="both")
        plt.xlabel("$f$ [Hz]")
        plt.ylabel("dB")
        plt.xlim((frequencies[0], frequencies[-1]))
        plt.gcf().tight_layout()




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_001.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_002.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_002.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_003.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_004.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_005.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_005.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_006.png
         :alt: plot i simulating a delta sigma modulator
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_006.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 177-180

Simulation Setup
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 180-196

.. code-block:: default


    simulator_ctsd = cbadc.simulator.get_simulator(
        analog_frontend_ctsd.analog_system,
        analog_frontend_ctsd.digital_control,
        [input_signal],
    )
    digital_estimator_ctsd(simulator_ctsd)

    simulator_leap_frog = cbadc.simulator.get_simulator(
        analog_frontend_leap_frog.analog_system,
        analog_frontend_leap_frog.digital_control,
        [input_signal],
    )
    digital_estimator_leap_frog(simulator_leap_frog)









.. GENERATED FROM PYTHON SOURCE LINES 197-200

Simulate State Trajectories
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 200-261

.. code-block:: default


    # Simulate for 65536 control cycles.
    size = 1 << 14

    time_vector = np.arange(size)
    states = np.zeros((N, size, 2))
    control_signals = np.zeros((N, size, 2), dtype=np.double)

    # Iterate through and store states and control_signals.
    simulator_ctsd = cbadc.simulator.extended_simulation_result(simulator_ctsd)
    simulator_leap_frog = cbadc.simulator.extended_simulation_result(simulator_leap_frog)
    for index in cbadc.utilities.show_status(range(size)):
        res_ctsd = next(simulator_ctsd)
        states[:, index, 0] = res_ctsd["analog_state"]
        control_signals[:, index, 0] = res_ctsd["control_signal"]
        res_leap_frog = next(simulator_leap_frog)
        states[:, index, 1] = res_leap_frog["analog_state"]
        control_signals[:, index, 1] = res_leap_frog["control_signal"]

    xlim = 1 << 12
    # Plot all analog state evolutions.
    plt.figure()
    plt.title("Analog state vectors")
    for index in range(N):
        plt.plot(time_vector, states[index, :, 1], label=f"LF $x_{index + 1}(t)$")
        plt.plot(time_vector, states[index, :, 0], label=f"CTSD $x_{index + 1}(t)$")
    plt.grid(visible=True, which="major", color="gray", alpha=0.6, lw=1.5)
    plt.xlabel("$t/T$")
    plt.xlim((0, xlim))
    plt.legend()


    # reset figure size and plot individual results.
    plt.rcParams["figure.figsize"] = [6.40, 6.40 * 2]
    fig, ax = plt.subplots(N, 2)
    for index in range(N):
        color = next(ax[0, 0]._get_lines.prop_cycler)["color"]
        color2 = next(ax[0, 0]._get_lines.prop_cycler)["color"]
        ax[index, 0].grid(visible=True, which="major", color="gray", alpha=0.6, lw=1.5)
        ax[index, 1].grid(visible=True, which="major", color="gray", alpha=0.6, lw=1.5)
        ax[index, 0].plot(time_vector, states[index, :, 1], color=color2, label="LF")
        ax[index, 0].plot(time_vector, states[index, :, 0], color=color, label="CTSD")
        ax[index, 1].plot(
            time_vector, control_signals[0, :, 1], "--", color=color2, label="LF"
        )
        if index == (N - 1):
            ax[index, 1].plot(
                time_vector, control_signals[0, :, 0], "--", color=color, label="CTSD"
            )
        ax[index, 0].set_ylabel(f"$x_{index + 1}(t)$")
        ax[index, 1].set_ylabel(f"$s_{index + 1}(t)$")
        ax[index, 0].set_xlim((0, xlim))
        ax[index, 1].set_xlim((0, xlim))
        ax[index, 0].set_ylim((-1, 1))
        ax[index, 0].legend()
    fig.suptitle("Analog state and control contribution evolution")
    ax[-1, 0].set_xlabel("$t / T$")
    ax[-1, 1].set_xlabel("$t / T$")
    fig.tight_layout()





.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_007.png
         :alt: Analog state vectors
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_007.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_008.png
         :alt: Analog state and control contribution evolution
         :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_008.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0/16384 [00:00<?, ?it/s]      1%|          | 104/16384 [00:00<00:15, 1032.41it/s]      1%|1         | 217/16384 [00:00<00:14, 1086.81it/s]      2%|2         | 330/16384 [00:00<00:14, 1102.79it/s]      3%|2         | 441/16384 [00:00<00:20, 776.07it/s]       3%|3         | 555/16384 [00:00<00:18, 878.94it/s]      4%|4         | 670/16384 [00:00<00:16, 955.73it/s]      5%|4         | 788/16384 [00:00<00:15, 1018.79it/s]      6%|5         | 908/16384 [00:00<00:14, 1070.65it/s]      6%|6         | 1027/16384 [00:01<00:13, 1104.89it/s]      7%|7         | 1147/16384 [00:01<00:13, 1132.72it/s]      8%|7         | 1268/16384 [00:01<00:13, 1153.68it/s]      8%|8         | 1389/16384 [00:01<00:12, 1168.49it/s]      9%|9         | 1510/16384 [00:01<00:12, 1178.19it/s]     10%|9         | 1629/16384 [00:01<00:12, 1177.66it/s]     11%|#         | 1750/16384 [00:01<00:12, 1187.21it/s]     11%|#1        | 1871/16384 [00:01<00:12, 1193.40it/s]     12%|#2        | 1993/16384 [00:01<00:12, 1199.13it/s]     13%|#2        | 2115/16384 [00:01<00:11, 1203.51it/s]     14%|#3        | 2236/16384 [00:02<00:11, 1201.78it/s]     14%|#4        | 2357/16384 [00:02<00:11, 1203.77it/s]     15%|#5        | 2478/16384 [00:02<00:11, 1167.24it/s]     16%|#5        | 2599/16384 [00:02<00:11, 1178.62it/s]     17%|#6        | 2720/16384 [00:02<00:11, 1187.85it/s]     17%|#7        | 2842/16384 [00:02<00:11, 1194.51it/s]     18%|#8        | 2964/16384 [00:02<00:11, 1201.32it/s]     19%|#8        | 3085/16384 [00:02<00:11, 1201.71it/s]     20%|#9        | 3207/16384 [00:02<00:10, 1204.69it/s]     20%|##        | 3328/16384 [00:02<00:10, 1202.41it/s]     21%|##1       | 3449/16384 [00:03<00:10, 1199.60it/s]     22%|##1       | 3570/16384 [00:03<00:10, 1201.08it/s]     23%|##2       | 3691/16384 [00:03<00:10, 1201.71it/s]     23%|##3       | 3813/16384 [00:03<00:10, 1206.16it/s]     24%|##4       | 3934/16384 [00:03<00:10, 1183.53it/s]     25%|##4       | 4053/16384 [00:03<00:10, 1147.71it/s]     25%|##5       | 4169/16384 [00:03<00:10, 1143.88it/s]     26%|##6       | 4284/16384 [00:03<00:10, 1145.47it/s]     27%|##6       | 4399/16384 [00:03<00:10, 1136.88it/s]     28%|##7       | 4513/16384 [00:03<00:10, 1135.71it/s]     28%|##8       | 4629/16384 [00:04<00:10, 1140.32it/s]     29%|##8       | 4746/16384 [00:04<00:10, 1146.59it/s]     30%|##9       | 4862/16384 [00:04<00:10, 1149.54it/s]     30%|###       | 4981/16384 [00:04<00:09, 1158.85it/s]     31%|###1      | 5100/16384 [00:04<00:09, 1165.53it/s]     32%|###1      | 5217/16384 [00:04<00:09, 1137.22it/s]     33%|###2      | 5331/16384 [00:04<00:09, 1129.94it/s]     33%|###3      | 5447/16384 [00:04<00:09, 1136.41it/s]     34%|###3      | 5567/16384 [00:04<00:09, 1152.64it/s]     35%|###4      | 5683/16384 [00:04<00:09, 1141.84it/s]     35%|###5      | 5798/16384 [00:05<00:09, 1130.12it/s]     36%|###6      | 5912/16384 [00:05<00:09, 1119.17it/s]     37%|###6      | 6026/16384 [00:05<00:09, 1124.70it/s]     37%|###7      | 6139/16384 [00:05<00:09, 1125.34it/s]     38%|###8      | 6253/16384 [00:05<00:08, 1127.79it/s]     39%|###8      | 6367/16384 [00:05<00:08, 1130.87it/s]     40%|###9      | 6482/16384 [00:05<00:08, 1135.40it/s]     40%|####      | 6600/16384 [00:05<00:08, 1147.41it/s]     41%|####1     | 6720/16384 [00:05<00:08, 1161.59it/s]     42%|####1     | 6840/16384 [00:05<00:08, 1170.42it/s]     42%|####2     | 6958/16384 [00:06<00:08, 1160.75it/s]     43%|####3     | 7080/16384 [00:06<00:07, 1176.10it/s]     44%|####3     | 7201/16384 [00:06<00:07, 1185.64it/s]     45%|####4     | 7323/16384 [00:06<00:07, 1193.00it/s]     45%|####5     | 7445/16384 [00:06<00:07, 1198.73it/s]     46%|####6     | 7566/16384 [00:06<00:07, 1200.97it/s]     47%|####6     | 7688/16384 [00:06<00:07, 1204.50it/s]     48%|####7     | 7809/16384 [00:06<00:07, 1206.03it/s]     48%|####8     | 7931/16384 [00:06<00:07, 1207.40it/s]     49%|####9     | 8053/16384 [00:06<00:06, 1209.57it/s]     50%|####9     | 8174/16384 [00:07<00:06, 1206.64it/s]     51%|#####     | 8296/16384 [00:07<00:06, 1208.30it/s]     51%|#####1    | 8418/16384 [00:07<00:06, 1210.58it/s]     52%|#####2    | 8540/16384 [00:07<00:06, 1211.02it/s]     53%|#####2    | 8662/16384 [00:07<00:06, 1212.24it/s]     54%|#####3    | 8784/16384 [00:07<00:06, 1206.51it/s]     54%|#####4    | 8905/16384 [00:07<00:06, 1194.56it/s]     55%|#####5    | 9027/16384 [00:07<00:06, 1199.37it/s]     56%|#####5    | 9148/16384 [00:07<00:06, 1201.97it/s]     57%|#####6    | 9269/16384 [00:08<00:06, 1163.16it/s]     57%|#####7    | 9386/16384 [00:08<00:06, 1111.05it/s]     58%|#####7    | 9498/16384 [00:08<00:06, 1093.67it/s]     59%|#####8    | 9612/16384 [00:08<00:06, 1105.68it/s]     59%|#####9    | 9729/16384 [00:08<00:05, 1124.07it/s]     60%|######    | 9849/16384 [00:08<00:05, 1144.25it/s]     61%|######    | 9971/16384 [00:08<00:05, 1163.93it/s]     62%|######1   | 10092/16384 [00:08<00:05, 1176.63it/s]     62%|######2   | 10214/16384 [00:08<00:05, 1188.13it/s]     63%|######3   | 10335/16384 [00:08<00:05, 1193.36it/s]     64%|######3   | 10455/16384 [00:09<00:04, 1194.33it/s]     65%|######4   | 10575/16384 [00:09<00:04, 1190.13it/s]     65%|######5   | 10695/16384 [00:09<00:04, 1189.57it/s]     66%|######6   | 10814/16384 [00:09<00:04, 1160.46it/s]     67%|######6   | 10931/16384 [00:09<00:04, 1124.06it/s]     67%|######7   | 11044/16384 [00:09<00:04, 1109.88it/s]     68%|######8   | 11156/16384 [00:09<00:04, 1112.68it/s]     69%|######8   | 11276/16384 [00:09<00:04, 1135.49it/s]     70%|######9   | 11395/16384 [00:09<00:04, 1149.54it/s]     70%|#######   | 11513/16384 [00:09<00:04, 1157.25it/s]     71%|#######   | 11629/16384 [00:10<00:04, 1153.74it/s]     72%|#######1  | 11750/16384 [00:10<00:03, 1167.99it/s]     72%|#######2  | 11871/16384 [00:10<00:03, 1179.79it/s]     73%|#######3  | 11993/16384 [00:10<00:03, 1188.92it/s]     74%|#######3  | 12115/16384 [00:10<00:03, 1196.33it/s]     75%|#######4  | 12236/16384 [00:10<00:03, 1198.96it/s]     75%|#######5  | 12357/16384 [00:10<00:03, 1202.24it/s]     76%|#######6  | 12478/16384 [00:10<00:03, 1203.86it/s]     77%|#######6  | 12600/16384 [00:10<00:03, 1206.68it/s]     78%|#######7  | 12721/16384 [00:10<00:03, 1207.44it/s]     78%|#######8  | 12842/16384 [00:11<00:02, 1207.48it/s]     79%|#######9  | 12964/16384 [00:11<00:02, 1208.35it/s]     80%|#######9  | 13085/16384 [00:11<00:02, 1207.83it/s]     81%|########  | 13207/16384 [00:11<00:02, 1209.43it/s]     81%|########1 | 13329/16384 [00:11<00:02, 1210.25it/s]     82%|########2 | 13451/16384 [00:11<00:02, 1201.97it/s]     83%|########2 | 13573/16384 [00:11<00:02, 1205.03it/s]     84%|########3 | 13694/16384 [00:11<00:02, 1205.73it/s]     84%|########4 | 13815/16384 [00:11<00:02, 1185.01it/s]     85%|########5 | 13934/16384 [00:12<00:02, 1150.08it/s]     86%|########5 | 14050/16384 [00:12<00:02, 1138.16it/s]     86%|########6 | 14166/16384 [00:12<00:01, 1143.89it/s]     87%|########7 | 14281/16384 [00:12<00:01, 1125.31it/s]     88%|########7 | 14400/16384 [00:12<00:01, 1141.46it/s]     89%|########8 | 14518/16384 [00:12<00:01, 1151.76it/s]     89%|########9 | 14634/16384 [00:12<00:01, 1152.01it/s]     90%|######### | 14750/16384 [00:12<00:01, 1145.50it/s]     91%|######### | 14865/16384 [00:12<00:01, 1139.42it/s]     91%|#########1| 14979/16384 [00:12<00:01, 1110.82it/s]     92%|#########2| 15091/16384 [00:13<00:01, 1088.14it/s]     93%|#########2| 15200/16384 [00:13<00:01, 1079.92it/s]     93%|#########3| 15310/16384 [00:13<00:00, 1084.70it/s]     94%|#########4| 15420/16384 [00:13<00:00, 1088.03it/s]     95%|#########4| 15532/16384 [00:13<00:00, 1095.94it/s]     96%|#########5| 15648/16384 [00:13<00:00, 1114.39it/s]     96%|#########6| 15764/16384 [00:13<00:00, 1125.78it/s]     97%|#########6| 15877/16384 [00:13<00:00, 1105.55it/s]     98%|#########7| 15992/16384 [00:13<00:00, 1117.05it/s]     98%|#########8| 16108/16384 [00:13<00:00, 1129.57it/s]     99%|#########9| 16223/16384 [00:14<00:00, 1134.16it/s]    100%|#########9| 16337/16384 [00:14<00:00, 1121.62it/s]    100%|##########| 16384/16384 [00:14<00:00, 1154.08it/s]




.. GENERATED FROM PYTHON SOURCE LINES 262-265

Simulation
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 265-277

.. code-block:: default


    size = 1 << 14
    u_hat_ctsd = np.zeros(size)
    u_hat_leap_frog = np.zeros(size)

    for index in range(size):
        u_hat_ctsd[index] = next(digital_estimator_ctsd)
        u_hat_leap_frog[index] = next(digital_estimator_leap_frog)

    u_hat_ctsd = u_hat_ctsd[K1 + K2 :]
    u_hat_leap_frog = u_hat_leap_frog[K1 + K2 :]








.. GENERATED FROM PYTHON SOURCE LINES 278-281

Visualize Results
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 281-334

.. code-block:: default


    plt.rcParams["figure.figsize"] = [6.40 * 1.34, 6.40]

    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_ctsd[:],
        fs=1 / analog_frontend_ctsd.digital_control.clock.T,
        nperseg=u_hat_ctsd.size,
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / analog_frontend_ctsd.digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"CTSD, OSR={1/(2 * analog_frontend_ctsd.digital_control.clock.T * BW):.0f}, est_ENOB={est_ENOB:.1f} bits, est_SNR={est_SNR:.1f} dB",
    )

    f, psd = cbadc.utilities.compute_power_spectral_density(
        u_hat_leap_frog[:],
        fs=1 / analog_frontend_ctsd.digital_control.clock.T,
        nperseg=u_hat_leap_frog.size,
    )
    signal_index = cbadc.utilities.find_sinusoidal(psd, 15)
    noise_index = np.ones(psd.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[f < (BW * 1e-2)] = False
    noise_index[f > BW] = False
    fom = cbadc.utilities.snr_spectrum_computation_extended(
        psd, signal_index, noise_index, fs=1 / analog_frontend_ctsd.digital_control.clock.T
    )
    est_SNR = cbadc.fom.snr_to_dB(fom['snr'])
    est_ENOB = cbadc.fom.snr_to_enob(est_SNR)
    plt.semilogx(
        f,
        10 * np.log10(np.abs(psd)),
        label=f"LF, OSR={1/(2 * analog_frontend_ctsd.digital_control.clock.T * BW):.0f}, est_ENOB={est_ENOB:.1f} bits, est_SNR={est_SNR:.1f} dB",
    )

    plt.title("Power spectral density of input estimate")
    plt.xlabel('Hz')
    plt.ylabel('$V^2$ / Hz dB')
    plt.legend()
    plt.grid(which="both")
    plt.gcf().tight_layout()





.. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_009.png
   :alt: Power spectral density of input estimate
   :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_009.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 335-338

Time
---------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 338-349

.. code-block:: default


    t = np.arange(u_hat_ctsd.size)
    plt.plot(t, u_hat_ctsd, label="CTSD")
    plt.plot(t, u_hat_leap_frog, label="LF")
    plt.xlabel("$t / T$")
    plt.ylabel("$\hat{u}(t)$")
    plt.title("Estimated input signal")
    plt.grid()
    plt.xlim((0, 1500))
    plt.ylim((-1, 1))
    plt.tight_layout()



.. image-sg:: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_010.png
   :alt: Estimated input signal
   :srcset: /tutorials/b_high_level_simulation/images/sphx_glr_plot_i_simulating_a_delta_sigma_modulator_010.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  10.275 seconds)


.. _sphx_glr_download_tutorials_b_high_level_simulation_plot_i_simulating_a_delta_sigma_modulator.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_i_simulating_a_delta_sigma_modulator.py <plot_i_simulating_a_delta_sigma_modulator.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_i_simulating_a_delta_sigma_modulator.ipynb <plot_i_simulating_a_delta_sigma_modulator.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
