
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/b_general/plot_c_downsample.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_b_general_plot_c_downsample.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_b_general_plot_c_downsample.py:


=============
Downsampling
=============

In this tutorial we demonstrate how to configure the digital estimator
for downsampling.

.. GENERATED FROM PYTHON SOURCE LINES 9-14

.. code-block:: default
   :lineno-start: 9

    import scipy.signal
    import numpy as np
    import cbadc as cbc
    import matplotlib.pyplot as plt








.. GENERATED FROM PYTHON SOURCE LINES 15-27

Setting up the Analog System and Digital Control
------------------------------------------------

In this example, we assume that we have access to a control signal
s[k] generated by the interactions of an analog system and digital control.
Furthermore, we a chain-of-integrators converter with corresponding
analog system and digital control.

.. image:: /images/chainOfIntegratorsGeneral.svg
   :width: 500
   :align: center
   :alt: The chain of integrators ADC.

.. GENERATED FROM PYTHON SOURCE LINES 27-56

.. code-block:: default
   :lineno-start: 28


    # Setup analog system and digital control

    # We fix the number of analog states.
    N = 6
    M = N
    # Set the amplification factor.
    beta = 6250.
    rho = - 1e-2
    kappa = - 1.0
    # In this example, each nodes amplification and local feedback will be set
    # identically.
    betaVec = beta * np.ones(N)
    rhoVec = betaVec * rho
    kappaVec = kappa * beta * np.eye(N)

    # Instantiate a chain-of-integrators analog system.
    analog_system = cbc.analog_system.ChainOfIntegrators(betaVec, rhoVec, kappaVec)


    T = 1/(2 * beta)
    digital_control = cbc.digital_control.DigitalControl(T, M)


    # Summarize the analog system, digital control, and digital estimator.
    print(analog_system, "\n")
    print(digital_control)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ -62.5    0.     0.     0.     0.     0. ]
     [6250.   -62.5    0.     0.     0.     0. ]
     [   0.  6250.   -62.5    0.     0.     0. ]
     [   0.     0.  6250.   -62.5    0.     0. ]
     [   0.     0.     0.  6250.   -62.5    0. ]
     [   0.     0.     0.     0.  6250.   -62.5]],
    B =
    [[6250.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]],
    CT = 
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[-6250.    -0.    -0.    -0.    -0.    -0.]
     [   -0. -6250.    -0.    -0.    -0.    -0.]
     [   -0.    -0. -6250.    -0.    -0.    -0.]
     [   -0.    -0.    -0. -6250.    -0.    -0.]
     [   -0.    -0.    -0.    -0. -6250.    -0.]
     [   -0.    -0.    -0.    -0.    -0. -6250.]],
    Gamma_tildeT =
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]], and D=[[0.]
     [0.]
     [0.]
     [0.]
     [0.]
     [0.]] 

    The Digital Control is parameterized as:
    T = 8e-05,
    M = 6, and next update at
    t = 8e-05




.. GENERATED FROM PYTHON SOURCE LINES 57-68

Loading Control Signal from File
--------------------------------

Next, we will load an actual control signal to demonstrate the digital
estimator's capabilities. To this end, we will use the
`sinusodial_simulation.adcs` file that was produced in
:doc:`./plot_b_simulate_a_control_bounded_adc`.

The control signal file is encoded as raw binary data so to unpack it
correctly we will use the :func:`cbadc.utilities.read_byte_stream_from_file`
and :func:`cbadc.utilities.byte_stream_2_control_signal` functions.

.. GENERATED FROM PYTHON SOURCE LINES 68-91

.. code-block:: default
   :lineno-start: 69


    byte_stream = cbc.utilities.read_byte_stream_from_file(
        '../a_getting_started/sinusodial_simulation.adcs', M)
    control_signal_sequences1 = cbc.utilities.byte_stream_2_control_signal(
        byte_stream, M)

    byte_stream = cbc.utilities.read_byte_stream_from_file(
        '../a_getting_started/sinusodial_simulation.adcs', M)
    control_signal_sequences2 = cbc.utilities.byte_stream_2_control_signal(
        byte_stream, M)

    byte_stream = cbc.utilities.read_byte_stream_from_file(
        '../a_getting_started/sinusodial_simulation.adcs', M)
    control_signal_sequences3 = cbc.utilities.byte_stream_2_control_signal(
        byte_stream, M)


    byte_stream = cbc.utilities.read_byte_stream_from_file(
        '../a_getting_started/sinusodial_simulation.adcs', M)
    control_signal_sequences4 = cbc.utilities.byte_stream_2_control_signal(
        byte_stream, M)









.. GENERATED FROM PYTHON SOURCE LINES 92-95

Oversampling
-------------


.. GENERATED FROM PYTHON SOURCE LINES 95-101

.. code-block:: default
   :lineno-start: 96


    OSR = 16

    omega_3dB = 2 * np.pi / (T * OSR)









.. GENERATED FROM PYTHON SOURCE LINES 102-107

Oversampling = 1
----------------------------------------

First we initialize our default estimator without a downsampling parameter
which then defaults to 1, i.e., no downsampling.

.. GENERATED FROM PYTHON SOURCE LINES 107-127

.. code-block:: default
   :lineno-start: 108


    # Set the bandwidth of the estimator
    G_at_omega = np.linalg.norm(
        analog_system.transfer_function_matrix(np.array([omega_3dB / 2])))
    eta2 = G_at_omega**2
    # eta2 = 1.0
    print(f"eta2 = {eta2}, {10 * np.log10(eta2)} [dB]")

    # Set the filter size
    L1 = 1 << 12
    L2 = L1

    # Instantiate the digital estimator.
    digital_estimator_ref = cbc.digital_estimator.FIRFilter(
        analog_system, digital_control, eta2, L1, L2)
    digital_estimator_ref(control_signal_sequences1)

    print(digital_estimator_ref, "\n")






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    eta2 = 87574.25572661227, 49.42376455036846 [dB]
    FIR estimator is parameterized as 
    eta2 = 87574.26, 49 [dB],
    Ts = 8e-05,
    K1 = 4096,
    K2 = 4096,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    h = 
    [[[ 3.55990445e-95  1.42412246e-95 -8.07811499e-96 -6.45762292e-97
        1.32955934e-96 -9.72617900e-98]
      [ 2.76240492e-95  1.82636990e-95 -7.62786724e-96 -1.33980733e-96
        1.38622941e-96 -1.24737454e-98]
      [ 1.76589627e-95  2.19922553e-95 -6.82068247e-96 -2.05614928e-96
        1.39325750e-96  8.21379656e-98]
      ...
      [ 1.76589627e-95 -2.16391013e-95 -7.69373510e-96  1.62200519e-96
        1.54381374e-96  4.50497165e-98]
      [ 2.76240492e-95 -1.77112250e-95 -8.34780716e-96  8.61459580e-97
        1.47844576e-96  1.38257124e-97]
      [ 3.55990446e-95 -1.35292339e-95 -8.63396392e-96  1.44959196e-97
        1.36586535e-96  2.17212387e-97]]]. 





.. GENERATED FROM PYTHON SOURCE LINES 128-131

Visualize Estimator's Transfer Function
---------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 131-165

.. code-block:: default
   :lineno-start: 132


    # Logspace frequencies
    frequencies = np.logspace(-3, 0, 100)
    omega = 4 * np.pi * beta * frequencies

    # Compute NTF
    ntf = digital_estimator_ref.noise_transfer_function(omega)
    ntf_dB = 20 * np.log10(np.abs(ntf))

    # Compute STF
    stf = digital_estimator_ref.signal_transfer_function(omega)
    stf_dB = 20 * np.log10(np.abs(stf.flatten()))

    # Signal attenuation at the input signal frequency
    stf_at_omega = digital_estimator_ref.signal_transfer_function(
        np.array([omega_3dB]))[0]

    # Plot
    plt.figure()
    plt.semilogx(frequencies, stf_dB, label='$STF(\omega)$')
    for n in range(N):
        plt.semilogx(frequencies, ntf_dB[0, n, :], label=f"$|NTF_{n+1}(\omega)|$")
    plt.semilogx(frequencies, 20 * np.log10(np.linalg.norm(
        ntf[:, 0, :], axis=0)), '--', label="$ || NTF(\omega) ||_2 $")

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which='both')
    plt.title("Signal and noise transfer functions")
    plt.xlabel("$\omega / (4 \pi \\beta ) $")
    plt.ylabel("dB")
    plt.xlim((frequencies[5], frequencies[-1]))
    plt.gcf().tight_layout()




.. image:: /tutorials/b_general/images/sphx_glr_plot_c_downsample_001.png
    :alt: Signal and noise transfer functions
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /drives1/PhD/cbadc/docs/code_examples/b_general/plot_c_downsample.py:138: RuntimeWarning: divide by zero encountered in log10
      ntf_dB = 20 * np.log10(np.abs(ntf))
    /drives1/PhD/cbadc/docs/code_examples/b_general/plot_c_downsample.py:153: RuntimeWarning: divide by zero encountered in log10
      plt.semilogx(frequencies, 20 * np.log10(np.linalg.norm(




.. GENERATED FROM PYTHON SOURCE LINES 166-170

FIR Filter With Downsampling
----------------------------

Next we repeat the initialization steps above but for a downsampled estimator

.. GENERATED FROM PYTHON SOURCE LINES 170-182

.. code-block:: default
   :lineno-start: 171


    digital_estimator_dow = cbc.digital_estimator.FIRFilter(
        analog_system,
        digital_control,
        eta2,
        L1,
        L2,
        downsample=OSR)
    digital_estimator_dow(control_signal_sequences2)

    print(digital_estimator_dow, "\n")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    FIR estimator is parameterized as 
    eta2 = 87574.26, 49 [dB],
    Ts = 8e-05,
    K1 = 4096,
    K2 = 4096,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    h = 
    [[[ 3.55990445e-95  1.42412246e-95 -8.07811499e-96 -6.45762292e-97
        1.32955934e-96 -9.72617900e-98]
      [ 2.76240492e-95  1.82636990e-95 -7.62786724e-96 -1.33980733e-96
        1.38622941e-96 -1.24737454e-98]
      [ 1.76589627e-95  2.19922553e-95 -6.82068247e-96 -2.05614928e-96
        1.39325750e-96  8.21379656e-98]
      ...
      [ 1.76589627e-95 -2.16391013e-95 -7.69373510e-96  1.62200519e-96
        1.54381374e-96  4.50497165e-98]
      [ 2.76240492e-95 -1.77112250e-95 -8.34780716e-96  8.61459580e-97
        1.47844576e-96  1.38257124e-97]
      [ 3.55990446e-95 -1.35292339e-95 -8.63396392e-96  1.44959196e-97
        1.36586535e-96  2.17212387e-97]]]. 





.. GENERATED FROM PYTHON SOURCE LINES 183-186

Estimating (Filtering)
----------------------


.. GENERATED FROM PYTHON SOURCE LINES 186-196

.. code-block:: default
   :lineno-start: 187


    # Set simulation length
    size = 1 << 17
    u_hat_ref = np.zeros(size)
    u_hat_dow = np.zeros(size // OSR)
    for index in range(size):
        u_hat_ref[index] = next(digital_estimator_ref)
    for index in range(size // OSR):
        u_hat_dow[index] = next(digital_estimator_dow)








.. GENERATED FROM PYTHON SOURCE LINES 197-203

Aliasing
========

We compare the difference between the downsampled estimate and the default.
Clearly, we are suffering from aliasing as is also explained by considering
the PSD plot.

.. GENERATED FROM PYTHON SOURCE LINES 203-233

.. code-block:: default
   :lineno-start: 204


    # compensate the built in L1 delay of FIR filter.
    t = np.arange(-L1 + 1, size - L1 + 1)
    t_down = np.arange(-(L1) // OSR, (size - L1) // OSR) * OSR + 1
    plt.plot(t, u_hat_ref, label="$\hat{u}(t)$ Reference")
    plt.plot(t_down, u_hat_dow, label="$\hat{u}(t)$ Downsampled")
    plt.xlabel('$t / T$')
    plt.legend()
    plt.title("Estimated input signal")
    plt.grid(which='both')
    plt.xlim((-50, 1000))
    plt.tight_layout()

    plt.figure()
    u_hat_ref_clipped = u_hat_ref[(L1 + L2):]
    u_hat_dow_clipped = u_hat_dow[(L1 + L2) // OSR:]
    f_ref, psd_ref = cbc.utilities.compute_power_spectral_density(
        u_hat_ref_clipped, fs=1.0/T)
    f_dow, psd_dow = cbc.utilities.compute_power_spectral_density(
        u_hat_dow_clipped, fs=1.0/(T * OSR))
    plt.semilogx(f_ref, 10 * np.log10(psd_ref), label="$\hat{U}(f)$ Referefence")
    plt.semilogx(f_dow, 10 * np.log10(psd_dow), label="$\hat{U}(f)$ Downsampled")
    plt.legend()
    plt.ylim((-300, 50))
    plt.xlim((f_ref[1], f_ref[-1]))
    plt.xlabel('$f$ [Hz]')
    plt.ylabel('$ \mathrm{V}^2 \, / \, (1 \mathrm{Hz})$')
    plt.grid(which='both')
    plt.show()




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_c_downsample_002.png
          :alt: Estimated input signal
          :class: sphx-glr-multi-img

    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_c_downsample_003.png
          :alt: plot c downsample
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/scipy/signal/spectral.py:1964: UserWarning: nperseg = 16384 is greater than input length  = 7680, using nperseg = 7680
      warnings.warn('nperseg = {0:d} is greater than input length '




.. GENERATED FROM PYTHON SOURCE LINES 234-244

Prepending a Virtual Bandlimiting Filter
----------------------------------------

To battle the aliasing we extend the current estimator by placing a
bandlimiting filter in front of the system. Note that this filter is a
conceptual addition and not actually part of the physical analog system.
Regardless, this effectively suppresses aliasing since we now reconstruct
a signal shaped by both the STF of the system in addition
to a bandlimiting filter.


.. GENERATED FROM PYTHON SOURCE LINES 244-270

.. code-block:: default
   :lineno-start: 245


    wp = omega_3dB / 2.0
    ws = omega_3dB
    gpass = 0.1
    gstop = 80

    filter = cbc.analog_system.IIRDesign(wp, ws, gpass, gstop, ftype="ellip")

    # Compute transfer functions for each frequency in frequencies
    transfer_function_filter = filter.transfer_function_matrix(omega)

    plt.semilogx(
        omega/(2 * np.pi),
        20 * np.log10(np.linalg.norm(
            transfer_function_filter[:, 0, :],
            axis=0)),
        label="Cauer")
    # Add labels and legends to figure
    # plt.legend()
    plt.grid(which='both')
    plt.title("Filter Transfer Functions")
    plt.xlabel("$f$ [Hz]")
    plt.ylabel("dB")
    plt.xlim((5e1, 1e4))
    plt.gcf().tight_layout()




.. image:: /tutorials/b_general/images/sphx_glr_plot_c_downsample_004.png
    :alt: Filter Transfer Functions
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [6 3 5 2 4 1 0]
    [3 0 4 1 5 2]
    The analog system is parameterized as:
    A =
    [[ -158.38991952  2539.20594553]
     [-2539.20594553  -158.38991952]],
    B =
    [[1.30646843]
     [0.        ]],
    CT = 
    [[  -316.77983904 -26439.53111383]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[1.30646843]]
    The analog system is parameterized as:
    A =
    [[ -507.42484717  2151.20032347]
     [-2151.20032347  -507.42484717]],
    B =
    [[1.30646843]
     [0.        ]],
    CT = 
    [[-1014.84969433 -9539.6006361 ]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[1.30646843]]
    The analog system is parameterized as:
    A =
    [[ -872.67796009  1287.51180494]
     [-1287.51180494  -872.67796009]],
    B =
    [[1.30646843]
     [0.        ]],
    CT = 
    [[ -1745.35592017 -12669.31428504]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[1.30646843]]
    The analog system is parameterized as:
    A =
    [[-1049.83492627]],
    B =
    [[1.1430085]],
    CT = 
    [[1.]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.]]




.. GENERATED FROM PYTHON SOURCE LINES 271-274

New Analog System
-------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 274-305

.. code-block:: default
   :lineno-start: 275


    new_analog_system = cbc.analog_system.chain([filter, analog_system])
    print(new_analog_system)

    transfer_function_analog_system = analog_system.transfer_function_matrix(omega)

    transfer_function_new_analog_system = new_analog_system.transfer_function_matrix(
        omega)

    plt.semilogx(
        omega/(2 * np.pi),
        20 * np.log10(np.linalg.norm(
            transfer_function_analog_system[:, 0, :],
            axis=0)),
        label="Default Analog System")
    plt.semilogx(
        omega/(2 * np.pi),
        20 * np.log10(np.linalg.norm(
            transfer_function_new_analog_system[:, 0, :],
            axis=0)),
        label="Combined Analog System")

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which='both')
    plt.title("Analog System Transfer Function")
    plt.xlabel("$f$ [Hz]")
    plt.ylabel("$||\mathbf{G}(\omega)||_2$ dB")
    # plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()




.. image:: /tutorials/b_general/images/sphx_glr_plot_c_downsample_005.png
    :alt: Analog System Transfer Function
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[  -158.38991952   2539.20594553      0.              0.
           0.              0.              0.              0.
           0.              0.              0.              0.
           0.        ]
     [ -2539.20594553   -158.38991952      0.              0.
           0.              0.              0.              0.
           0.              0.              0.              0.
           0.        ]
     [  -413.86285921 -34542.41272467   -507.42484717   2151.20032347
           0.              0.              0.              0.
           0.              0.              0.              0.
           0.        ]
     [     0.              0.          -2151.20032347   -507.42484717
           0.              0.              0.              0.
           0.              0.              0.              0.
           0.        ]
     [  -540.69876022 -45128.57174752  -1325.86908763 -12463.18707325
        -872.67796009   1287.51180494      0.              0.
           0.              0.              0.              0.
           0.        ]
     [     0.              0.              0.              0.
       -1287.51180494   -872.67796009      0.              0.
           0.              0.              0.              0.
           0.        ]
     [  -618.0232788  -51582.34109438  -1515.47963687 -14245.52876018
       -1994.95665205 -14481.13391532  -1049.83492627      0.
           0.              0.              0.              0.
           0.        ]
     [     0.              0.              0.              0.
           0.              0.           6250.            -62.5
           0.              0.              0.              0.
           0.        ]
     [     0.              0.              0.              0.
           0.              0.              0.           6250.
         -62.5             0.              0.              0.
           0.        ]
     [     0.              0.              0.              0.
           0.              0.              0.              0.
        6250.            -62.5             0.              0.
           0.        ]
     [     0.              0.              0.              0.
           0.              0.              0.              0.
           0.           6250.            -62.5             0.
           0.        ]
     [     0.              0.              0.              0.
           0.              0.              0.              0.
           0.              0.           6250.            -62.5
           0.        ]
     [     0.              0.              0.              0.
           0.              0.              0.              0.
           0.              0.              0.           6250.
         -62.5       ]],
    B =
    [[1.30646843]
     [0.        ]
     [1.70685976]
     [0.        ]
     [2.22995839]
     [0.        ]
     [2.5488614 ]
     [0.        ]
     [0.        ]
     [0.        ]
     [0.        ]
     [0.        ]
     [0.        ]],
    CT = 
    [[0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[    0.     0.     0.     0.     0.     0.]
     [    0.     0.     0.     0.     0.     0.]
     [    0.     0.     0.     0.     0.     0.]
     [    0.     0.     0.     0.     0.     0.]
     [    0.     0.     0.     0.     0.     0.]
     [    0.     0.     0.     0.     0.     0.]
     [    0.     0.     0.     0.     0.     0.]
     [-6250.    -0.    -0.    -0.    -0.    -0.]
     [   -0. -6250.    -0.    -0.    -0.    -0.]
     [   -0.    -0. -6250.    -0.    -0.    -0.]
     [   -0.    -0.    -0. -6250.    -0.    -0.]
     [   -0.    -0.    -0.    -0. -6250.    -0.]
     [   -0.    -0.    -0.    -0.    -0. -6250.]],
    Gamma_tildeT =
    [[0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]], and D=[[0.]
     [0.]
     [0.]
     [0.]
     [0.]
     [0.]]




.. GENERATED FROM PYTHON SOURCE LINES 306-311

New Digital Estimator
--------------------------------------

Combining the virtual pre filter together with the default analog system
results in the following system.

.. GENERATED FROM PYTHON SOURCE LINES 311-323

.. code-block:: default
   :lineno-start: 312


    digital_estimator_dow_and_pre_filt = cbc.digital_estimator.FIRFilter(
        new_analog_system,
        digital_control,
        eta2,
        L1,
        L2,
        downsample=OSR)
    digital_estimator_dow_and_pre_filt(control_signal_sequences3)
    print(digital_estimator_dow_and_pre_filt)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    FIR estimator is parameterized as 
    eta2 = 87574.26, 49 [dB],
    Ts = 8e-05,
    K1 = 4096,
    K2 = 4096,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    h = 
    [[[ 3.22671732e-26 -8.89499869e-27 -5.18313820e-27  1.64702740e-27
        8.08357583e-28 -2.46832942e-28]
      [ 3.62156532e-26 -6.14381653e-27 -5.93153659e-27  1.20605140e-27
        9.43071238e-28 -1.86905231e-28]
      [ 3.87168333e-26 -3.06068193e-27 -6.44545999e-27  7.02415336e-28
        1.04090230e-27 -1.17479413e-28]
      ...
      [-7.47293263e-25  2.48522571e-26  1.28642368e-25  4.66541431e-27
       -2.09696790e-26 -1.74944274e-27]
      [-7.47502086e-25 -3.86626172e-26  1.24250568e-25  1.51096568e-26
       -1.95583874e-26 -3.16125633e-27]
      [-7.16560992e-25 -9.90015793e-26  1.14790067e-25  2.46670037e-26
       -1.73669678e-26 -4.40656818e-27]]].




.. GENERATED FROM PYTHON SOURCE LINES 324-329

Post filtering the FIR filter coefficients
-----------------------------------------------------------

Yet another approach is to, instead of pre-filtering, post filter
the resulting FIR filter coefficients with another lowpass FIR filter.

.. GENERATED FROM PYTHON SOURCE LINES 329-384

.. code-block:: default
   :lineno-start: 330


    numtaps = 1 << 10
    f_cutoff = 1.0 / OSR
    fir_filter = scipy.signal.firwin(numtaps, f_cutoff)

    digital_estimator_dow_and_post_filt = cbc.digital_estimator.FIRFilter(
        analog_system,
        digital_control,
        eta2,
        L1,
        L2,
        downsample=OSR)
    digital_estimator_dow_and_post_filt(control_signal_sequences4)

    # Apply the FIR post filter
    digital_estimator_dow_and_post_filt.convolve(fir_filter)

    print(digital_estimator_dow_and_post_filt, "\n")

    FIR_frequency_response = np.fft.rfft(fir_filter)
    f_FIR = np.fft.rfftfreq(numtaps, d=T)
    plt.figure()
    plt.semilogx(f_FIR, 20 * np.log10(np.abs(FIR_frequency_response)))
    plt.xlabel('$f$ [Hz]')
    plt.ylabel('$|h|$ dB')
    plt.grid(which='both')

    impulse_response_dB_dow = 20 * \
        np.log10(np.linalg.norm(
            np.array(digital_estimator_dow.h[0, :, :]), axis=1))

    impulse_response_dB_dow_and_post_filt = 20 * \
        np.log10(np.linalg.norm(
            np.array(digital_estimator_dow_and_post_filt.h[0, :, :]), axis=1))

    impulse_response_dB_FIR_filter = 20 * np.log10(np.abs(fir_filter[numtaps//2:]))

    plt.figure()
    plt.plot(np.arange(0, L1),
             impulse_response_dB_dow[L1:],
             label="Ref")
    plt.plot(np.arange(0, numtaps//2),
             impulse_response_dB_FIR_filter,
             label="Post FIR Filter")
    plt.plot(np.arange(0, L1),
             impulse_response_dB_dow_and_post_filt[L1:],
             label="Combined Post Filtered")

    plt.legend()
    plt.xlabel("filter tap k")
    plt.ylabel("$|| \mathbf{h} [k]||_2$ [dB]")
    plt.xlim((0, 1024))
    plt.ylim((-160, 0))
    plt.grid(which='both')




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_c_downsample_006.png
          :alt: plot c downsample
          :class: sphx-glr-multi-img

    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_c_downsample_007.png
          :alt: plot c downsample
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    FIR estimator is parameterized as 
    eta2 = 87574.26, 49 [dB],
    Ts = 8e-05,
    K1 = 4096,
    K2 = 4096,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    h = 
    [[[ 4.57908971e-87 -4.65114691e-87  1.82792564e-88  6.70779970e-88
       -1.47628062e-88 -6.91352512e-89]
      [ 6.94779186e-87 -4.67950396e-87 -1.70771451e-88  7.41295180e-88
       -1.07130519e-88 -8.41311065e-89]
      [ 9.29685994e-87 -4.52237142e-87 -5.56320514e-88  7.89684437e-88
       -5.78631185e-89 -9.73845893e-89]
      ...
      [ 1.15294566e-86  4.39630135e-87 -7.90611925e-88 -8.64551730e-88
       -6.70300573e-89  1.07217155e-88]
      [ 9.29685995e-87  4.70832786e-87 -3.71706891e-88 -8.17937370e-88
       -1.21559326e-88  9.13414714e-89]
      [ 6.94779186e-87  4.81847681e-87  1.92059492e-89 -7.46238158e-88
       -1.66273628e-88  7.37212989e-89]]]. 





.. GENERATED FROM PYTHON SOURCE LINES 385-390

Plotting the Estimator's Signal and Noise Transfer Function
-----------------------------------------------------------

Next we visualize the resulting STF and NTF of the new digital estimator
filters.

.. GENERATED FROM PYTHON SOURCE LINES 390-428

.. code-block:: default
   :lineno-start: 391


    # Compute NTF
    ntf_pre = digital_estimator_dow_and_pre_filt.noise_transfer_function(omega)
    ntf_post = digital_estimator_dow_and_post_filt.noise_transfer_function(
        2 * np.pi * f_FIR) * FIR_frequency_response
    ntf_dow = digital_estimator_dow.noise_transfer_function(omega)

    # Compute STF
    stf_pre = digital_estimator_dow_and_pre_filt.signal_transfer_function(omega)
    stf_dB_pre = 20 * np.log10(np.abs(stf_pre.flatten()))
    stf_post = digital_estimator_dow_and_post_filt.signal_transfer_function(
        2 * np.pi * f_FIR) * FIR_frequency_response
    stf_dB_post = 20 * np.log10(np.abs(stf_post.flatten()))
    stf_dow = digital_estimator_dow.signal_transfer_function(omega)
    stf_dow_dB = 20 * np.log10(np.abs(stf_dow.flatten()))

    # Plot
    plt.figure()
    plt.semilogx(omega/(2 * np.pi), stf_dB_pre, label='$STF(\omega)$ pre-filter')
    plt.semilogx(f_FIR, stf_dB_post, label='$STF(\omega)$ post-filter')
    plt.semilogx(omega/(2 * np.pi), stf_dow_dB,
                 label='$STF(\omega)$ ref',  color='black')
    plt.semilogx(omega/(2 * np.pi), 20 * np.log10(np.linalg.norm(
        ntf_pre[:, 0, :], axis=0)), '--', label="$ || NTF(\omega) ||_2 $ pre-filter")
    plt.semilogx(f_FIR, 20 * np.log10(np.linalg.norm(
        ntf_post[:, 0, :], axis=0)), '--', label="$ || NTF(\omega) ||_2 $ post-filter")
    plt.semilogx(omega/(2 * np.pi), 20 * np.log10(np.linalg.norm(
        ntf_dow[:, 0, :], axis=0)), '--', label="$ || NTF(\omega) ||_2 $ ref", color='black')

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which='both')
    plt.title("Signal and noise transfer functions")
    plt.xlabel("$f$ [Hz]")
    plt.ylabel("dB")
    plt.xlim((1e2, 5e3))
    plt.gcf().tight_layout()




.. image:: /tutorials/b_general/images/sphx_glr_plot_c_downsample_008.png
    :alt: Signal and noise transfer functions
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /drives1/PhD/cbadc/docs/code_examples/b_general/plot_c_downsample.py:412: RuntimeWarning: divide by zero encountered in log10
      plt.semilogx(omega/(2 * np.pi), 20 * np.log10(np.linalg.norm(
    /drives1/PhD/cbadc/docs/code_examples/b_general/plot_c_downsample.py:416: RuntimeWarning: divide by zero encountered in log10
      plt.semilogx(omega/(2 * np.pi), 20 * np.log10(np.linalg.norm(




.. GENERATED FROM PYTHON SOURCE LINES 429-436

Filtering Estimate
--------------------

Finally, we plot the resulting input estimate PSD for each estimator.
Clearly, both the pre and post filter effectively suppresses the aliasing
effect.


.. GENERATED FROM PYTHON SOURCE LINES 436-464

.. code-block:: default
   :lineno-start: 437


    u_hat_dow_and_pre_filt = np.zeros(size // OSR)
    u_hat_dow_and_post_filt = np.zeros(size // OSR)
    for index in cbc.utilities.show_status(range(size // OSR)):
        u_hat_dow_and_pre_filt[index] = next(digital_estimator_dow_and_pre_filt)
        u_hat_dow_and_post_filt[index] = next(digital_estimator_dow_and_post_filt)

    plt.figure()
    u_hat_dow_and_pre_filt_clipped = u_hat_dow_and_pre_filt[(L1 + L2) // OSR:]
    u_hat_dow_and_post_filt_clipped = u_hat_dow_and_post_filt[(L1 + L2) // OSR:]
    _, psd_dow_and_pre_filt = cbc.utilities.compute_power_spectral_density(
        u_hat_dow_and_pre_filt_clipped, fs=1.0/(T * OSR))
    _, psd_dow_and_post_filt = cbc.utilities.compute_power_spectral_density(
        u_hat_dow_and_post_filt_clipped, fs=1.0/(T * OSR))
    plt.semilogx(f_ref, 10 * np.log10(psd_ref), label="$\hat{U}(f)$ Referefence")
    plt.semilogx(f_dow, 10 * np.log10(psd_dow), label="$\hat{U}(f)$ Downsampled")
    plt.semilogx(f_dow, 10 * np.log10(psd_dow_and_pre_filt),
                 label="$\hat{U}(f)$ Downsampled & Pre Filtered")
    plt.semilogx(f_dow, 10 * np.log10(psd_dow_and_post_filt),
                 label="$\hat{U}(f)$ Downsampled & Post Filtered")
    plt.legend()
    plt.ylim((-300, 50))
    plt.xlim((f_ref[1], f_ref[-1]))
    plt.xlabel('$f$ [Hz]')
    plt.ylabel('$ \mathrm{V}^2 \, / \, (1 \mathrm{Hz})$')
    plt.grid(which='both')
    plt.show()




.. image:: /tutorials/b_general/images/sphx_glr_plot_c_downsample_009.png
    :alt: plot c downsample
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0/8192 [00:00<?, ?it/s]      1%|1         | 112/8192 [00:00<00:07, 1113.18it/s]      3%|2         | 224/8192 [00:00<00:08, 971.98it/s]       4%|3         | 323/8192 [00:00<00:11, 683.12it/s]      5%|5         | 441/8192 [00:00<00:09, 828.53it/s]      7%|7         | 581/8192 [00:00<00:07, 996.57it/s]      9%|8         | 732/8192 [00:00<00:06, 1148.64it/s]     11%|#         | 867/8192 [00:00<00:06, 1208.21it/s]     12%|#2        | 1003/8192 [00:00<00:05, 1251.68it/s]     14%|#4        | 1156/8192 [00:01<00:05, 1333.60it/s]     16%|#5        | 1309/8192 [00:01<00:04, 1391.13it/s]     18%|#7        | 1451/8192 [00:01<00:05, 1224.73it/s]     19%|#9        | 1579/8192 [00:01<00:06, 1045.88it/s]     21%|##        | 1692/8192 [00:01<00:07, 919.74it/s]      22%|##2       | 1822/8192 [00:01<00:06, 1006.86it/s]     24%|##4       | 1968/8192 [00:01<00:05, 1118.29it/s]     26%|##5       | 2119/8192 [00:01<00:04, 1219.79it/s]     28%|##7       | 2264/8192 [00:02<00:04, 1280.42it/s]     29%|##9       | 2398/8192 [00:02<00:04, 1286.40it/s]     31%|###1      | 2550/8192 [00:02<00:04, 1351.67it/s]     33%|###2      | 2701/8192 [00:02<00:03, 1396.58it/s]     35%|###4      | 2855/8192 [00:02<00:03, 1436.18it/s]     37%|###6      | 3008/8192 [00:02<00:03, 1463.59it/s]     39%|###8      | 3156/8192 [00:02<00:04, 1148.15it/s]     40%|####      | 3283/8192 [00:02<00:04, 1112.00it/s]     42%|####1     | 3435/8192 [00:02<00:03, 1214.27it/s]     44%|####3     | 3566/8192 [00:03<00:03, 1237.90it/s]     45%|####5     | 3708/8192 [00:03<00:03, 1286.44it/s]     47%|####6     | 3849/8192 [00:03<00:03, 1319.64it/s]     49%|####8     | 3994/8192 [00:03<00:03, 1352.35it/s]     51%|#####     | 4140/8192 [00:03<00:02, 1381.55it/s]     52%|#####2    | 4287/8192 [00:03<00:02, 1407.29it/s]     54%|#####4    | 4430/8192 [00:03<00:02, 1343.64it/s]     56%|#####5    | 4583/8192 [00:03<00:02, 1395.13it/s]     58%|#####7    | 4734/8192 [00:03<00:02, 1426.86it/s]     60%|#####9    | 4880/8192 [00:03<00:02, 1436.48it/s]     61%|######1   | 5025/8192 [00:04<00:02, 1357.78it/s]     63%|######3   | 5177/8192 [00:04<00:02, 1403.46it/s]     65%|######5   | 5330/8192 [00:04<00:01, 1437.53it/s]     67%|######6   | 5483/8192 [00:04<00:01, 1463.92it/s]     69%|######8   | 5636/8192 [00:04<00:01, 1481.27it/s]     71%|#######   | 5785/8192 [00:04<00:01, 1479.85it/s]     72%|#######2  | 5934/8192 [00:04<00:01, 1374.40it/s]     74%|#######4  | 6087/8192 [00:04<00:01, 1417.25it/s]     76%|#######6  | 6231/8192 [00:04<00:01, 1224.62it/s]     78%|#######7  | 6359/8192 [00:05<00:01, 1182.20it/s]     79%|#######9  | 6481/8192 [00:05<00:01, 1173.80it/s]     81%|########  | 6613/8192 [00:05<00:01, 1212.94it/s]     83%|########2 | 6764/8192 [00:05<00:01, 1294.61it/s]     84%|########4 | 6897/8192 [00:05<00:00, 1303.56it/s]     86%|########5 | 7029/8192 [00:05<00:00, 1212.83it/s]     88%|########7 | 7181/8192 [00:05<00:00, 1296.77it/s]     90%|########9 | 7334/8192 [00:05<00:00, 1362.52it/s]     91%|#########1| 7487/8192 [00:05<00:00, 1410.08it/s]     93%|#########3| 7639/8192 [00:06<00:00, 1441.75it/s]     95%|#########5| 7791/8192 [00:06<00:00, 1462.65it/s]     97%|#########6| 7939/8192 [00:06<00:00, 1312.53it/s]     99%|#########8| 8092/8192 [00:06<00:00, 1369.76it/s]    100%|##########| 8192/8192 [00:06<00:00, 1275.08it/s]
    /home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/scipy/signal/spectral.py:1964: UserWarning: nperseg = 16384 is greater than input length  = 7680, using nperseg = 7680
      warnings.warn('nperseg = {0:d} is greater than input length '




.. GENERATED FROM PYTHON SOURCE LINES 465-472

In Time Domain
---------------

The corresponding estimate samples are plotted. As is evident from the plots
the different filter realization all result in different filter lags.
Naturally, the filter lag follows from the choice of K1, K2, and the pre or
post filter design and is therefore a known parameter.

.. GENERATED FROM PYTHON SOURCE LINES 472-490

.. code-block:: default
   :lineno-start: 473


    t = np.arange(size)
    t_down = np.arange(size // OSR) * OSR
    plt.plot(t, u_hat_ref, label="$\hat{u}(t)$ Reference")
    plt.plot(t_down, u_hat_dow, label="$\hat{u}(t)$ Downsampled")
    plt.plot(t_down, u_hat_dow_and_pre_filt,
             label="$\hat{u}(t)$ Downsampled and Pre Filtered")
    plt.plot(t_down, u_hat_dow_and_post_filt,
             label="$\hat{u}(t)$ Downsampled and Post Filtered")
    plt.xlabel('$t / T$')
    plt.legend()
    plt.title("Estimated input signal")
    plt.grid(which='both')
    offset = (L1 + L2) * 4
    plt.xlim((offset, offset + 1000))
    plt.ylim((-0.6, 0.6))
    plt.tight_layout()




.. image:: /tutorials/b_general/images/sphx_glr_plot_c_downsample_010.png
    :alt: Estimated input signal
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 491-498

Compare Filter Coefficients
---------------------------

Futhermore, the filter coefficient's magnitude decay varies for the different
implementations. Keep in mind that the for this example the pre and post
filter are parametrized such that the formed slightly outperforms the latter
in terms of precision (see the PSD plot above).

.. GENERATED FROM PYTHON SOURCE LINES 498-520

.. code-block:: default
   :lineno-start: 499


    impulse_response_dB_dow_and_pre_filt = 20 * \
        np.log10(np.linalg.norm(
            np.array(digital_estimator_dow_and_pre_filt.h[0, :, :]), axis=1))

    plt.plot(np.arange(0, L1),
             impulse_response_dB_dow[L1:],
             label="Ref")

    plt.plot(np.arange(0, L1),
             impulse_response_dB_dow_and_pre_filt[L1:],
             label="Pre Filtered")
    plt.plot(np.arange(0, L1),
             impulse_response_dB_dow_and_post_filt[L1:],
             label="Post Filtered")
    plt.legend()
    plt.xlabel("filter tap k")
    plt.ylabel("$|| \mathbf{h} [k]||_2$ [dB]")
    plt.xlim((0, 1024))
    plt.ylim((-160, -20))
    plt.grid(which='both')




.. image:: /tutorials/b_general/images/sphx_glr_plot_c_downsample_011.png
    :alt: plot c downsample
    :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  23.417 seconds)


.. _sphx_glr_download_tutorials_b_general_plot_c_downsample.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_c_downsample.py <plot_c_downsample.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_c_downsample.ipynb <plot_c_downsample.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
