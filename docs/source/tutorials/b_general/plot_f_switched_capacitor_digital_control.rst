
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/b_general/plot_f_switched_capacitor_digital_control.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_b_general_plot_f_switched_capacitor_digital_control.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_b_general_plot_f_switched_capacitor_digital_control.py:


Switched-Capacitor Digital Control
==================================

In this tutorial we show how to use switched-capacitor digital control
in combination with a continuous-time system.

.. GENERATED FROM PYTHON SOURCE LINES 8-15

.. code-block:: default
   :lineno-start: 8

    import cbadc
    import numpy as np
    import matplotlib.pyplot as plt

    from cbadc import analog_system
    from cbadc import simulator








.. GENERATED FROM PYTHON SOURCE LINES 16-50

Integration Node
----------------

Initially we consider a integration node as shown in the figure below.

.. image:: /images/RC-amp.svg
   :width: 500
   :align: center
   :alt: The RC integrator with switched-capacitor digital control.

Which is goverened by the differetial equations

:math:`\dot{v}_{x_{\ell}}(t) = \frac{1}{C_{x_{\ell}}} \left( \frac{v_{\Gamma_{\ell}}(t) - v_{s_\ell}(t)}{R_{s}} - \frac{1}{R_{\beta_\ell}}  v_{x_{\ell - 1}}(t) \right)`

:math:`\dot{v}_{\Gamma_{\ell}}(t) = \frac{1}{2R_{s} C_{\Gamma_{\ell}}} \left( v_{s_\ell}(t) - v_{\Gamma_{\ell}}(t) \right)`

during phase :math:`\phi_1` and

:math:`\dot{v}_{x_{\ell}}(t)  =  - \frac{1}{R_{\beta_\ell} C_{x_{\ell}}} v_{x_{\ell - 1}}(t)`

:math:`\dot{v}_{\Gamma_{\ell}}(t) = - \frac{1}{2 R_{s} C_{\Gamma_{\ell}}}  v_{\Gamma_{\ell}}(t)`

during phase :math:`\bar{\phi}_1` where a full control phase :math:`T = T_{\phi_1} + T_{\bar{\phi}_1}`.

To simulate this control-bounded converter we need to specify the whole system which for this
tutorial will be a chain-of-integrators system as shown below.

.. image:: /images/chainOfIntegratorsGeneral.svg
   :width: 1500
   :align: center
   :alt: The chain-of-integrators ADC.

where the digital controls are implemented as above.
Thus the system equations can be written as

.. GENERATED FROM PYTHON SOURCE LINES 50-67

.. code-block:: default
   :lineno-start: 51


    N = 4
    M = N

    C_x = 1e-9
    C_Gamma = C_x / 2
    R_s = 100.0
    R_beta = 16e4

    beta = 1 / (R_beta * C_x)
    T = 1 / (2 * beta)

    A = beta * np.eye(N, k=-1)
    B = np.zeros(N)
    B[0] = beta
    CT = np.eye(N)








.. GENERATED FROM PYTHON SOURCE LINES 68-86

Simplifying the Differential Equation
-------------------------------------

Due to the virtual ground of the op-amp integrator we can treat the
second differential equation (the one involving :math:`v_{\Gamma_\ell}(t)`)
seperately. Specifically, if we assume the
capacitor :math:`C_{\Gamma}` empties completely during :math:`\bar{\phi}_1`,
and that :math:`v_{s_\ell} = \{\pm 1\}` for all :math:`t`, the digital
control's effect on the analog system can be written as

:math:`v_{\Gamma_\ell}(t) - v_{s_\ell}(t) = v_{s_\ell}(t) \cdot e^{-t/\tau}`

where :math:`\tau=R_s C_{\Gamma_\ell}`.

This can be modeled by instantiating the digital control
:class:`cbadc.digital_control.DigitalControl`
using the impulse response :func:`cbadc.digital_control.RC_impulse_response`
as

.. GENERATED FROM PYTHON SOURCE LINES 86-100

.. code-block:: default
   :lineno-start: 87


    impulse_response = lambda t: cbadc.digital_control.RC_impulse_response(t, R_s * C_Gamma)
    digital_control_sc = cbadc.digital_control.DigitalControl(
        T, M, impulse_response=impulse_response
    )

    Gamma = 1 / (R_s * C_x) * np.eye(M)
    Gamma_tildeT = -np.eye(M)

    analog_system_sc = cbadc.analog_system.AnalogSystem(A, B, CT, Gamma, Gamma_tildeT)

    print(digital_control_sc)
    print(analog_system_sc)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The Digital Control is parameterized as:
    T = 8e-05,
    M = 4,
    clock_jitter = False
    and next update at
    t = 8e-05
    The analog system is parameterized as:
    A =
    [[   0.    0.    0.    0.]
     [6250.    0.    0.    0.]
     [   0. 6250.    0.    0.]
     [   0.    0. 6250.    0.]],
    B =
    [[6250.]
     [   0.]
     [   0.]
     [   0.]],
    CT = 
    [[1. 0. 0. 0.]
     [0. 1. 0. 0.]
     [0. 0. 1. 0.]
     [0. 0. 0. 1.]],
    Gamma =
    [[10000000.        0.        0.        0.]
     [       0. 10000000.        0.        0.]
     [       0.        0. 10000000.        0.]
     [       0.        0.        0. 10000000.]],
    Gamma_tildeT =
    [[-1. -0. -0. -0.]
     [-0. -1. -0. -0.]
     [-0. -0. -1. -0.]
     [-0. -0. -0. -1.]], and D=[[0.]
     [0.]
     [0.]
     [0.]]




.. GENERATED FROM PYTHON SOURCE LINES 101-104

Visualizing the State Trajectories
----------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 104-146

.. code-block:: default
   :lineno-start: 105


    analog_signal = cbadc.analog_signal.Sinusodial(1.0, 1 / T / 32)
    Ts = T / 1000.0
    size = 1 << 14

    simulator_sc = cbadc.simulator.extended_simulation_result(
        cbadc.simulator.StateSpaceSimulator(
            analog_system_sc, digital_control_sc, [analog_signal], Ts=Ts
        )
    )


    analog_system_ref = cbadc.analog_system.AnalogSystem(
        A, B, CT, np.eye(N) * beta, Gamma_tildeT
    )
    digital_control_ref = cbadc.digital_control.DigitalControl(T, M)
    simulator_ref = cbadc.simulator.extended_simulation_result(
        cbadc.simulator.StateSpaceSimulator(
            analog_system_ref, digital_control_ref, [analog_signal], Ts=Ts,
        )
    )

    states = np.zeros((size, N))
    states_ref = np.zeros_like(states)
    t = Ts * np.arange(size)

    # Simulations
    for time_step in cbadc.utilities.show_status(range(size)):
        states[time_step, :] = next(simulator_sc)["analog_state"]
        states_ref[time_step, :] = next(simulator_ref)["analog_state"]

    # Plot state trajectories
    for index in range(N):
        plt.figure()
        plt.title("Analog state trajectories for " + f"$x_{index + 1}(t)$")
        plt.plot(t / T, states[:, index], label=f"SC")
        plt.plot(t / T, states_ref[:, index], label="ref")
        plt.grid(b=True, which="major", color="gray", alpha=0.6, lw=1.5)
        plt.xlabel("$t/T$")
        plt.legend()





.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_f_switched_capacitor_digital_control_001.png
          :alt: Analog state trajectories for $x_1(t)$
          :class: sphx-glr-multi-img

    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_f_switched_capacitor_digital_control_002.png
          :alt: Analog state trajectories for $x_2(t)$
          :class: sphx-glr-multi-img

    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_f_switched_capacitor_digital_control_003.png
          :alt: Analog state trajectories for $x_3(t)$
          :class: sphx-glr-multi-img

    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_f_switched_capacitor_digital_control_004.png
          :alt: Analog state trajectories for $x_4(t)$
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Pre-computations turned off as Ts != T
    Pre-computations turned off as Ts != T
      0%|          | 0/16384 [00:00<?, ?it/s]      1%|          | 138/16384 [00:00<00:11, 1373.59it/s]      2%|1         | 287/16384 [00:00<00:11, 1438.58it/s]      3%|2         | 459/16384 [00:00<00:10, 1562.22it/s]      4%|3         | 618/16384 [00:00<00:10, 1570.75it/s]      5%|4         | 776/16384 [00:00<00:12, 1266.41it/s]      6%|5         | 911/16384 [00:00<00:12, 1192.78it/s]      6%|6         | 1036/16384 [00:00<00:14, 1052.61it/s]      7%|7         | 1162/16384 [00:00<00:13, 1103.23it/s]      8%|7         | 1278/16384 [00:01<00:13, 1103.70it/s]      8%|8         | 1392/16384 [00:01<00:13, 1097.30it/s]      9%|9         | 1518/16384 [00:01<00:13, 1142.53it/s]     10%|#         | 1681/16384 [00:01<00:11, 1279.86it/s]     11%|#1        | 1855/16384 [00:01<00:10, 1412.12it/s]     12%|#2        | 2000/16384 [00:01<00:10, 1333.75it/s]     13%|#3        | 2136/16384 [00:01<00:11, 1278.38it/s]     14%|#3        | 2281/16384 [00:01<00:10, 1324.19it/s]     15%|#4        | 2456/16384 [00:01<00:09, 1442.54it/s]     16%|#6        | 2631/16384 [00:02<00:08, 1530.09it/s]     17%|#7        | 2808/16384 [00:02<00:08, 1599.83it/s]     18%|#8        | 3000/16384 [00:02<00:08, 1587.90it/s]     19%|#9        | 3160/16384 [00:02<00:08, 1554.78it/s]     21%|##        | 3368/16384 [00:02<00:07, 1702.76it/s]     22%|##1       | 3577/16384 [00:02<00:07, 1811.48it/s]     23%|##2       | 3760/16384 [00:02<00:06, 1815.19it/s]     24%|##4       | 3943/16384 [00:02<00:07, 1755.07it/s]     25%|##5       | 4120/16384 [00:02<00:08, 1484.16it/s]     26%|##6       | 4327/16384 [00:03<00:07, 1634.30it/s]     28%|##7       | 4537/16384 [00:03<00:06, 1757.59it/s]     29%|##8       | 4745/16384 [00:03<00:06, 1844.99it/s]     30%|###       | 4941/16384 [00:03<00:06, 1875.32it/s]     31%|###1      | 5133/16384 [00:03<00:07, 1495.03it/s]     32%|###2      | 5298/16384 [00:03<00:07, 1489.20it/s]     33%|###3      | 5458/16384 [00:03<00:07, 1443.24it/s]     34%|###4      | 5610/16384 [00:03<00:07, 1402.53it/s]     35%|###5      | 5756/16384 [00:03<00:07, 1415.37it/s]     36%|###6      | 5924/16384 [00:04<00:07, 1485.04it/s]     37%|###7      | 6076/16384 [00:04<00:08, 1275.35it/s]     38%|###8      | 6234/16384 [00:04<00:07, 1351.09it/s]     39%|###9      | 6413/16384 [00:04<00:06, 1467.16it/s]     40%|####      | 6591/16384 [00:04<00:06, 1553.09it/s]     41%|####1     | 6752/16384 [00:04<00:06, 1547.89it/s]     42%|####2     | 6929/16384 [00:04<00:05, 1608.89it/s]     43%|####3     | 7093/16384 [00:04<00:06, 1367.66it/s]     44%|####4     | 7268/16384 [00:04<00:06, 1464.82it/s]     45%|####5     | 7447/16384 [00:05<00:05, 1551.58it/s]     46%|####6     | 7609/16384 [00:05<00:05, 1506.01it/s]     47%|####7     | 7780/16384 [00:05<00:05, 1560.73it/s]     49%|####8     | 7948/16384 [00:05<00:05, 1593.29it/s]     49%|####9     | 8110/16384 [00:05<00:05, 1389.19it/s]     51%|#####     | 8287/16384 [00:05<00:05, 1487.98it/s]     52%|#####1    | 8458/16384 [00:05<00:05, 1547.37it/s]     53%|#####2    | 8635/16384 [00:05<00:04, 1609.17it/s]     54%|#####3    | 8802/16384 [00:05<00:04, 1624.30it/s]     55%|#####4    | 8976/16384 [00:06<00:04, 1656.70it/s]     56%|#####5    | 9144/16384 [00:06<00:04, 1490.55it/s]     57%|#####7    | 9353/16384 [00:06<00:04, 1652.12it/s]     58%|#####8    | 9523/16384 [00:06<00:04, 1610.30it/s]     59%|#####9    | 9724/16384 [00:06<00:03, 1720.09it/s]     61%|######    | 9933/16384 [00:06<00:03, 1823.26it/s]     62%|######1   | 10119/16384 [00:06<00:03, 1698.12it/s]     63%|######3   | 10331/16384 [00:06<00:03, 1814.14it/s]     64%|######4   | 10542/16384 [00:06<00:03, 1895.52it/s]     66%|######5   | 10753/16384 [00:07<00:02, 1955.45it/s]     67%|######6   | 10962/16384 [00:07<00:02, 1993.16it/s]     68%|######8   | 11163/16384 [00:07<00:02, 1802.40it/s]     69%|######9   | 11373/16384 [00:07<00:02, 1883.69it/s]     71%|#######   | 11583/16384 [00:07<00:02, 1944.57it/s]     72%|#######1  | 11795/16384 [00:07<00:02, 1993.59it/s]     73%|#######3  | 12001/16384 [00:07<00:02, 1939.78it/s]     74%|#######4  | 12197/16384 [00:07<00:02, 1870.64it/s]     76%|#######5  | 12405/16384 [00:07<00:02, 1927.59it/s]     77%|#######7  | 12616/16384 [00:08<00:01, 1977.86it/s]     78%|#######8  | 12816/16384 [00:08<00:01, 1975.97it/s]     79%|#######9  | 13015/16384 [00:08<00:01, 1781.04it/s]     81%|########  | 13224/16384 [00:08<00:01, 1864.24it/s]     82%|########1 | 13428/16384 [00:08<00:01, 1911.74it/s]     83%|########3 | 13623/16384 [00:08<00:01, 1861.56it/s]     84%|########4 | 13830/16384 [00:08<00:01, 1918.35it/s]     86%|########5 | 14024/16384 [00:08<00:01, 1755.38it/s]     87%|########6 | 14231/16384 [00:08<00:01, 1841.10it/s]     88%|########8 | 14439/16384 [00:08<00:01, 1906.58it/s]     89%|########9 | 14645/16384 [00:09<00:00, 1949.06it/s]     91%|######### | 14852/16384 [00:09<00:00, 1982.95it/s]     92%|#########1| 15052/16384 [00:09<00:00, 1788.20it/s]     93%|#########3| 15259/16384 [00:09<00:00, 1864.06it/s]     94%|#########4| 15466/16384 [00:09<00:00, 1921.02it/s]     96%|#########5| 15672/16384 [00:09<00:00, 1959.94it/s]     97%|#########6| 15878/16384 [00:09<00:00, 1988.19it/s]     98%|#########8| 16079/16384 [00:09<00:00, 1831.87it/s]     99%|#########9| 16287/16384 [00:09<00:00, 1900.67it/s]    100%|##########| 16384/16384 [00:10<00:00, 1637.08it/s]




.. GENERATED FROM PYTHON SOURCE LINES 147-150

Filter Coefficients
----------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 150-249

.. code-block:: default
   :lineno-start: 151


    eta2 = 1e4
    K1 = 1 << 8
    K2 = K1


    # prepending an anti-aliasing filter
    omega_3dB = 2 * np.pi * 1e3
    wp = omega_3dB / 2.0
    ws = omega_3dB
    gpass = 1.0
    gstop = 60
    filter = cbadc.analog_system.IIRDesign(wp, ws, gpass, gstop, ftype="ellip")


    digital_estimator_sc = cbadc.digital_estimator.FIRFilter(
        cbadc.analog_system.chain([filter, analog_system_sc]),
        digital_control_sc,
        eta2,
        K1,
        K2,
    )

    digital_estimator_ref = cbadc.digital_estimator.FIRFilter(
        cbadc.analog_system.chain([filter, analog_system_ref]),
        digital_control_ref,
        eta2,
        K1,
        K2,
    )

    plt.figure()
    plt.semilogy(
        np.arange(-K1, K2),
        np.linalg.norm(np.array(digital_estimator_sc.h[0, :, :]), axis=1)[:],
        label="Switched Capacitor Filter",
    )
    plt.semilogy(
        np.arange(-K1, K2),
        np.linalg.norm(np.array(digital_estimator_ref.h[0, :, :]), axis=1)[:],
        label="Ref Filter",
    )

    plt.legend()
    plt.xlabel("filter tap k")
    plt.ylabel("$|| \mathbf{h} [k]||_2$")
    plt.xlim((-K1, K2))
    # plt.ylim((1e-16, 1))
    plt.grid(which="both")

    # Logspace frequencies
    frequencies = np.logspace(-3, 0, 100)
    omega = 4 * np.pi * beta * frequencies

    plt.figure()
    plt.semilogx(
        omega / (2 * np.pi),
        20
        * np.log10(np.abs(digital_estimator_sc.signal_transfer_function(omega))).flatten(),
        label="$STF(\omega)$ SC",
    )
    plt.semilogx(
        omega / (2 * np.pi),
        20
        * np.log10(np.abs(digital_estimator_ref.signal_transfer_function(omega))).flatten(),
        label="$STF(\omega)$ ref",
    )
    plt.semilogx(
        omega / (2 * np.pi),
        20
        * np.log10(
            np.linalg.norm(
                digital_estimator_sc.noise_transfer_function(omega)[:, 0, :], axis=0
            )
        ),
        "--",
        label="$ || NTF(\omega) ||_2 $ SC",
    )
    plt.semilogx(
        omega / (2 * np.pi),
        20
        * np.log10(
            np.linalg.norm(
                digital_estimator_ref.noise_transfer_function(omega)[:, 0, :], axis=0
            )
        ),
        "--",
        label="$ || NTF(\omega) ||_2 $ ref",
    )
    # Add labels and legends to figure
    plt.legend()
    plt.grid(which="both")
    plt.title("Signal and noise transfer functions")
    plt.xlabel("$f$ [Hz]")
    plt.ylabel("dB")
    plt.xlim((1e2, 5e3))
    plt.gcf().tight_layout()





.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_f_switched_capacitor_digital_control_005.png
          :alt: plot f switched capacitor digital control
          :class: sphx-glr-multi-img

    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_f_switched_capacitor_digital_control_006.png
          :alt: Signal and noise transfer functions
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/scipy/integrate/_ivp/rk.py:502: RuntimeWarning: invalid value encountered in double_scalars
      return np.abs(h) * err5_norm_2 / np.sqrt(denom * len(scale))




.. GENERATED FROM PYTHON SOURCE LINES 250-254

Mismatch Sensitivity to Switch Resistance
-----------------------------------------



.. GENERATED FROM PYTHON SOURCE LINES 254-330

.. code-block:: default
   :lineno-start: 255


    # mismatch_in_percent = np.arange(2) * 100

    # size = 1 << 14
    # t = np.arange(size) * T

    # simulators = []
    # digital_estimators = []
    # estimates = []

    # for mismatch in mismatch_in_percent:
    #     digital_estimators.append(
    #         cbadc.digital_estimator.FIRFilter(
    #             cbadc.analog_system.chain([filter, analog_system]),
    #             cbadc.digital_control.DigitalControl(
    #                 T,
    #                 M,
    #                 impulse_response=lambda t: cbadc.digital_control.RC_impulse_response(
    #                     t, R_s * C_Gamma
    #                 ),
    #             ),
    #             eta2,
    #             K1,
    #             K2,
    #         )
    #     )
    #     digital_estimators[-1](
    #         cbadc.simulator.StateSpaceSimulator(
    #             cbadc.analog_system.AnalogSystem(
    #                 A,
    #                 B,
    #                 CT,
    #                 1 / ((1 + mismatch / 100) * R_s * C_x) * np.eye(M),
    #                 Gamma_tildeT,
    #             ),
    #             cbadc.digital_control.DigitalControl(
    #                 T,
    #                 M,
    #                 impulse_response=lambda t: cbadc.digital_control.RC_impulse_response(
    #                     t, (1 + mismatch / 100) * R_s * C_Gamma
    #                 ),
    #             ),
    #             [analog_signal],
    #             pre_compute_control_interactions=False,
    #         )
    #     )
    #     u_hat = np.zeros(size)
    #     for index in range(size):
    #         u_hat[index] = next(digital_estimators[-1])
    #     estimates.append(u_hat)

    # # Plot estimates in time domain
    # plt.figure()
    # plt.title("Estimates")
    # for index, mismatch in enumerate(mismatch_in_percent):
    #     plt.plot(t / T, estimates[index], label=f"Mismatch R_s {mismatch}%")
    # plt.grid(b=True, which="major", color="gray", alpha=0.6, lw=1.5)
    # plt.xlabel("$t/T$")
    # plt.xlim((K1 + K2, K1 + K2 + 100))
    # plt.legend()


    # # Plot estimates PSD
    # plt.figure()
    # plt.title("Estimates PSD")
    # for index, mismatch in enumerate(mismatch_in_percent):
    #     f, psd = cbadc.utilities.compute_power_spectral_density(
    #         estimates[index][K1 + K2 :], fs=1.0 / T
    #     )
    #     plt.semilogx(f, 10 * np.log10(psd), label=f"Mismatch R_s {mismatch}%")
    # plt.grid(b=True, which="major", color="gray", alpha=0.6, lw=1.5)
    # plt.xlabel("f [Hz]")
    # plt.ylabel("V^2/Hz [dB]")
    # plt.legend()









.. GENERATED FROM PYTHON SOURCE LINES 331-334

Clock Jitter Sensitivity
------------------------


.. GENERATED FROM PYTHON SOURCE LINES 334-427

.. code-block:: default
   :lineno-start: 335


    jitter_std = np.arange(4) * T * 0.1
    clock_jitter = [lambda: np.random.randn() * std for std in jitter_std]

    size = 1 << 12
    t = np.arange(size) * T

    estimates = []
    estimates_ref = []

    for jitter in clock_jitter:
        digital_estimator_sc = cbadc.digital_estimator.FIRFilter(
            cbadc.analog_system.chain([filter, analog_system_sc]),
            digital_control_sc,
            eta2,
            K1,
            K2,
        )

        digital_estimator_sc(
            cbadc.simulator.StateSpaceSimulator(
                analog_system_sc,
                cbadc.digital_control.DigitalControl(
                    T,
                    M,
                    impulse_response=lambda t: cbadc.digital_control.RC_impulse_response(
                        t, R_s * C_Gamma
                    ),
                    clock_jitter=jitter,
                ),
                [analog_signal],
            )
        )

        digital_estimator_ref = cbadc.digital_estimator.FIRFilter(
            cbadc.analog_system.chain([filter, analog_system_ref]),
            cbadc.digital_control.DigitalControl(T, M),
            eta2,
            K1,
            K2,
        )

        digital_estimator_ref(
            cbadc.simulator.StateSpaceSimulator(
                analog_system_ref,
                cbadc.digital_control.DigitalControl(T, M, clock_jitter=jitter),
                [analog_signal],
            )
        )

        u_hat = np.zeros(size)
        u_hat_ref = np.zeros_like(u_hat)
        for index in range(size):
            u_hat[index] = next(digital_estimator_sc)
            u_hat_ref[index] = next(digital_estimator_ref)
        estimates.append(u_hat)
        estimates_ref.append(u_hat_ref)

    # Plot estimates in time domain
    plt.figure()
    plt.title("Estimates")
    for index, jitter in enumerate(clock_jitter):
        plt.plot(
            t / T, estimates[index], label=f"Std / T = {np.round(jitter_std[index] / T, 2)}"
        )
    plt.grid(b=True, which="major", color="gray", alpha=0.6, lw=1.5)
    plt.xlabel("$t/T$")
    plt.xlim((K1 + K2, K1 + K2 + 100))
    plt.legend()


    # Plot estimates PSD
    plt.figure()
    plt.title("Estimates PSD")
    for index, jitter in enumerate(clock_jitter):
        f, psd = cbadc.utilities.compute_power_spectral_density(
            estimates[index][K1 + K2 :], fs=1.0 / T
        )
        f_ref, psd_ref = cbadc.utilities.compute_power_spectral_density(
            estimates_ref[index][K1 + K2 :], fs=1.0 / T
        )
        plt.semilogx(
            f, 10 * np.log10(psd), label=f"Std / T = {np.round(jitter_std[index] / T, 2)}"
        )
        plt.semilogx(
            f_ref,
            10 * np.log10(psd_ref),
            label=f"Ref, Std / T = {np.round(jitter_std[index] / T, 2)}",
        )
    plt.grid(b=True, which="major", color="gray", alpha=0.6, lw=1.5)
    plt.xlabel("f [Hz]")
    plt.ylabel("V^2/Hz [dB]")
    plt.legend()



.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_f_switched_capacitor_digital_control_007.png
          :alt: Estimates
          :class: sphx-glr-multi-img

    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_f_switched_capacitor_digital_control_008.png
          :alt: Estimates PSD
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/scipy/integrate/_ivp/rk.py:502: RuntimeWarning: invalid value encountered in double_scalars
      return np.abs(h) * err5_norm_2 / np.sqrt(denom * len(scale))
    Pre-computations turned off as clock_jitter is simulated
    Pre-computations turned off as clock_jitter is simulated
    Pre-computations turned off as clock_jitter is simulated
    Pre-computations turned off as clock_jitter is simulated
    Pre-computations turned off as clock_jitter is simulated
    Pre-computations turned off as clock_jitter is simulated
    Pre-computations turned off as clock_jitter is simulated
    Pre-computations turned off as clock_jitter is simulated
    /home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/scipy/signal/spectral.py:1964: UserWarning: nperseg = 16384 is greater than input length  = 3584, using nperseg = 3584
      warnings.warn('nperseg = {0:d} is greater than input length '
    /home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/scipy/signal/spectral.py:1964: UserWarning: nperseg = 16384 is greater than input length  = 3584, using nperseg = 3584
      warnings.warn('nperseg = {0:d} is greater than input length '
    /home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/scipy/signal/spectral.py:1964: UserWarning: nperseg = 16384 is greater than input length  = 3584, using nperseg = 3584
      warnings.warn('nperseg = {0:d} is greater than input length '
    /home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/scipy/signal/spectral.py:1964: UserWarning: nperseg = 16384 is greater than input length  = 3584, using nperseg = 3584
      warnings.warn('nperseg = {0:d} is greater than input length '

    <matplotlib.legend.Legend object at 0x7fd7c32b5bb0>




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 8 minutes  1.207 seconds)


.. _sphx_glr_download_tutorials_b_general_plot_f_switched_capacitor_digital_control.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_f_switched_capacitor_digital_control.py <plot_f_switched_capacitor_digital_control.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_f_switched_capacitor_digital_control.ipynb <plot_f_switched_capacitor_digital_control.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
