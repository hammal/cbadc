
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/b_general/plot_e_fixed_point_aritmetics.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_b_general_plot_e_fixed_point_aritmetics.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_b_general_plot_e_fixed_point_aritmetics.py:


=======================
Fixed Point Arithmetics
=======================

In this tutorial we demonstrate we can evaluate the FIR filter using
fixed point arithmetics.

.. GENERATED FROM PYTHON SOURCE LINES 9-14

.. code-block:: default
   :lineno-start: 9

    import scipy.signal
    import numpy as np
    import cbadc
    import matplotlib.pyplot as plt








.. GENERATED FROM PYTHON SOURCE LINES 15-27

Setting up the Analog System and Digital Control
------------------------------------------------

In this example, we assume that we have access to a control signal
s[k] generated by the interactions of an analog system and digital control.
Furthermore, we a chain-of-integrators converter with corresponding
analog system and digital control.

.. image:: /images/chainOfIntegratorsGeneral.svg
   :width: 500
   :align: center
   :alt: The chain of integrators ADC.

.. GENERATED FROM PYTHON SOURCE LINES 27-56

.. code-block:: default
   :lineno-start: 28


    # Setup analog system and digital control

    # We fix the number of analog states.
    N = 6
    M = N
    # Set the amplification factor.
    beta = 6250.0
    rho = -1e-2
    kappa = -1.0
    # In this example, each nodes amplification and local feedback will be set
    # identically.
    betaVec = beta * np.ones(N)
    rhoVec = betaVec * rho
    kappaVec = kappa * beta * np.eye(N)

    # Instantiate a chain-of-integrators analog system.
    analog_system = cbadc.analog_system.ChainOfIntegrators(betaVec, rhoVec, kappaVec)


    T = 1 / (2 * beta)
    digital_control = cbadc.digital_control.DigitalControl(T, M)


    # Summarize the analog system, digital control, and digital estimator.
    print(analog_system, "\n")
    print(digital_control)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ -62.5    0.     0.     0.     0.     0. ]
     [6250.   -62.5    0.     0.     0.     0. ]
     [   0.  6250.   -62.5    0.     0.     0. ]
     [   0.     0.  6250.   -62.5    0.     0. ]
     [   0.     0.     0.  6250.   -62.5    0. ]
     [   0.     0.     0.     0.  6250.   -62.5]],
    B =
    [[6250.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]],
    CT = 
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[-6250.    -0.    -0.    -0.    -0.    -0.]
     [   -0. -6250.    -0.    -0.    -0.    -0.]
     [   -0.    -0. -6250.    -0.    -0.    -0.]
     [   -0.    -0.    -0. -6250.    -0.    -0.]
     [   -0.    -0.    -0.    -0. -6250.    -0.]
     [   -0.    -0.    -0.    -0.    -0. -6250.]],
    Gamma_tildeT =
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]], and D=[[0.]
     [0.]
     [0.]
     [0.]
     [0.]
     [0.]] 

    The Digital Control is parameterized as:
    T = 8e-05,
    M = 6, and next update at
    t = 8e-05




.. GENERATED FROM PYTHON SOURCE LINES 57-64

-------------------------
Fixed Point Configuration
-------------------------

Next we configure the fixed point by instantiating
:py:class:`cbadc.utilities.FixedPoint`.


.. GENERATED FROM PYTHON SOURCE LINES 64-71

.. code-block:: default
   :lineno-start: 65


    bits_used = 20
    max_floating_point_value = 1.0
    fixed_point = cbadc.utilities.FixedPoint(bits_used, max_floating_point_value)
    print(fixed_point)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


            number of bits = 20 including sign bit,
            max float value = 1.0,
            and min float value = 1.9073486328125e-06
        




.. GENERATED FROM PYTHON SOURCE LINES 72-81

----------------
Impulse Response
----------------

Next we instantiate a :py:class:`cbadc.digital_estimator.FIRFilter` and
visualize its impulse responses.

Note the truncation in the impulse response as a result of the
:py:class:`cbadc.utilities.FixedPoint` configuration.

.. GENERATED FROM PYTHON SOURCE LINES 81-119

.. code-block:: default
   :lineno-start: 82


    # Choose an eta2 according to OSR
    OSR = 1 << 5
    omega_3dB = 2 * np.pi / (2 * T * OSR)
    eta2 = (
        np.linalg.norm(analog_system.transfer_function_matrix(np.array([omega_3dB]))) ** 2
    )

    # Instantiate digital estimator
    K1 = 1 << 9
    K2 = 1 << 9
    digital_estimator = cbadc.digital_estimator.FIRFilter(
        analog_system, digital_control, eta2, K1, K2, fixed_point=fixed_point
    )

    # extract impulse response
    impulse_response = np.abs(np.array(digital_estimator.h[0, :, :]))

    # Visualize the impulse response
    h_index = np.arange(-K1, K2)
    fig, ax = plt.subplots(2)
    for index in range(N):
        ax[0].plot(h_index, impulse_response[:, index], label=f"$h_{index + 1}[k]$")
        ax[1].semilogy(h_index, impulse_response[:, index], label=f"$h_{index + 1}[k]$")
    ax[0].legend()
    fig.suptitle(f"For $\eta^2 = {10 * np.log10(eta2)}$ [dB]")
    ax[1].set_xlabel("filter tap k")
    ax[0].set_ylabel("$| h_\ell [k]|$")
    ax[1].set_ylabel("$| h_\ell [k]|$")
    ax[0].set_xlim((-50, 50))
    ax[0].grid(which="both")
    ax[1].set_xlim((-K1, K2))
    ax[1].grid(which="both")

    print(
        f"Total number of filter coefficients = {digital_estimator.number_of_filter_coefficients()}"
    )




.. image:: /tutorials/b_general/images/sphx_glr_plot_e_fixed_point_aritmetics_001.png
    :alt: For $\eta^2 = 84.94011061240755$ [dB]
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Total number of filter coefficients = 1034




.. GENERATED FROM PYTHON SOURCE LINES 120-124

Fixed Point Arithmetic Precision
--------------------------------



.. GENERATED FROM PYTHON SOURCE LINES 124-176

.. code-block:: default
   :lineno-start: 126



    fixed_point_precision = np.array([8, 10, 12, 14, 16, 20, 24])

    control_signal_sequences = [
        cbadc.utilities.byte_stream_2_control_signal(
            cbadc.utilities.read_byte_stream_from_file(
                "../a_getting_started/sinusodial_simulation.adcs", M
            ),
            M,
        )
        for _ in fixed_point_precision
    ]

    size = 1 << 16
    u_hat = np.zeros(size)

    fixed_points = [cbadc.utilities.FixedPoint(bits, 1.0) for bits in fixed_point_precision]


    digital_estimators = [
        cbadc.digital_estimator.FIRFilter(
            analog_system, digital_control, eta2, K1, K2, fixed_point=fixed_point,
        )
        for fixed_point in fixed_points
    ]

    for index, bits in enumerate(fixed_point_precision):
        print(
            f"Precision = {bits} bits, total number of non-zero filter coefficients = {digital_estimators[index].number_of_filter_coefficients()}"
        )


    for index, de in enumerate(digital_estimators):
        de(control_signal_sequences[index])


    for m in range(M):
        plt.figure()
        for bits, de in enumerate(digital_estimators):
            plt.semilogy(
                np.arange(0, K2),
                np.abs(np.array(de.h[0, :, :]))[K2:, m] * fixed_points[bits].min(),
                label=f"#bits = {fixed_point_precision[bits]}",
            )
        plt.legend()
        plt.xlabel("filter tap $k$")
        plt.ylabel(f"$h_[k, {m}]" + " / max$")
        plt.xlim((0, K2))
        plt.ylim((1e-7, 1e0))
        plt.grid(which="both")




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_e_fixed_point_aritmetics_002.png
          :alt: plot e fixed point aritmetics
          :class: sphx-glr-multi-img

    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_e_fixed_point_aritmetics_003.png
          :alt: plot e fixed point aritmetics
          :class: sphx-glr-multi-img

    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_e_fixed_point_aritmetics_004.png
          :alt: plot e fixed point aritmetics
          :class: sphx-glr-multi-img

    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_e_fixed_point_aritmetics_005.png
          :alt: plot e fixed point aritmetics
          :class: sphx-glr-multi-img

    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_e_fixed_point_aritmetics_006.png
          :alt: plot e fixed point aritmetics
          :class: sphx-glr-multi-img

    *

      .. image:: /tutorials/b_general/images/sphx_glr_plot_e_fixed_point_aritmetics_007.png
          :alt: plot e fixed point aritmetics
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Precision = 8 bits, total number of non-zero filter coefficients = 50
    Precision = 10 bits, total number of non-zero filter coefficients = 100
    Precision = 12 bits, total number of non-zero filter coefficients = 172
    Precision = 14 bits, total number of non-zero filter coefficients = 335
    Precision = 16 bits, total number of non-zero filter coefficients = 538
    Precision = 20 bits, total number of non-zero filter coefficients = 1034
    Precision = 24 bits, total number of non-zero filter coefficients = 1675




.. GENERATED FROM PYTHON SOURCE LINES 177-180

Resulting PSD
---------------


.. GENERATED FROM PYTHON SOURCE LINES 180-247

.. code-block:: default
   :lineno-start: 181


    plt.rcParams["figure.figsize"] = [12, 8]
    plt.figure()
    u_hats = []
    description = []
    for index_de, bits in enumerate(fixed_point_precision):
        # Compute estimates for each estimator
        for index in range(size):
            u_hat[index] = next(digital_estimators[index_de])
        u_hats.append(np.copy(u_hat))

        # Compute power spectral density
        f, psd = cbadc.utilities.compute_power_spectral_density(u_hat[K1:])
        signal_index = cbadc.utilities.find_sinusoidal(psd, 50)
        noise_index = np.ones(psd.size, dtype=bool)
        noise_index[signal_index] = False
        noise_index[0:2] = False
        noise_index[size // OSR :] = False
        res = cbadc.utilities.snr_spectrum_computation_extended(
            psd, signal_index, noise_index, fs=1 / T
        )
        SNR = 10 * np.log10(res["snr"])
        ENOB = np.round((SNR - 1.76) / 6.02, 1)
        description.append(
            f"ENOB={ENOB}, fixed point precision={bits} bits, #coeff={digital_estimators[index_de].number_of_filter_coefficients()})"
        )
        # Plot the FIR filters
        plt.semilogx(f, 10 * np.log10(psd), label=description[-1])

    digital_estimators_ref = cbadc.digital_estimator.FIRFilter(
        analog_system, digital_control, eta2, K1, K2
    )

    digital_estimators_ref(
        cbadc.utilities.byte_stream_2_control_signal(
            cbadc.utilities.read_byte_stream_from_file(
                "../a_getting_started/sinusodial_simulation.adcs", M
            ),
            M,
        )
    )

    for index in range(size):
        u_hat[index] = next(digital_estimators_ref)
    u_hats.append(np.copy(u_hat))
    f_ref, psd_ref = cbadc.utilities.compute_power_spectral_density(u_hat[K1:])
    signal_index = cbadc.utilities.find_sinusoidal(psd_ref, 50)
    noise_index = np.ones(psd_ref.size, dtype=bool)
    noise_index[signal_index] = False
    noise_index[0:2] = False
    noise_index[size // OSR :] = False
    res = cbadc.utilities.snr_spectrum_computation_extended(
        psd_ref, signal_index, noise_index, fs=1 / T
    )
    SNR = 10 * np.log10(res["snr"])
    ENOB = np.round((SNR - 1.76) / 6.02, 1)
    description.append(f"Ref, ENOB={ENOB}")

    plt.semilogx(f_ref, 10 * np.log10(psd_ref), label=description[-1])

    plt.legend()
    plt.xlabel("frequency [Hz]")
    plt.grid(b=True, which="major", color="gray", alpha=0.6, lw=1.5)
    plt.ylabel("$ \mathrm{V}^2 \, / \, \mathrm{Hz}$")
    plt.xlim((0.0002, 0.5))
    _ = plt.ylim((-150, 40))




.. image:: /tutorials/b_general/images/sphx_glr_plot_e_fixed_point_aritmetics_008.png
    :alt: plot e fixed point aritmetics
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 248-251

Time Snap Shot
--------------


.. GENERATED FROM PYTHON SOURCE LINES 251-265

.. code-block:: default
   :lineno-start: 252


    # Plot snapshot in time domain
    plt.rcParams["figure.figsize"] = [6.40, 6.40]
    plt.figure()
    plt.title("Estimates in time domain")
    for index in range(len(fixed_point_precision + 1)):
        t_fir = np.arange(-K1 + 1, size - K2 + 1,)
        plt.plot(t_fir, u_hats[index], label=description[index])
    plt.ylabel("$\hat{u}(t)$")
    plt.xlim((64000, 64500))
    plt.ylim((-0.6, 0.6))
    plt.xlabel("$t / T$")
    _ = plt.legend()




.. image:: /tutorials/b_general/images/sphx_glr_plot_e_fixed_point_aritmetics_009.png
    :alt: Estimates in time domain
    :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  39.845 seconds)


.. _sphx_glr_download_tutorials_b_general_plot_e_fixed_point_aritmetics.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_e_fixed_point_aritmetics.py <plot_e_fixed_point_aritmetics.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_e_fixed_point_aritmetics.ipynb <plot_e_fixed_point_aritmetics.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
