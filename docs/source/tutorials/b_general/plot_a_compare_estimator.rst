
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/b_general/plot_a_compare_estimator.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_b_general_plot_a_compare_estimator.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_b_general_plot_a_compare_estimator.py:


Compare Estimators
==================

In this tutorial we investigate different estimator implementation techniques
and compare their performance.

.. GENERATED FROM PYTHON SOURCE LINES 8-13

.. code-block:: default

    import timeit
    import matplotlib.pyplot as plt
    import numpy as np
    import cbadc








.. GENERATED FROM PYTHON SOURCE LINES 14-19

Analog System
-------------

We will commit to a leap-frog control-bounded analog system throughtout
this tutorial.

.. GENERATED FROM PYTHON SOURCE LINES 19-38

.. code-block:: default


    # Determine system parameters
    N = 6
    M = N
    beta = 6250
    # Set control period
    T = 1.0 / (2.0 * beta)
    # Adjust the feedback to achieve a bandwidth corresponding to OSR.
    OSR = 128
    omega_3dB = 2 * np.pi / (T * OSR)

    # Instantiate analog system.
    beta_vec = beta * np.ones(N)
    rho_vec = -(omega_3dB ** 2) / beta * np.ones(N)
    Gamma = np.diag(-beta_vec)
    analog_system = cbadc.analog_system.LeapFrog(beta_vec, rho_vec, Gamma)

    print(analog_system, "\n")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ -60.23928467  -60.23928467    0.            0.            0.
         0.        ]
     [6250.            0.          -60.23928467    0.            0.
         0.        ]
     [   0.         6250.            0.          -60.23928467    0.
         0.        ]
     [   0.            0.         6250.            0.          -60.23928467
         0.        ]
     [   0.            0.            0.         6250.            0.
       -60.23928467]
     [   0.            0.            0.            0.         6250.
         0.        ]],
    B =
    [[6250.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]],
    CT =
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[-6250.     0.     0.     0.     0.     0.]
     [    0. -6250.     0.     0.     0.     0.]
     [    0.     0. -6250.     0.     0.     0.]
     [    0.     0.     0. -6250.     0.     0.]
     [    0.     0.     0.     0. -6250.     0.]
     [    0.     0.     0.     0.     0. -6250.]],
    Gamma_tildeT =
    [[ 1. -0. -0. -0. -0. -0.]
     [-0.  1. -0. -0. -0. -0.]
     [-0. -0.  1. -0. -0. -0.]
     [-0. -0. -0.  1. -0. -0.]
     [-0. -0. -0. -0.  1. -0.]
     [-0. -0. -0. -0. -0.  1.]], and D=[[0.]
     [0.]
     [0.]
     [0.]
     [0.]
     [0.]]





.. GENERATED FROM PYTHON SOURCE LINES 39-44

Analog Signal
-------------

We will also need an analog signal for conversion.
In this tutorial we will use a Sinusoidal signal.

.. GENERATED FROM PYTHON SOURCE LINES 44-61

.. code-block:: default


    # Set the peak amplitude.
    amplitude = 1.0
    # Choose the sinusoidal frequency via an oversampling ratio (OSR).
    frequency = 1.0 / (T * OSR * (1 << 0))

    # We also specify a phase an offset these are hovewer optional.
    phase = 0.0
    offset = 0.0

    # Instantiate the analog signal
    analog_signal = cbadc.analog_signal.Sinusoidal(
        amplitude, frequency, phase, offset)

    print(analog_signal)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Not yet implemented.

    Sinusoidal parameterized as:
    amplitude = 1.0,
    frequency = 97.65624999999999,
    phase = 0.0,
    and
    offset = 0.0





.. GENERATED FROM PYTHON SOURCE LINES 62-67

Simulating
----------

Each estimator will require an independent stream of control signals.
Therefore, we will next instantiate several digital controls and simulators.

.. GENERATED FROM PYTHON SOURCE LINES 67-101

.. code-block:: default


    clock = cbadc.analog_signal.Clock(T)

    # Instantiate digital controls. We will need four of them as we will compare
    # four different estimators.
    digital_control1 = cbadc.digital_control.DigitalControl(clock, M)
    digital_control2 = cbadc.digital_control.DigitalControl(clock, M)
    digital_control3 = cbadc.digital_control.DigitalControl(clock, M)
    digital_control4 = cbadc.digital_control.DigitalControl(clock, M)
    print(digital_control1)

    # Instantiate simulators.
    simulator1 = cbadc.simulator.Simulator(
        analog_system,
        digital_control1,
        [analog_signal],
    )
    simulator2 = cbadc.simulator.Simulator(
        analog_system,
        digital_control2,
        [analog_signal],
    )
    simulator3 = cbadc.simulator.Simulator(
        analog_system,
        digital_control3,
        [analog_signal],
    )
    simulator4 = cbadc.simulator.Simulator(
        analog_system,
        digital_control4,
        [analog_signal],
    )
    print(simulator1)



.. rst-class:: sphx-glr-script-out

.. code-block:: pytb

    Traceback (most recent call last):
      File "/drives1/PhD/cbadc/docs/code_examples/b_general/plot_a_compare_estimator.py", line 79, in <module>
        simulator1 = cbadc.simulator.Simulator(
      File "/home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/cbadc/simulator/analytical_simulator.py", line 79, in __init__
        self.analog_system.homogenius_solution().subs(
      File "/home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/cbadc/analog_system/analog_system.py", line 278, in homogenius_solution
        return sp.solvers.ode.systems.matrix_exp(self._A_s, self.t)
      File "/home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/sympy/solvers/ode/systems.py", line 569, in matrix_exp
        P, expJ = matrix_exp_jordan_form(A, t)
      File "/home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/sympy/solvers/ode/systems.py", line 650, in matrix_exp_jordan_form
        eigenchains = jordan_chains(A)
      File "/home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/sympy/solvers/ode/systems.py", line 637, in jordan_chains
        P, blocks = A.jordan_cells()
      File "/home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/sympy/matrices/matrices.py", line 731, in jordan_cells
        P, J = self.jordan_form()
      File "/home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/sympy/matrices/matrices.py", line 416, in jordan_form
        return _jordan_form(self, calc_transform=calc_transform, **kwargs)
      File "/home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/sympy/matrices/eigen.py", line 1195, in _jordan_form
        raise MatrixError(
    sympy.matrices.common.MatrixError: Jordan normal form is not implemented if the matrix have eigenvalues in CRootOf form




.. GENERATED FROM PYTHON SOURCE LINES 102-111

Default, Quadratic Complexity, Estimator
----------------------------------------

Next we instantiate the quadratic and default estimator
:py:class:`cbadc.digital_estimator.DigitalEstimator`. Note that during its
construction, the corresponding filter coefficients of the system will be
computed. Therefore, this procedure could be computationally intense for a
analog system with a large analog state order or equivalently for large
number of independent digital controls.

.. GENERATED FROM PYTHON SOURCE LINES 111-133

.. code-block:: default


    # Set the bandwidth of the estimator
    G_at_omega = np.linalg.norm(
        analog_system.transfer_function_matrix(np.array([omega_3dB]))
    )
    eta2 = G_at_omega ** 2
    print(f"eta2 = {eta2}, {10 * np.log10(eta2)} [dB]")

    # Set the batch size
    K1 = 1 << 14
    K2 = 1 << 14

    # Instantiate the digital estimator (this is where the filter coefficients are
    # computed).
    digital_estimator_batch = cbadc.digital_estimator.DigitalEstimator(
        analog_system, digital_control1, eta2, K1, K2
    )
    digital_estimator_batch(simulator1)

    print(digital_estimator_batch, "\n")



.. GENERATED FROM PYTHON SOURCE LINES 134-137

Visualize Estimator's Transfer Function (Same for Both)
-------------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 137-176

.. code-block:: default


    # Logspace frequencies
    frequencies = np.logspace(-3, 0, 100)
    omega = 4 * np.pi * beta * frequencies

    # Compute NTF
    ntf = digital_estimator_batch.noise_transfer_function(omega)
    ntf_dB = 20 * np.log10(np.abs(ntf))

    # Compute STF
    stf = digital_estimator_batch.signal_transfer_function(omega)
    stf_dB = 20 * np.log10(np.abs(stf.flatten()))

    # Signal attenuation at the input signal frequency
    stf_at_omega = digital_estimator_batch.signal_transfer_function(
        np.array([2 * np.pi * frequency])
    )[0]

    # Plot
    plt.figure()
    plt.semilogx(frequencies, stf_dB, label="$STF(\omega)$")
    for n in range(N):
        plt.semilogx(frequencies, ntf_dB[0, n, :], label=f"$|NTF_{n+1}(\omega)|$")
    plt.semilogx(
        frequencies,
        20 * np.log10(np.linalg.norm(ntf[0, :, :], axis=0)),
        "--",
        label="$ || NTF(\omega) ||_2 $",
    )

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which="both")
    plt.title("Signal and noise transfer functions")
    plt.xlabel("$\omega / (4 \pi \\beta ) $")
    plt.ylabel("dB")
    plt.xlim((frequencies[1], frequencies[-1]))
    plt.gcf().tight_layout()


.. GENERATED FROM PYTHON SOURCE LINES 177-185

FIR Filter Estimator
--------------------

Similarly as for the previous estimator the
:py:class:`cbadc.digital_estimator.FIRFilter` is initalized. Additionally,
we visualize the decay of the :math:`\|\cdot\|_2` norm of the corresponding
filter coefficients. This is an aid to determine if the lookahead and
lookback sizes L1 and L2 are set sufficiently large.

.. GENERATED FROM PYTHON SOURCE LINES 185-222

.. code-block:: default


    # Determine lookback
    L1 = K2
    # Determine lookahead
    L2 = K2
    digital_estimator_fir = cbadc.digital_estimator.FIRFilter(
        analog_system, digital_control2, eta2, L1, L2
    )

    print(digital_estimator_fir, "\n")

    digital_estimator_fir(simulator2)

    # Next visualize the decay of the resulting filter coefficients.
    h_index = np.arange(-L1, L2)

    impulse_response = np.abs(np.array(digital_estimator_fir.h[0, :, :])) ** 2
    impulse_response_dB = 10 * np.log10(impulse_response)

    fig, ax = plt.subplots(2)
    for index in range(N):
        ax[0].plot(h_index, impulse_response[:, index],
                   label=f"$h_{index + 1}[k]$")
        ax[1].plot(h_index, impulse_response_dB[:, index],
                   label=f"$h_{index + 1}[k]$")
    ax[0].legend()
    fig.suptitle(f"For $\eta^2 = {10 * np.log10(eta2)}$ [dB]")
    ax[1].set_xlabel("filter taps k")
    ax[0].set_ylabel("$| h_\ell [k]|^2_2$")
    ax[1].set_ylabel("$| h_\ell [k]|^2_2$ [dB]")
    ax[0].set_xlim((-50, 50))
    ax[0].grid(which="both")
    ax[1].set_xlim((-50, 500))
    ax[1].set_ylim((-200, 0))
    ax[1].grid(which="both")



.. GENERATED FROM PYTHON SOURCE LINES 223-229

IIR Filter Estimator
--------------------

The IIR filter is closely related to the FIR filter with the exception
of an moving average computation.
See :py:class:`cbadc.digital_estimator.IIRFilter` for more information.

.. GENERATED FROM PYTHON SOURCE LINES 229-241

.. code-block:: default


    # Determine lookahead
    L2 = K2

    digital_estimator_iir = cbadc.digital_estimator.IIRFilter(
        analog_system, digital_control3, eta2, L2
    )

    print(digital_estimator_iir, "\n")

    digital_estimator_iir(simulator3)


.. GENERATED FROM PYTHON SOURCE LINES 242-250

Parallel Estimator
------------------------------

Next we instantiate the parallel estimator
:py:class:`cbadc.digital_estimator.ParallelEstimator`. The parallel estimator
resembles the default estimator but diagonalizes the filter coefficients
resulting in a more computationally more efficient filter that can be
parallelized into independent filter operations.

.. GENERATED FROM PYTHON SOURCE LINES 250-261

.. code-block:: default


    # Instantiate the digital estimator (this is where the filter coefficients are
    # computed).
    digital_estimator_parallel = cbadc.digital_estimator.ParallelEstimator(
        analog_system, digital_control4, eta2, K1, K2
    )

    digital_estimator_parallel(simulator4)
    print(digital_estimator_parallel, "\n")



.. GENERATED FROM PYTHON SOURCE LINES 262-269

Estimating (Filtering)
----------------------

Next we execute all simulation and estimation tasks by iterating over the
estimators. Note that since no stop criteria is set for either the analog
signal, the simulator, or the digital estimator this iteration could
potentially continue until the default stop criteria of 2^63 iterations.

.. GENERATED FROM PYTHON SOURCE LINES 269-282

.. code-block:: default


    # Set simulation length
    size = K2 << 4
    u_hat_batch = np.zeros(size)
    u_hat_fir = np.zeros(size)
    u_hat_iir = np.zeros(size)
    u_hat_parallel = np.zeros(size)
    for index in range(size):
        u_hat_batch[index] = next(digital_estimator_batch)
        u_hat_fir[index] = next(digital_estimator_fir)
        u_hat_iir[index] = next(digital_estimator_iir)
        u_hat_parallel[index] = next(digital_estimator_parallel)


.. GENERATED FROM PYTHON SOURCE LINES 283-288

Visualizing Results
-------------------

Finally, we summarize the comparision by visualizing the resulting estimate
in both time and frequency domain.

.. GENERATED FROM PYTHON SOURCE LINES 288-404

.. code-block:: default


    t = np.arange(size)
    # compensate the built in L1 delay of FIR filter.
    t_fir = np.arange(-L1 + 1, size - L1 + 1)
    t_iir = np.arange(-L1 + 1, size - L1 + 1)
    u = np.zeros_like(u_hat_batch)
    for index, tt in enumerate(t):
        u[index] = analog_signal.evaluate(tt * T)
    plt.plot(t, u_hat_batch, label="$\hat{u}(t)$ Batch")
    plt.plot(t_fir, u_hat_fir, label="$\hat{u}(t)$ FIR")
    plt.plot(t_iir, u_hat_iir, label="$\hat{u}(t)$ IIR")
    plt.plot(t, u_hat_parallel, label="$\hat{u}(t)$ Parallel")
    plt.plot(t, stf_at_omega * u, label="$\mathrm{STF}(2 \pi f_u) * u(t)$")
    plt.xlabel("$t / T$")
    plt.legend()
    plt.title("Estimated input signal")
    plt.grid(which="both")
    plt.xlim((-100, 500))
    plt.tight_layout()

    plt.figure()
    plt.plot(t, u_hat_batch, label="$\hat{u}(t)$ Batch")
    plt.plot(t_fir, u_hat_fir, label="$\hat{u}(t)$ FIR")
    plt.plot(t_iir, u_hat_iir, label="$\hat{u}(t)$ IIR")
    plt.plot(t, u_hat_parallel, label="$\hat{u}(t)$ Parallel")
    plt.plot(t, stf_at_omega * u, label="$\mathrm{STF}(2 \pi f_u) * u(t)$")
    plt.xlabel("$t / T$")
    plt.legend()
    plt.title("Estimated input signal")
    plt.grid(which="both")
    plt.xlim((t_fir[-1] - 50, t_fir[-1]))
    plt.tight_layout()

    plt.figure()
    plt.plot(t, u_hat_batch, label="$\hat{u}(t)$ Batch")
    plt.plot(t_fir, u_hat_fir, label="$\hat{u}(t)$ FIR")
    plt.plot(t_iir, u_hat_iir, label="$\hat{u}(t)$ IIR")
    plt.plot(t, u_hat_parallel, label="$\hat{u}(t)$ Parallel")
    plt.plot(t, stf_at_omega * u, label="$\mathrm{STF}(2 \pi f_u) * u(t)$")
    plt.xlabel("$t / T$")
    plt.legend()
    plt.title("Estimated input signal")
    plt.grid(which="both")
    # plt.xlim((t_fir[0], t[-1]))
    plt.xlim(((1 << 14) - 100, (1 << 14) + 100))
    plt.tight_layout()

    batch_error = stf_at_omega * u - u_hat_batch
    fir_error = stf_at_omega * u[: (u.size - L1 + 1)] - u_hat_fir[(L1 - 1):]
    iir_error = stf_at_omega * u[: (u.size - L1 + 1)] - u_hat_iir[(L1 - 1):]
    parallel_error = stf_at_omega * u - u_hat_parallel
    plt.figure()
    plt.plot(t, batch_error,
             label="$|\mathrm{STF}(2 \pi f_u) * u(t) - \hat{u}(t)|$ Batch")
    plt.plot(
        t[: (u.size - L1 + 1)],
        fir_error,
        label="$|\mathrm{STF}(2 \pi f_u) * u(t) - \hat{u}(t)|$ FIR",
    )
    plt.plot(
        t[: (u.size - L1 + 1)],
        iir_error,
        label="$|\mathrm{STF}(2 \pi f_u) * u(t) - \hat{u}(t)|$ IIR",
    )
    plt.plot(
        t, parallel_error, label="$|\mathrm{STF}(2 \pi f_u) * u(t) - \hat{u}(t)|$ Parallel"
    )
    plt.xlabel("$t / T$")
    plt.xlim(((1 << 14) - 100, (1 << 14) + 100))
    plt.ylim((-0.00001, 0.00001))
    plt.legend()
    plt.title("Estimation error")
    plt.grid(which="both")
    plt.tight_layout()


    print(f"Average Batch Error: {np.linalg.norm(batch_error) / batch_error.size}")
    print(f"Average FIR Error: {np.linalg.norm(fir_error) / fir_error.size}")
    print(f"Average IIR Error: {np.linalg.norm(iir_error) / iir_error.size}")
    print(
        f"""Average Parallel Error: { np.linalg.norm(parallel_error)/
        parallel_error.size}"""
    )

    plt.figure()
    u_hat_batch_clipped = u_hat_batch[(K1 + K2): -K2]
    u_hat_fir_clipped = u_hat_fir[(L1 + L2):]
    u_hat_iir_clipped = u_hat_iir[(K1 + K2): -K2]
    u_hat_parallel_clipped = u_hat_parallel[(K1 + K2): -K2]
    u_clipped = stf_at_omega * u
    f_batch, psd_batch = cbadc.utilities.compute_power_spectral_density(
        u_hat_batch_clipped)
    f_fir, psd_fir = cbadc.utilities.compute_power_spectral_density(
        u_hat_fir_clipped)
    f_iir, psd_iir = cbadc.utilities.compute_power_spectral_density(
        u_hat_iir_clipped)
    f_parallel, psd_parallel = cbadc.utilities.compute_power_spectral_density(
        u_hat_parallel_clipped
    )
    f_ref, psd_ref = cbadc.utilities.compute_power_spectral_density(u_clipped)
    plt.semilogx(f_ref, 10 * np.log10(psd_ref),
                 label="$\mathrm{STF}(2 \pi f_u) * U(f)$")
    plt.semilogx(f_batch, 10 * np.log10(psd_batch), label="$\hat{U}(f)$ Batch")
    plt.semilogx(f_fir, 10 * np.log10(psd_fir), label="$\hat{U}(f)$ FIR")
    plt.semilogx(f_iir, 10 * np.log10(psd_iir), label="$\hat{U}(f)$ IIR")
    plt.semilogx(f_parallel, 10 * np.log10(psd_parallel),
                 label="$\hat{U}(f)$ Parallel")
    plt.legend()
    plt.ylim((-200, 50))
    plt.xlim((f_fir[1], f_fir[-1]))
    plt.xlabel("frequency [Hz]")
    plt.ylabel("$ \mathrm{V}^2 \, / \, (1 \mathrm{Hz})$")
    plt.grid(which="both")
    plt.show()



.. GENERATED FROM PYTHON SOURCE LINES 405-409

Compute Time
------------

Compare the execution time of each estimator

.. GENERATED FROM PYTHON SOURCE LINES 409-478

.. code-block:: default



    def dummy_input_control_signal():
        while True:
            yield np.zeros(M, dtype=np.int8)


    def iterate_number_of_times(iterator, number_of_times):
        for _ in range(number_of_times):
            _ = next(iterator)


    digital_estimator_batch = cbadc.digital_estimator.DigitalEstimator(
        analog_system, digital_control1, eta2, K1, K2
    )
    digital_estimator_fir = cbadc.digital_estimator.FIRFilter(
        analog_system, digital_control2, eta2, L1, L2
    )
    digital_estimator_parallel = cbadc.digital_estimator.ParallelEstimator(
        analog_system, digital_control4, eta2, K1, K2
    )
    digital_estimator_iir = cbadc.digital_estimator.IIRFilter(
        analog_system, digital_control3, eta2, L2
    )

    digital_estimator_batch(dummy_input_control_signal())
    digital_estimator_fir(dummy_input_control_signal())
    digital_estimator_parallel(dummy_input_control_signal())
    digital_estimator_iir(dummy_input_control_signal())

    length = 1 << 14
    repetitions = 10

    print("Digital Estimator:")
    print(
        timeit.timeit(
            lambda: iterate_number_of_times(digital_estimator_batch, length),
            number=repetitions,
        ),
        "sec \n",
    )

    print("FIR Estimator:")
    print(
        timeit.timeit(
            lambda: iterate_number_of_times(digital_estimator_fir, length),
            number=repetitions,
        ),
        "sec \n",
    )

    print("IIR Estimator:")
    print(
        timeit.timeit(
            lambda: iterate_number_of_times(digital_estimator_iir, length),
            number=repetitions,
        ),
        "sec \n",
    )

    print("Parallel Estimator:")
    print(
        timeit.timeit(
            lambda: iterate_number_of_times(digital_estimator_parallel, length),
            number=repetitions,
        ),
        "sec \n",
    )



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  1.458 seconds)


.. _sphx_glr_download_tutorials_b_general_plot_a_compare_estimator.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_a_compare_estimator.py <plot_a_compare_estimator.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_a_compare_estimator.ipynb <plot_a_compare_estimator.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
