
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/b_general/plot_a_compare_estimator.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_b_general_plot_a_compare_estimator.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_b_general_plot_a_compare_estimator.py:


Compare Estimators
==================

In this tutorial we investigate different estimator implementation techniques
and compare their performance.

.. GENERATED FROM PYTHON SOURCE LINES 8-13

.. code-block:: default

    import timeit
    import matplotlib.pyplot as plt
    import numpy as np
    import cbadc








.. GENERATED FROM PYTHON SOURCE LINES 14-19

Analog System
-------------

We will commit to a leap-frog control-bounded analog system throughtout
this tutorial.

.. GENERATED FROM PYTHON SOURCE LINES 19-40

.. code-block:: default


    # Determine system parameters
    N = 6
    M = N

    BW = 1e3
    OSR = 32
    # Fix per-stage gain at bandwidth
    gamma = OSR / np.pi
    omega_3dB = 2 * np.pi * BW

    # Instantiate analog system.
    beta_vec = gamma * (omega_3dB / 2) * np.ones(N)
    alpha_vec = -(omega_3dB / 2) / gamma * np.ones(N - 1)
    rho_vec = np.zeros(N)
    T = 1.0 / (2.0 * beta_vec[0])
    Gamma = np.diag(-beta_vec)
    analog_system = cbadc.analog_system.LeapFrog(beta_vec, alpha_vec, rho_vec, Gamma)

    print(analog_system, "\n")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[    0.          -308.42513753     0.             0.
          0.             0.        ]
     [32000.             0.          -308.42513753     0.
          0.             0.        ]
     [    0.         32000.             0.          -308.42513753
          0.             0.        ]
     [    0.             0.         32000.             0.
       -308.42513753     0.        ]
     [    0.             0.             0.         32000.
          0.          -308.42513753]
     [    0.             0.             0.             0.
      32000.             0.        ]],
    B =
    [[32000.]
     [    0.]
     [    0.]
     [    0.]
     [    0.]
     [    0.]],
    CT =
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[-32000.      0.      0.      0.      0.      0.]
     [     0. -32000.      0.      0.      0.      0.]
     [     0.      0. -32000.      0.      0.      0.]
     [     0.      0.      0. -32000.      0.      0.]
     [     0.      0.      0.      0. -32000.      0.]
     [     0.      0.      0.      0.      0. -32000.]],
    Gamma_tildeT =
    [[ 1. -0. -0. -0. -0. -0.]
     [-0.  1. -0. -0. -0. -0.]
     [-0. -0.  1. -0. -0. -0.]
     [-0. -0. -0.  1. -0. -0.]
     [-0. -0. -0. -0.  1. -0.]
     [-0. -0. -0. -0. -0.  1.]], and D=[[0.]
     [0.]
     [0.]
     [0.]
     [0.]
     [0.]]





.. GENERATED FROM PYTHON SOURCE LINES 41-46

Analog Signal
-------------

We will also need an analog signal for conversion.
In this tutorial we will use a Sinusoidal signal.

.. GENERATED FROM PYTHON SOURCE LINES 46-60

.. code-block:: default


    # Set the peak amplitude.
    amplitude = 1.0
    # Choose the sinusoidal frequency via an oversampling ratio (OSR).
    frequency = BW / 4
    # We also specify a phase an offset these are hovewer optional.
    phase = 0.0
    offset = 0.0

    # Instantiate the analog signal
    analog_signal = cbadc.analog_signal.Sinusoidal(amplitude, frequency, phase, offset)

    print(analog_signal)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    Sinusoidal parameterized as:
    amplitude = 1.0,
    frequency = 250.0,
    phase = 0.0,
    and
    offset = 0.0





.. GENERATED FROM PYTHON SOURCE LINES 61-66

Simulating
----------

Each estimator will require an independent stream of control signals.
Therefore, we will next instantiate several digital controls and simulators.

.. GENERATED FROM PYTHON SOURCE LINES 66-91

.. code-block:: default



    # Instantiate digital controls. We will need four of them as we will compare
    # four different estimators.
    digital_control1 = cbadc.digital_control.DigitalControl(cbadc.analog_signal.Clock(T), M)
    digital_control2 = cbadc.digital_control.DigitalControl(cbadc.analog_signal.Clock(T), M)
    digital_control3 = cbadc.digital_control.DigitalControl(cbadc.analog_signal.Clock(T), M)
    digital_control4 = cbadc.digital_control.DigitalControl(cbadc.analog_signal.Clock(T), M)
    print(digital_control1)

    # Instantiate simulators.
    simulator1 = cbadc.simulator.get_simulator(
        analog_system, digital_control1, [analog_signal]
    )
    simulator2 = cbadc.simulator.get_simulator(
        analog_system, digital_control2, [analog_signal]
    )
    simulator3 = cbadc.simulator.get_simulator(
        analog_system, digital_control3, [analog_signal]
    )
    simulator4 = cbadc.simulator.get_simulator(
        analog_system, digital_control4, [analog_signal]
    )
    print(simulator1)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    ================================================================================

    The Digital Control is parameterized as:

    --------------------------------------------------------------------------------

    clock:
    Analog signal returns constant 0, i.e., maps t |-> 0.

    M:
    6
    ================================================================================

    ================================================================================

    The Simulator is parameterized by the:

    --------------------------------------------------------------------------------

    Analog System:
    The analog system is parameterized as:
    A =
    [[    0.          -308.42513753     0.             0.
          0.             0.        ]
     [32000.             0.          -308.42513753     0.
          0.             0.        ]
     [    0.         32000.             0.          -308.42513753
          0.             0.        ]
     [    0.             0.         32000.             0.
       -308.42513753     0.        ]
     [    0.             0.             0.         32000.
          0.          -308.42513753]
     [    0.             0.             0.             0.
      32000.             0.        ]],
    B =
    [[32000.]
     [    0.]
     [    0.]
     [    0.]
     [    0.]
     [    0.]],
    CT =
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[-32000.      0.      0.      0.      0.      0.]
     [     0. -32000.      0.      0.      0.      0.]
     [     0.      0. -32000.      0.      0.      0.]
     [     0.      0.      0. -32000.      0.      0.]
     [     0.      0.      0.      0. -32000.      0.]
     [     0.      0.      0.      0.      0. -32000.]],
    Gamma_tildeT =
    [[ 1. -0. -0. -0. -0. -0.]
     [-0.  1. -0. -0. -0. -0.]
     [-0. -0.  1. -0. -0. -0.]
     [-0. -0. -0.  1. -0. -0.]
     [-0. -0. -0. -0.  1. -0.]
     [-0. -0. -0. -0. -0.  1.]], and D=[[0.]
     [0.]
     [0.]
     [0.]
     [0.]
     [0.]]

    Digital Control:
    ================================================================================

    The Digital Control is parameterized as:

    --------------------------------------------------------------------------------

    clock:
    Analog signal returns constant 0, i.e., maps t |-> 0.

    M:
    6
    ================================================================================


    Input signals:

    Sinusoidal parameterized as:
    amplitude = 1.0,
    frequency = 250.0,
    phase = 0.0,
    and
    offset = 0.0


    Clock:
    Analog signal returns constant 0, i.e., maps t |-> 0.

    t_stop:
    inf

    --------------------------------------------------------------------------------

    Currently the

    state vector is:
    [0. 0. 0. 0. 0. 0.]

    t:
    0.0

    --------------------------------------------------------------------------------


            ================================================================================

    atol, rtol:
    1e-09, 1e-06

    Pre computed transition matrix:
    [[ 9.98795698e-01 -4.81527325e-03  1.16050752e-05 -1.86444179e-08
       2.24643322e-11 -2.16542496e-14]
     [ 4.99598526e-01  9.97591638e-01 -4.81333884e-03  1.16027445e-05
      -1.86421712e-08  2.24643322e-11]
     [ 1.24924719e-01  4.99397825e-01  9.97591880e-01 -4.81333907e-03
       1.16027445e-05 -1.86444179e-08]
     [ 2.08232955e-02  1.24899629e-01  4.99397849e-01  9.97591880e-01
      -4.81333884e-03  1.16050752e-05]
     [ 2.60312102e-03  2.08207862e-02  1.24899629e-01  4.99397825e-01
       9.97591638e-01 -4.81527325e-03]
     [ 2.60341975e-04  2.60312102e-03  2.08232955e-02  1.24924719e-01
       4.99598526e-01  9.98795698e-01]]

    Pre-computed control matrix
    [[-4.99799251e-01  1.20430195e-03 -1.93464537e-06  2.33092665e-09
      -2.24669054e-12  1.80861355e-15]
     [-1.24949811e-01 -4.99598526e-01  1.20406011e-03 -1.93441227e-06
       2.33073934e-09 -2.24668025e-12]
     [-2.08258047e-02 -1.24924719e-01 -4.99598550e-01  1.20406013e-03
      -1.93441227e-06  2.33092503e-09]
     [-2.60333014e-03 -2.08232955e-02 -1.24924721e-01 -4.99598550e-01
       1.20406011e-03 -1.93464538e-06]
     [-2.60341975e-04 -2.60312102e-03 -2.08232955e-02 -1.24924719e-01
      -4.99598526e-01  1.20430195e-03]
     [-2.16967209e-05 -2.60341975e-04 -2.60333014e-03 -2.08258047e-02
      -1.24949811e-01 -4.99799251e-01]]






.. GENERATED FROM PYTHON SOURCE LINES 92-101

Default, Quadratic Complexity, Estimator
----------------------------------------

Next we instantiate the quadratic and default estimator
:py:class:`cbadc.digital_estimator.BatchEstimator`. Note that during its
construction, the corresponding filter coefficients of the system will be
computed. Therefore, this procedure could be computationally intense for a
analog system with a large analog state order or equivalently for large
number of independent digital controls.

.. GENERATED FROM PYTHON SOURCE LINES 101-123

.. code-block:: default


    # Set the bandwidth of the estimator
    G_at_omega = np.linalg.norm(
        analog_system.transfer_function_matrix(np.array([omega_3dB]))
    )
    eta2 = G_at_omega ** 2
    print(f"eta2 = {eta2}, {10 * np.log10(eta2)} [dB]")

    # Set the batch size
    K1 = 1 << 11
    K2 = 1 << 11

    # Instantiate the digital estimator (this is where the filter coefficients are
    # computed).
    digital_estimator_batch = cbadc.digital_estimator.BatchEstimator(
        analog_system, digital_control1, eta2, K1, K2
    )
    digital_estimator_batch(simulator1)

    print(digital_estimator_batch, "\n")






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    eta2 = 26459977418.02706, 104.22589469207853 [dB]
    Digital estimator is parameterized as

    eta2 = 26459977418.03, 104 [dB],

    Ts = 1.5625e-05,
    K1 = 2048,
    K2 = 2048,

    and
    number_of_iterations = 9223372036854775808

    Resulting in the filter coefficients
    Af =
    [[ 9.98795698e-01 -4.81527485e-03  1.16035361e-05 -6.07235846e-09
       6.62781583e-08  1.14909591e-07]
     [ 4.99598514e-01  9.97591577e-01 -4.81358199e-03  1.09658379e-05
      -8.28257369e-07  1.72361023e-07]
     [ 1.24924560e-01  4.99396743e-01  9.97586120e-01 -4.83576711e-03
      -4.54113081e-05 -6.95421344e-05]
     [ 2.08218061e-02  1.24888065e-01  4.99326185e-01  9.97258846e-01
      -5.84265925e-03 -1.59108618e-03]
     [ 2.59409426e-03  2.07435792e-02  1.24365449e-01  4.96571297e-01
       9.87314426e-01 -2.37271694e-02]
     [ 2.31177572e-04  2.33031405e-03  1.87279492e-02  1.12314958e-01
       4.45032553e-01  8.62936312e-01]],

    Ab =
    [[ 9.98795698e-01  4.81527485e-03  1.16035361e-05  6.07235846e-09
       6.62781583e-08 -1.14909591e-07]
     [-4.99598514e-01  9.97591577e-01  4.81358199e-03  1.09658379e-05
       8.28257369e-07  1.72361023e-07]
     [ 1.24924560e-01 -4.99396743e-01  9.97586120e-01  4.83576711e-03
      -4.54113081e-05  6.95421344e-05]
     [-2.08218061e-02  1.24888065e-01 -4.99326185e-01  9.97258846e-01
       5.84265925e-03 -1.59108618e-03]
     [ 2.59409426e-03 -2.07435792e-02  1.24365449e-01 -4.96571297e-01
       9.87314426e-01  2.37271694e-02]
     [-2.31177572e-04  2.33031405e-03 -1.87279492e-02  1.12314958e-01
      -4.45032553e-01  8.62936312e-01]],

    Bf =
    [[-4.99799251e-01  1.20430232e-03 -1.93398908e-06  6.46854605e-10
      -1.41189812e-08 -2.95070176e-08]
     [-1.24949809e-01 -4.99598515e-01  1.20410779e-03 -1.79017597e-06
       2.17324128e-07 -2.55036474e-08]
     [-2.08257856e-02 -1.24924564e-01 -4.99597571e-01  1.20849684e-03
       1.10586458e-05  1.82041145e-05]
     [-2.60317066e-03 -2.08218097e-02 -1.24913623e-01 -4.99536697e-01
       1.42998475e-03  4.11783042e-04]
     [-2.59457773e-04 -2.59406069e-03 -2.07471338e-02 -1.24432802e-01
      -4.97413073e-01  6.04765403e-03]
     [-1.90632341e-05 -2.31053871e-04 -2.33077494e-03 -1.88139600e-02
      -1.14126403e-01 -4.65402801e-01]],

    Bb =
    [[ 4.99799251e-01  1.20430232e-03  1.93398908e-06  6.46854605e-10
       1.41189812e-08 -2.95070176e-08]
     [-1.24949809e-01  4.99598515e-01  1.20410779e-03  1.79017597e-06
       2.17324128e-07  2.55036474e-08]
     [ 2.08257856e-02 -1.24924564e-01  4.99597571e-01  1.20849684e-03
      -1.10586458e-05  1.82041145e-05]
     [-2.60317066e-03  2.08218097e-02 -1.24913623e-01  4.99536697e-01
       1.42998475e-03 -4.11783042e-04]
     [ 2.59457773e-04 -2.59406069e-03  2.07471338e-02 -1.24432802e-01
       4.97413073e-01  6.04765403e-03]
     [-1.90632341e-05  2.31053871e-04 -2.33077494e-03  1.88139600e-02
      -1.14126403e-01  4.65402801e-01]],

    and WT =
    [[ 6.22717510e-02  1.50438371e-19 -2.26678168e-04  5.01702132e-22
       2.08035013e-06 -2.62726899e-23]].





.. GENERATED FROM PYTHON SOURCE LINES 124-127

Visualize Estimator's Transfer Function (Same for Both)
-------------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 127-166

.. code-block:: default


    # Logspace frequencies
    frequencies = np.logspace(-3, 0, 100)
    omega = 4 * np.pi * beta_vec[0] * frequencies

    # Compute NTF
    ntf = digital_estimator_batch.noise_transfer_function(omega)
    ntf_dB = 20 * np.log10(np.abs(ntf))

    # Compute STF
    stf = digital_estimator_batch.signal_transfer_function(omega)
    stf_dB = 20 * np.log10(np.abs(stf.flatten()))

    # Signal attenuation at the input signal frequency
    stf_at_omega = digital_estimator_batch.signal_transfer_function(
        np.array([2 * np.pi * frequency])
    )[0]

    # Plot
    plt.figure()
    plt.semilogx(frequencies, stf_dB, label="$STF(\omega)$")
    for n in range(N):
        plt.semilogx(frequencies, ntf_dB[0, n, :], label=f"$|NTF_{n+1}(\omega)|$")
    plt.semilogx(
        frequencies,
        20 * np.log10(np.linalg.norm(ntf[0, :, :], axis=0)),
        "--",
        label="$ || NTF(\omega) ||_2 $",
    )

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which="both")
    plt.title("Signal and noise transfer functions")
    plt.xlabel("$\omega / (4 \pi \\beta ) $")
    plt.ylabel("dB")
    plt.xlim((frequencies[1], frequencies[-1]))
    plt.gcf().tight_layout()




.. image-sg:: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_001.png
   :alt: Signal and noise transfer functions
   :srcset: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 167-175

FIR Filter Estimator
--------------------

Similarly as for the previous estimator the
:py:class:`cbadc.digital_estimator.FIRFilter` is initalized. Additionally,
we visualize the decay of the :math:`\|\cdot\|_2` norm of the corresponding
filter coefficients. This is an aid to determine if the lookahead and
lookback sizes L1 and L2 are set sufficiently large.

.. GENERATED FROM PYTHON SOURCE LINES 175-210

.. code-block:: default


    # Determine lookback
    L1 = K2
    # Determine lookahead
    L2 = K2
    digital_estimator_fir = cbadc.digital_estimator.FIRFilter(
        analog_system, digital_control2, eta2, L1, L2
    )

    print(digital_estimator_fir, "\n")

    digital_estimator_fir(simulator2)

    # Next visualize the decay of the resulting filter coefficients.
    h_index = np.arange(-L1, L2)

    impulse_response = np.abs(np.array(digital_estimator_fir.h[0, :, :])) ** 2
    impulse_response_dB = 10 * np.log10(impulse_response)

    fig, ax = plt.subplots(2)
    for index in range(N):
        ax[0].plot(h_index, impulse_response[:, index], label=f"$h_{index + 1}[k]$")
        ax[1].plot(h_index, impulse_response_dB[:, index], label=f"$h_{index + 1}[k]$")
    ax[0].legend()
    fig.suptitle(f"For $\eta^2 = {10 * np.log10(eta2)}$ [dB]")
    ax[1].set_xlabel("filter taps k")
    ax[0].set_ylabel("$| h_\ell [k]|^2_2$")
    ax[1].set_ylabel("$| h_\ell [k]|^2_2$ [dB]")
    ax[0].set_xlim((-50, 50))
    ax[0].grid(which="both")
    ax[1].set_xlim((-50, 500))
    ax[1].set_ylim((-200, 0))
    ax[1].grid(which="both")





.. image-sg:: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_002.png
   :alt: For $\eta^2 = 104.22589469207853$ [dB]
   :srcset: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    FIR estimator is parameterized as
    eta2 = 26459977418.03, 104 [dB],
    Ts = 1.5625e-05,
    K1 = 2048,
    K2 = 2048,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    h =
    [[[-1.55314631e-12  5.63120300e-12 -1.71059167e-13 -8.99375700e-14
        8.49137247e-15  6.26348645e-16]
      [-4.38409135e-12  5.68418045e-12 -9.75981959e-14 -9.46400845e-14
        7.70083018e-15  7.54660412e-16]
      [-7.22882161e-12  5.68614173e-12 -2.18449945e-14 -9.85659483e-14
        6.82475059e-15  8.78508578e-16]
      ...
      [-7.22882161e-12 -5.68614173e-12 -2.18449945e-14  9.85659483e-14
        6.82475059e-15 -8.78508578e-16]
      [-4.38409135e-12 -5.68418045e-12 -9.75981959e-14  9.46400845e-14
        7.70083018e-15 -7.54660412e-16]
      [-1.55314631e-12 -5.63120300e-12 -1.71059167e-13  8.99375700e-14
        8.49137247e-15 -6.26348645e-16]]].





.. GENERATED FROM PYTHON SOURCE LINES 211-217

IIR Filter Estimator
--------------------

The IIR filter is closely related to the FIR filter with the exception
of an moving average computation.
See :py:class:`cbadc.digital_estimator.IIRFilter` for more information.

.. GENERATED FROM PYTHON SOURCE LINES 217-229

.. code-block:: default


    # Determine lookahead
    L2 = K2

    digital_estimator_iir = cbadc.digital_estimator.IIRFilter(
        analog_system, digital_control3, eta2, L2
    )

    print(digital_estimator_iir, "\n")

    digital_estimator_iir(simulator3)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    IIR estimator is parameterized as
    eta2 = 26459977418.03, 104 [dB],
    Ts = 1.5625e-05,
    K2 = 2048,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    Af =
    [[ 9.98795698e-01 -4.81527485e-03  1.16035361e-05 -6.07235846e-09
       6.62781583e-08  1.14909591e-07]
     [ 4.99598514e-01  9.97591577e-01 -4.81358199e-03  1.09658379e-05
      -8.28257369e-07  1.72361023e-07]
     [ 1.24924560e-01  4.99396743e-01  9.97586120e-01 -4.83576711e-03
      -4.54113081e-05 -6.95421344e-05]
     [ 2.08218061e-02  1.24888065e-01  4.99326185e-01  9.97258846e-01
      -5.84265925e-03 -1.59108618e-03]
     [ 2.59409426e-03  2.07435792e-02  1.24365449e-01  4.96571297e-01
       9.87314426e-01 -2.37271694e-02]
     [ 2.31177572e-04  2.33031405e-03  1.87279492e-02  1.12314958e-01
       4.45032553e-01  8.62936312e-01]],
    Bf =
    [[-4.99799251e-01  1.20430232e-03 -1.93398908e-06  6.46854605e-10
      -1.41189812e-08 -2.95070176e-08]
     [-1.24949809e-01 -4.99598515e-01  1.20410779e-03 -1.79017597e-06
       2.17324128e-07 -2.55036474e-08]
     [-2.08257856e-02 -1.24924564e-01 -4.99597571e-01  1.20849684e-03
       1.10586458e-05  1.82041145e-05]
     [-2.60317066e-03 -2.08218097e-02 -1.24913623e-01 -4.99536697e-01
       1.42998475e-03  4.11783042e-04]
     [-2.59457773e-04 -2.59406069e-03 -2.07471338e-02 -1.24432802e-01
      -4.97413073e-01  6.04765403e-03]
     [-1.90632341e-05 -2.31053871e-04 -2.33077494e-03 -1.88139600e-02
      -1.14126403e-01 -4.65402801e-01]],WT =
    [[ 6.22717510e-02  1.50438371e-19 -2.26678168e-04  5.01702132e-22
       2.08035013e-06 -2.62726899e-23]],
     and h =
    [[[ 3.11186543e-02  1.03306289e-04 -1.13084268e-04 -5.32763365e-07
        1.03817932e-06  6.61730890e-09]
      [ 3.10154531e-02  3.09288216e-04 -1.11557924e-04 -1.59161719e-06
        1.02623510e-06  1.97688980e-08]
      [ 3.08096807e-02  5.13382899e-04 -1.08517969e-04 -2.63052107e-06
        1.00249745e-06  3.26727142e-08]
      ...
      [-7.22882161e-12 -5.68614173e-12 -2.18449945e-14  9.85659483e-14
        6.82475059e-15 -8.78508578e-16]
      [-4.38409135e-12 -5.68418045e-12 -9.75981959e-14  9.46400845e-14
        7.70083018e-15 -7.54660412e-16]
      [-1.55314631e-12 -5.63120300e-12 -1.71059167e-13  8.99375700e-14
        8.49137247e-15 -6.26348645e-16]]].





.. GENERATED FROM PYTHON SOURCE LINES 230-238

Parallel Estimator
------------------------------

Next we instantiate the parallel estimator
:py:class:`cbadc.digital_estimator.ParallelEstimator`. The parallel estimator
resembles the default estimator but diagonalizes the filter coefficients
resulting in a more computationally more efficient filter that can be
parallelized into independent filter operations.

.. GENERATED FROM PYTHON SOURCE LINES 238-249

.. code-block:: default


    # Instantiate the digital estimator (this is where the filter coefficients are
    # computed).
    digital_estimator_parallel = cbadc.digital_estimator.ParallelEstimator(
        analog_system, digital_control4, eta2, K1, K2
    )

    digital_estimator_parallel(simulator4)
    print(digital_estimator_parallel, "\n")






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Parallel estimator is parameterized as
    eta2 = 26459977418.03, 104 [dB],
    Ts = 1.5625e-05,
    K1 = 2048,
    K2 = 2048,
    and
    number_of_iterations = 9223372036854775808
    Resulting in the filter coefficients
    f_a =
    [0.98616542+0.09375588j 0.98616542-0.09375588j 0.97147317+0.06629753j
     0.97147317-0.06629753j 0.9631029 +0.02376522j 0.9631029 -0.02376522j],
    b_a =
    [[-1.67833262e+03+4.08886106e+02j  4.58527849e+01+3.25879138e+02j
       4.64664675e+01+1.39605281e+00j  1.58312464e+00-5.64152261e+00j
      -5.91763217e-01-3.92804805e-01j -6.84026484e-02+5.01133341e-02j]
     [-1.67833262e+03-4.08886106e+02j  4.58527849e+01-3.25879138e+02j
       4.64664675e+01-1.39605281e+00j  1.58312464e+00+5.64152261e+00j
      -5.91763217e-01+3.92804805e-01j -6.84026484e-02-5.01133341e-02j]
     [ 3.91500426e+03-3.39530202e+03j -2.54280578e+02-7.14281333e+02j
      -7.31435090e+01-3.60982327e+01j -1.12641323e+01+1.16153418e+00j
      -1.14657024e+00+1.24940513e+00j  5.00478421e-03+2.32378488e-01j]
     [ 3.91500426e+03+3.39530202e+03j -2.54280578e+02+7.14281333e+02j
      -7.31435090e+01+3.60982327e+01j -1.12641323e+01-1.16153418e+00j
      -1.14657024e+00-1.24940513e+00j  5.00478421e-03-2.32378488e-01j]
     [ 2.23691029e+03-7.56707432e+03j -2.06537927e+02-6.74734693e+02j
      -2.71362070e+01-1.13065388e+02j -9.59340879e+00-1.35968568e+01j
      -1.64722755e+00-1.63064605e+00j -2.99924339e-01-1.70103156e-01j]
     [ 2.23691029e+03+7.56707432e+03j -2.06537927e+02+6.74734693e+02j
      -2.71362070e+01+1.13065388e+02j -9.59340879e+00+1.35968568e+01j
      -1.64722755e+00+1.63064605e+00j -2.99924339e-01+1.70103156e-01j]],
    f_b =
    [[ 1.67833262e+03-4.08886106e+02j  4.58527849e+01+3.25879138e+02j
      -4.64664675e+01-1.39605281e+00j  1.58312464e+00-5.64152261e+00j
       5.91763217e-01+3.92804805e-01j -6.84026484e-02+5.01133341e-02j]
     [ 1.67833262e+03+4.08886106e+02j  4.58527849e+01-3.25879138e+02j
      -4.64664675e+01+1.39605281e+00j  1.58312464e+00+5.64152261e+00j
       5.91763217e-01-3.92804805e-01j -6.84026484e-02-5.01133341e-02j]
     [ 3.91500426e+03-3.39530202e+03j  2.54280578e+02+7.14281333e+02j
      -7.31435090e+01-3.60982327e+01j  1.12641323e+01-1.16153418e+00j
      -1.14657024e+00+1.24940513e+00j -5.00478421e-03-2.32378488e-01j]
     [ 3.91500426e+03+3.39530202e+03j  2.54280578e+02-7.14281333e+02j
      -7.31435090e+01+3.60982327e+01j  1.12641323e+01+1.16153418e+00j
      -1.14657024e+00-1.24940513e+00j -5.00478421e-03+2.32378488e-01j]
     [-2.23691029e+03+7.56707432e+03j -2.06537927e+02-6.74734693e+02j
       2.71362070e+01+1.13065388e+02j -9.59340879e+00-1.35968568e+01j
       1.64722755e+00+1.63064605e+00j -2.99924339e-01-1.70103156e-01j]
     [-2.23691029e+03-7.56707432e+03j -2.06537927e+02+6.74734693e+02j
       2.71362070e+01-1.13065388e+02j -9.59340879e+00+1.35968568e+01j
       1.64722755e+00-1.63064605e+00j -2.99924339e-01+1.70103156e-01j]],
    b_b =
    [[-1.67833262e+03+4.08886106e+02j  4.58527849e+01+3.25879138e+02j
       4.64664675e+01+1.39605281e+00j  1.58312464e+00-5.64152261e+00j
      -5.91763217e-01-3.92804805e-01j -6.84026484e-02+5.01133341e-02j]
     [-1.67833262e+03-4.08886106e+02j  4.58527849e+01-3.25879138e+02j
       4.64664675e+01-1.39605281e+00j  1.58312464e+00+5.64152261e+00j
      -5.91763217e-01+3.92804805e-01j -6.84026484e-02-5.01133341e-02j]
     [ 3.91500426e+03-3.39530202e+03j -2.54280578e+02-7.14281333e+02j
      -7.31435090e+01-3.60982327e+01j -1.12641323e+01+1.16153418e+00j
      -1.14657024e+00+1.24940513e+00j  5.00478421e-03+2.32378488e-01j]
     [ 3.91500426e+03+3.39530202e+03j -2.54280578e+02+7.14281333e+02j
      -7.31435090e+01+3.60982327e+01j -1.12641323e+01-1.16153418e+00j
      -1.14657024e+00-1.24940513e+00j  5.00478421e-03-2.32378488e-01j]
     [ 2.23691029e+03-7.56707432e+03j -2.06537927e+02-6.74734693e+02j
      -2.71362070e+01-1.13065388e+02j -9.59340879e+00-1.35968568e+01j
      -1.64722755e+00-1.63064605e+00j -2.99924339e-01-1.70103156e-01j]
     [ 2.23691029e+03+7.56707432e+03j -2.06537927e+02+6.74734693e+02j
      -2.71362070e+01+1.13065388e+02j -9.59340879e+00+1.35968568e+01j
      -1.64722755e+00+1.63064605e+00j -2.99924339e-01+1.70103156e-01j]],
    f_w =
    [[ 1.67660131e-06-1.23031217e-06j  1.67660131e-06+1.23031217e-06j
       1.11435361e-06+4.10929466e-07j  1.11435361e-06-4.10929466e-07j
      -3.66037140e-07-8.81684085e-07j -3.66037140e-07+8.81684085e-07j]],
    and b_w =
    [[-1.67660131e-06+1.23031217e-06j -1.67660131e-06-1.23031217e-06j
       1.11435361e-06+4.10929466e-07j  1.11435361e-06-4.10929466e-07j
       3.66037140e-07+8.81684085e-07j  3.66037140e-07-8.81684085e-07j]].





.. GENERATED FROM PYTHON SOURCE LINES 250-257

Estimating (Filtering)
----------------------

Next we execute all simulation and estimation tasks by iterating over the
estimators. Note that since no stop criteria is set for either the analog
signal, the simulator, or the digital estimator this iteration could
potentially continue until the default stop criteria of 2^63 iterations.

.. GENERATED FROM PYTHON SOURCE LINES 257-270

.. code-block:: default


    # Set simulation length
    size = K2 << 4
    u_hat_batch = np.zeros(size)
    u_hat_fir = np.zeros(size)
    u_hat_iir = np.zeros(size)
    u_hat_parallel = np.zeros(size)
    for index in range(size):
        u_hat_batch[index] = next(digital_estimator_batch)
        u_hat_fir[index] = next(digital_estimator_fir)
        u_hat_iir[index] = next(digital_estimator_iir)
        u_hat_parallel[index] = next(digital_estimator_parallel)








.. GENERATED FROM PYTHON SOURCE LINES 271-276

Visualizing Results
-------------------

Finally, we summarize the comparision by visualizing the resulting estimate
in both time and frequency domain.

.. GENERATED FROM PYTHON SOURCE LINES 276-386

.. code-block:: default


    t = np.arange(size)
    # compensate the built in L1 delay of FIR filter.
    t_fir = np.arange(-L1 + 1, size - L1 + 1)
    t_iir = np.arange(-L1 + 1, size - L1 + 1)
    u = np.zeros_like(u_hat_batch)
    for index, tt in enumerate(t):
        u[index] = analog_signal.evaluate(tt * T)
    plt.plot(t, u_hat_batch, label="$\hat{u}(t)$ Batch")
    plt.plot(t_fir, u_hat_fir, label="$\hat{u}(t)$ FIR")
    plt.plot(t_iir, u_hat_iir, label="$\hat{u}(t)$ IIR")
    plt.plot(t, u_hat_parallel, label="$\hat{u}(t)$ Parallel")
    plt.plot(t, stf_at_omega * u, label="$\mathrm{STF}(2 \pi f_u) * u(t)$")
    plt.xlabel("$t / T$")
    plt.legend()
    plt.title("Estimated input signal")
    plt.grid(which="both")
    plt.xlim((-100, 500))
    plt.tight_layout()

    plt.figure()
    plt.plot(t, u_hat_batch, label="$\hat{u}(t)$ Batch")
    plt.plot(t_fir, u_hat_fir, label="$\hat{u}(t)$ FIR")
    plt.plot(t_iir, u_hat_iir, label="$\hat{u}(t)$ IIR")
    plt.plot(t, u_hat_parallel, label="$\hat{u}(t)$ Parallel")
    plt.plot(t, stf_at_omega * u, label="$\mathrm{STF}(2 \pi f_u) * u(t)$")
    plt.xlabel("$t / T$")
    plt.legend()
    plt.title("Estimated input signal")
    plt.grid(which="both")
    plt.xlim((t_fir[-1] - 50, t_fir[-1]))
    plt.tight_layout()

    plt.figure()
    plt.plot(t, u_hat_batch, label="$\hat{u}(t)$ Batch")
    plt.plot(t_fir, u_hat_fir, label="$\hat{u}(t)$ FIR")
    plt.plot(t_iir, u_hat_iir, label="$\hat{u}(t)$ IIR")
    plt.plot(t, u_hat_parallel, label="$\hat{u}(t)$ Parallel")
    plt.plot(t, stf_at_omega * u, label="$\mathrm{STF}(2 \pi f_u) * u(t)$")
    plt.xlabel("$t / T$")
    plt.legend()
    plt.title("Estimated input signal")
    plt.grid(which="both")
    # plt.xlim((t_fir[0], t[-1]))
    plt.xlim(((1 << 14) - 100, (1 << 14) + 100))
    plt.tight_layout()

    batch_error = stf_at_omega * u - u_hat_batch
    fir_error = stf_at_omega * u[: (u.size - L1 + 1)] - u_hat_fir[(L1 - 1) :]
    iir_error = stf_at_omega * u[: (u.size - L1 + 1)] - u_hat_iir[(L1 - 1) :]
    parallel_error = stf_at_omega * u - u_hat_parallel
    plt.figure()
    plt.plot(t, batch_error, label="$|\mathrm{STF}(2 \pi f_u) * u(t) - \hat{u}(t)|$ Batch")
    plt.plot(
        t[: (u.size - L1 + 1)],
        fir_error,
        label="$|\mathrm{STF}(2 \pi f_u) * u(t) - \hat{u}(t)|$ FIR",
    )
    plt.plot(
        t[: (u.size - L1 + 1)],
        iir_error,
        label="$|\mathrm{STF}(2 \pi f_u) * u(t) - \hat{u}(t)|$ IIR",
    )
    plt.plot(
        t, parallel_error, label="$|\mathrm{STF}(2 \pi f_u) * u(t) - \hat{u}(t)|$ Parallel"
    )
    plt.xlabel("$t / T$")
    plt.xlim(((1 << 14) - 100, (1 << 14) + 100))
    plt.ylim((-0.00001, 0.00001))
    plt.legend()
    plt.title("Estimation error")
    plt.grid(which="both")
    plt.tight_layout()


    print(f"Average Batch Error: {np.linalg.norm(batch_error) / batch_error.size}")
    print(f"Average FIR Error: {np.linalg.norm(fir_error) / fir_error.size}")
    print(f"Average IIR Error: {np.linalg.norm(iir_error) / iir_error.size}")
    print(
        f"""Average Parallel Error: { np.linalg.norm(parallel_error)/
        parallel_error.size}"""
    )

    plt.figure()
    u_hat_batch_clipped = u_hat_batch[(K1 + K2) : -K2]
    u_hat_fir_clipped = u_hat_fir[(L1 + L2) :]
    u_hat_iir_clipped = u_hat_iir[(K1 + K2) : -K2]
    u_hat_parallel_clipped = u_hat_parallel[(K1 + K2) : -K2]
    u_clipped = stf_at_omega * u
    f_batch, psd_batch = cbadc.utilities.compute_power_spectral_density(u_hat_batch_clipped)
    f_fir, psd_fir = cbadc.utilities.compute_power_spectral_density(u_hat_fir_clipped)
    f_iir, psd_iir = cbadc.utilities.compute_power_spectral_density(u_hat_iir_clipped)
    f_parallel, psd_parallel = cbadc.utilities.compute_power_spectral_density(
        u_hat_parallel_clipped
    )
    f_ref, psd_ref = cbadc.utilities.compute_power_spectral_density(u_clipped)
    plt.semilogx(f_ref, 10 * np.log10(psd_ref), label="$\mathrm{STF}(2 \pi f_u) * U(f)$")
    plt.semilogx(f_batch, 10 * np.log10(psd_batch), label="$\hat{U}(f)$ Batch")
    plt.semilogx(f_fir, 10 * np.log10(psd_fir), label="$\hat{U}(f)$ FIR")
    plt.semilogx(f_iir, 10 * np.log10(psd_iir), label="$\hat{U}(f)$ IIR")
    plt.semilogx(f_parallel, 10 * np.log10(psd_parallel), label="$\hat{U}(f)$ Parallel")
    plt.legend()
    plt.ylim((-200, 50))
    plt.xlim((f_fir[1], f_fir[-1]))
    plt.xlabel("frequency [Hz]")
    plt.ylabel("$ \mathrm{V}^2 \, / \, (1 \mathrm{Hz})$")
    plt.grid(which="both")
    # plt.show()





.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_003.png
         :alt: Estimated input signal
         :srcset: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_004.png
         :alt: Estimated input signal
         :srcset: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_005.png
         :alt: Estimated input signal
         :srcset: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_005.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_006.png
         :alt: Estimation error
         :srcset: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_006.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_007.png
         :alt: plot a compare estimator
         :srcset: /tutorials/b_general/images/sphx_glr_plot_a_compare_estimator_007.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1298: ComplexWarning: Casting complex values to real discards the imaginary part
      return np.asarray(x, float)
    /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1298: ComplexWarning: Casting complex values to real discards the imaginary part
      return np.asarray(x, float)
    /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1298: ComplexWarning: Casting complex values to real discards the imaginary part
      return np.asarray(x, float)
    /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1298: ComplexWarning: Casting complex values to real discards the imaginary part
      return np.asarray(x, float)
    /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1298: ComplexWarning: Casting complex values to real discards the imaginary part
      return np.asarray(x, float)
    /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1298: ComplexWarning: Casting complex values to real discards the imaginary part
      return np.asarray(x, float)
    /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/matplotlib/cbook/__init__.py:1298: ComplexWarning: Casting complex values to real discards the imaginary part
      return np.asarray(x, float)
    Average Batch Error: 9.590568804923317e-05
    Average FIR Error: 9.905907361046125e-05
    Average IIR Error: 9.905907355631982e-05
    Average Parallel Error: 9.590568804968417e-05
    /Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/scipy/signal/spectral.py:1816: UserWarning: Input data is complex, switching to return_onesided=False
      warnings.warn('Input data is complex, switching to '




.. GENERATED FROM PYTHON SOURCE LINES 387-391

Compute Time
------------

Compare the execution time of each estimator

.. GENERATED FROM PYTHON SOURCE LINES 391-460

.. code-block:: default



    def dummy_input_control_signal():
        while True:
            yield np.zeros(M, dtype=np.int8)


    def iterate_number_of_times(iterator, number_of_times):
        for _ in range(number_of_times):
            _ = next(iterator)


    digital_estimator_batch = cbadc.digital_estimator.BatchEstimator(
        analog_system, digital_control1, eta2, K1, K2
    )
    digital_estimator_fir = cbadc.digital_estimator.FIRFilter(
        analog_system, digital_control2, eta2, L1, L2
    )
    digital_estimator_parallel = cbadc.digital_estimator.ParallelEstimator(
        analog_system, digital_control4, eta2, K1, K2
    )
    digital_estimator_iir = cbadc.digital_estimator.IIRFilter(
        analog_system, digital_control3, eta2, L2
    )

    digital_estimator_batch(dummy_input_control_signal())
    digital_estimator_fir(dummy_input_control_signal())
    digital_estimator_parallel(dummy_input_control_signal())
    digital_estimator_iir(dummy_input_control_signal())

    length = 1 << 14
    repetitions = 10

    print("Batch Estimator:")
    print(
        timeit.timeit(
            lambda: iterate_number_of_times(digital_estimator_batch, length),
            number=repetitions,
        ),
        "sec \n",
    )

    print("FIR Estimator:")
    print(
        timeit.timeit(
            lambda: iterate_number_of_times(digital_estimator_fir, length),
            number=repetitions,
        ),
        "sec \n",
    )

    print("IIR Estimator:")
    print(
        timeit.timeit(
            lambda: iterate_number_of_times(digital_estimator_iir, length),
            number=repetitions,
        ),
        "sec \n",
    )

    print("Parallel Estimator:")
    print(
        timeit.timeit(
            lambda: iterate_number_of_times(digital_estimator_parallel, length),
            number=repetitions,
        ),
        "sec \n",
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Batch Estimator:
    3.212444458000391 sec

    FIR Estimator:
    5.967657999997755 sec

    IIR Estimator:
    4.486581749999459 sec

    Parallel Estimator:
    5.505970834001346 sec






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 2 minutes  15.108 seconds)


.. _sphx_glr_download_tutorials_b_general_plot_a_compare_estimator.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_a_compare_estimator.py <plot_a_compare_estimator.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_a_compare_estimator.ipynb <plot_a_compare_estimator.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
