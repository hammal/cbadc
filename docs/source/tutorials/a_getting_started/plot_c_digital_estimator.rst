
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/a_getting_started/plot_c_digital_estimator.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_tutorials_a_getting_started_plot_c_digital_estimator.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_a_getting_started_plot_c_digital_estimator.py:


Digital Estimation
===================

Converting a stream of control signals into a estimate samples.

.. GENERATED FROM PYTHON SOURCE LINES 7-11

.. code-block:: default

    import matplotlib.pyplot as plt
    import cbadc
    import numpy as np








.. GENERATED FROM PYTHON SOURCE LINES 12-24

Setting up the Analog System and Digital Control
------------------------------------------------

In this example, we assume that we have access to a control signal
s[k] generated by the interactions of an analog system and digital control.
Furthermore, we assume a chain-of-integrators converter with corresponding
analog system and digital control.

.. image:: /images/chainOfIntegratorsGeneral.svg
   :width: 500
   :align: center
   :alt: The chain of integrators ADC.

.. GENERATED FROM PYTHON SOURCE LINES 24-61

.. code-block:: default


    # Setup analog system and digital control

    N = 6
    M = N
    beta = 6250.0
    rho = -1e-2
    kappa = -1.0
    A = [
        [beta * rho, 0, 0, 0, 0, 0],
        [beta, beta * rho, 0, 0, 0, 0],
        [0, beta, beta * rho, 0, 0, 0],
        [0, 0, beta, beta * rho, 0, 0],
        [0, 0, 0, beta, beta * rho, 0],
        [0, 0, 0, 0, beta, beta * rho],
    ]
    B = [[beta], [0], [0], [0], [0], [0]]
    CT = np.eye(N)
    Gamma = [
        [kappa * beta, 0, 0, 0, 0, 0],
        [0, kappa * beta, 0, 0, 0, 0],
        [0, 0, kappa * beta, 0, 0, 0],
        [0, 0, 0, kappa * beta, 0, 0],
        [0, 0, 0, 0, kappa * beta, 0],
        [0, 0, 0, 0, 0, kappa * beta],
    ]
    Gamma_tildeT = np.eye(N)
    T = 1.0 / (2 * beta)
    clock = cbadc.analog_signal.Clock(T)

    analog_system = cbadc.analog_system.AnalogSystem(A, B, CT, Gamma, Gamma_tildeT)
    digital_control = cbadc.digital_control.DigitalControl(clock, M)

    # Summarize the analog system, digital control, and digital estimator.
    print(analog_system, "\n")
    print(digital_control)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[-6.25e+01  0.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 6.25e+03 -6.25e+01  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  6.25e+03 -6.25e+01  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  6.25e+03 -6.25e+01  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  6.25e+03 -6.25e+01  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  6.25e+03 -6.25e+01]],
    B =
    [[ 6.25e+03]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]],
<<<<<<< HEAD
    CT = 
=======
    CT =
>>>>>>> origin/develop
    [[ 1.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  1.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  1.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  1.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  1.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00  1.00e+00]],
    Gamma =
    [[-6.25e+03  0.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00 -6.25e+03  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00 -6.25e+03  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00 -6.25e+03  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00 -6.25e+03  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00 -6.25e+03]],
    Gamma_tildeT =
    [[ 1.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  1.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  1.00e+00  0.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  1.00e+00  0.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  1.00e+00  0.00e+00]
     [ 0.00e+00  0.00e+00  0.00e+00  0.00e+00  0.00e+00  1.00e+00]], and D=[[ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
     [ 0.00e+00]
<<<<<<< HEAD
     [ 0.00e+00]] 
=======
     [ 0.00e+00]]
>>>>>>> origin/develop

    ================================================================================

    The Digital Control is parameterized as:

    --------------------------------------------------------------------------------

    clock:
    Analog signal returns constant 0, i.e., maps t |-> 0.

    M:
    6
    ================================================================================
        




.. GENERATED FROM PYTHON SOURCE LINES 62-69

Creating a Placehold Control Signal
-----------------------------------

We could, of course, simulate the analog system and digital control above
for a given analog signal. However, this might not always be the use case;
instead, imagine we have acquired such a control signal from a previous
simulation or possibly obtained it from a hardware implementation.

.. GENERATED FROM PYTHON SOURCE LINES 69-97

.. code-block:: default


    # In principle, we can create a dummy generator by just


    def dummy_control_sequence_signal():
        while True:
            yield np.zeros(M, dtype=np.int8)


    # and then pass dummy_control_sequence_signal as the control_sequence
    # to the digital estimator.


    # Another way would be to use a random control signal. Such a generator
    # is already provided in the :func:`cbadc.utilities.random_control_signal`
    # function. Subsequently, a random (random 1-0 valued M tuples) control signal
    # of length

    sequence_length = 10

    # can conveniently be created as

    control_signal_sequences = cbadc.utilities.random_control_signal(
        M, stop_after_number_of_iterations=sequence_length, random_seed=42
    )

    # where random_seed and stop_after_number_of_iterations are fully optional








.. GENERATED FROM PYTHON SOURCE LINES 98-106

Setting up the Filter
------------------------------------

To produce estimates we need to compute the filter coefficients of the
digital estimator. This is part of the instantiation process of the
BatchEstimator class. However, these computations require us to
specify both the analog system, the digital control and the filter parameters
such as eta2, the batch size K1, and possible the lookahead K2.

.. GENERATED FROM PYTHON SOURCE LINES 106-127

.. code-block:: default


    # Set the bandwidth of the estimator

    eta2 = 1e7

    # Set the batch size

    K1 = sequence_length

    # Instantiate the digital estimator (this is where the filter coefficients are
    # computed).

    digital_estimator = cbadc.digital_estimator.BatchEstimator(
        analog_system, digital_control, eta2, K1
    )

    print(digital_estimator, "\n")

    # Set control signal iterator
    digital_estimator(control_signal_sequences)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Digital estimator is parameterized as
        
    eta2 = 10000000.00, 70 [dB],
        
    Ts = 8e-05,
    K1 = 10,
    K2 = 0,
        
    and
    number_of_iterations = 9223372036854775808
        
    Resulting in the filter coefficients
<<<<<<< HEAD
    Af = 
=======
    Af =
>>>>>>> origin/develop
    [[ 9.95e-01 -1.07e-05 -3.30e-05 -7.22e-05 -1.00e-04 -6.09e-05]
     [ 4.97e-01  9.95e-01 -3.95e-04 -9.36e-04 -1.40e-03 -9.46e-04]
     [ 1.24e-01  4.97e-01  9.93e-01 -6.12e-03 -9.88e-03 -7.42e-03]
     [ 2.03e-02  1.22e-01  4.88e-01  9.70e-01 -4.41e-02 -3.76e-02]
     [ 1.57e-03  1.52e-02  1.02e-01  4.32e-01  8.65e-01 -1.32e-01]
     [-8.48e-04 -3.79e-03 -7.66e-03  2.91e-02  2.70e-01  6.77e-01]],
<<<<<<< HEAD
        
    Ab = 
=======

    Ab =
>>>>>>> origin/develop
    [[ 1.01e+00  1.55e-05 -4.75e-05  1.01e-04 -1.32e-04  7.07e-05]
     [-5.02e-01  1.00e+00  5.74e-04 -1.32e-03  1.86e-03 -1.11e-03]
     [ 1.25e-01 -5.02e-01  1.00e+00  8.51e-03 -1.29e-02  8.68e-03]
     [-2.03e-02  1.22e-01 -4.90e-01  9.71e-01  5.61e-02 -4.33e-02]
     [ 1.24e-03 -1.36e-02  9.62e-02 -4.19e-01  8.48e-01  1.47e-01]
     [ 1.07e-03 -4.99e-03  1.24e-02  1.63e-02 -2.49e-01  6.64e-01]],
<<<<<<< HEAD
        
    Bf = 
=======

    Bf =
>>>>>>> origin/develop
    [[-4.99e-01  2.01e-06  6.83e-06  1.63e-05  2.47e-05  1.69e-05]
     [-1.25e-01 -4.99e-01  8.01e-05  2.09e-04  3.43e-04  2.60e-04]
     [-2.07e-02 -1.24e-01 -4.98e-01  1.35e-03  2.39e-03  2.02e-03]
     [-2.52e-03 -2.03e-02 -1.23e-01 -4.93e-01  1.06e-02  1.01e-02]
     [-1.13e-04 -1.66e-03 -1.65e-02 -1.11e-01 -4.68e-01  3.49e-02]
     [ 1.30e-04  7.67e-04  2.57e-03 -1.50e-03 -7.34e-02 -4.16e-01]],
<<<<<<< HEAD
        
    Bb = 
=======

    Bb =
>>>>>>> origin/develop
    [[ 5.01e-01  2.91e-06 -9.87e-06  2.30e-05 -3.29e-05  2.00e-05]
     [-1.25e-01  5.01e-01  1.17e-04 -2.96e-04  4.59e-04 -3.10e-04]
     [ 2.09e-02 -1.25e-01  5.01e-01  1.89e-03 -3.16e-03  2.39e-03]
     [-2.51e-03  2.03e-02 -1.23e-01  4.94e-01  1.36e-02 -1.17e-02]
     [ 6.36e-05 -1.37e-03  1.53e-02 -1.08e-01  4.64e-01  3.93e-02]
     [ 1.62e-04 -9.68e-04  3.50e-03 -1.35e-03 -6.82e-02  4.13e-01]],
<<<<<<< HEAD
        
    and WT = 
    [[ 8.45e-02  8.45e-04 -2.13e-03 -6.41e-05  1.07e-04  5.04e-06]]. 
=======

    and WT =
    [[ 8.45e-02  8.45e-04 -2.13e-03 -6.41e-05  1.07e-04  5.04e-06]].
>>>>>>> origin/develop





.. GENERATED FROM PYTHON SOURCE LINES 128-132

Producing Estimates
-------------------

At this point, we can produce estimates by simply calling the iterator

.. GENERATED FROM PYTHON SOURCE LINES 132-137

.. code-block:: default


    for i in digital_estimator:
        print(i)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [-1.95e-01]
    [-1.93e-01]
    [-1.90e-01]
    [-1.85e-01]
    [-1.79e-01]
    [-1.72e-01]
    [-1.64e-01]
    [-1.54e-01]
    [-1.44e-01]
    [-1.33e-01]




.. GENERATED FROM PYTHON SOURCE LINES 138-142

Batch Size and Lookahead
------------------------

Note that batch and lookahead sizes are automatically handled such that for

.. GENERATED FROM PYTHON SOURCE LINES 142-161

.. code-block:: default

    K1 = 5
    K2 = 1
    sequence_length = 11
    control_signal_sequences = cbadc.utilities.random_control_signal(
        M, stop_after_number_of_iterations=sequence_length, random_seed=42
    )
    digital_estimator = cbadc.digital_estimator.BatchEstimator(
        analog_system, digital_control, eta2, K1, K2
    )

    # Set control signal iterator
    digital_estimator(control_signal_sequences)

    # The iterator is still called the same way.
    for i in digital_estimator:
        print(i)
    # However, this time this iterator involves computing two batches each
    # involving a lookahead of size one.





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [-2.50e-01]
    [-2.53e-01]
    [-2.54e-01]
    [-2.53e-01]
    [-2.51e-01]
    [-1.38e-01]
    [-1.28e-01]
    [-1.17e-01]
    [-1.06e-01]
    [-9.39e-02]




.. GENERATED FROM PYTHON SOURCE LINES 162-173

Loading Control Signal from File
--------------------------------

Next, we will load an actual control signal to demonstrate the digital
estimator's capabilities. To this end, we will use the
`sinusoidal_simulation.dat` file that was produced in
:doc:`./plot_b_simulate_a_control_bounded_adc`.

The control signal file is encoded as raw binary data so to unpack it
correctly we will use the :func:`cbadc.utilities.read_byte_stream_from_file`
and :func:`cbadc.utilities.byte_stream_2_control_signal` functions.

.. GENERATED FROM PYTHON SOURCE LINES 173-177

.. code-block:: default


    byte_stream = cbadc.utilities.read_byte_stream_from_file("sinusoidal_simulation.dat", M)
    control_signal_sequences = cbadc.utilities.byte_stream_2_control_signal(byte_stream, M)








.. GENERATED FROM PYTHON SOURCE LINES 178-184

Estimating the input
--------------------

Fortunately, we used the same
analog system and digital controls as in this example so


.. GENERATED FROM PYTHON SOURCE LINES 184-212

.. code-block:: default


    stop_after_number_of_iterations = 1 << 17
    u_hat = np.zeros(stop_after_number_of_iterations)
    K1 = 1 << 10
    K2 = 1 << 11
    digital_estimator = cbadc.digital_estimator.BatchEstimator(
        analog_system,
        digital_control,
        eta2,
        K1,
        K2,
        stop_after_number_of_iterations=stop_after_number_of_iterations,
    )
    # Set control signal iterator
    digital_estimator(control_signal_sequences)
    for index, u_hat_temp in enumerate(digital_estimator):
        u_hat[index] = u_hat_temp

    t = np.arange(u_hat.size)
    plt.plot(t, u_hat)
    plt.xlabel("$t / T$")
    plt.ylabel("$\hat{u}(t)$")
    plt.title("Estimated input signal")
    plt.grid()
    plt.xlim((0, 1500))
    plt.ylim((-1, 1))
    plt.tight_layout()




.. image-sg:: /tutorials/a_getting_started/images/sphx_glr_plot_c_digital_estimator_001.png
   :alt: Estimated input signal
   :srcset: /tutorials/a_getting_started/images/sphx_glr_plot_c_digital_estimator_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 213-218

Plotting the PSD
----------------

As is typical for delta-sigma modulators, we often visualize the performance
of the estimate by plotting the power spectral density (PSD).

.. GENERATED FROM PYTHON SOURCE LINES 218-226

.. code-block:: default


    f, psd = cbadc.utilities.compute_power_spectral_density(u_hat[K2:])
    plt.figure()
    plt.semilogx(f, 10 * np.log10(psd))
    plt.xlabel("frequency [Hz]")
    plt.ylabel("$ \mathrm{V}^2 \, / \, \mathrm{Hz}$")
    plt.xlim((f[1], f[-1]))
    plt.grid(which="both")



.. image-sg:: /tutorials/a_getting_started/images/sphx_glr_plot_c_digital_estimator_002.png
   :alt: plot c digital estimator
   :srcset: /tutorials/a_getting_started/images/sphx_glr_plot_c_digital_estimator_002.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

<<<<<<< HEAD
   **Total running time of the script:** ( 0 minutes  23.511 seconds)
=======
   **Total running time of the script:** ( 0 minutes  22.805 seconds)
>>>>>>> origin/develop


.. _sphx_glr_download_tutorials_a_getting_started_plot_c_digital_estimator.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_c_digital_estimator.py <plot_c_digital_estimator.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_c_digital_estimator.ipynb <plot_c_digital_estimator.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
