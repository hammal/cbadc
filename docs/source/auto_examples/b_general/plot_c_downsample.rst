
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/b_general/plot_c_downsample.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_b_general_plot_c_downsample.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_b_general_plot_c_downsample.py:


=============
Downsampling
=============

In this tutorial we demonstrate how to configure the digital estimator
for downsampling.

.. GENERATED FROM PYTHON SOURCE LINES 9-18

.. code-block:: default
   :lineno-start: 9

    import numpy as np
    from cbadc.digital_control import DigitalControl
    from cbadc.analog_system import AnalogSystem
    from cbadc.utilities import compute_power_spectral_density
    import matplotlib.pyplot as plt
    from cbadc.digital_estimator import FIRFilter
    from cbadc.utilities import read_byte_stream_from_file, \
        byte_stream_2_control_signal








.. GENERATED FROM PYTHON SOURCE LINES 19-31

Setting up the Analog System and Digital Control
------------------------------------------------

In this example, we assume that we have access to a control signal
s[k] generated by the interactions of an analog system and digital control.
Furthermore, we a chain-of-integrators converter with corresponding
analog system and digital control.

.. image:: /images/chainOfIntegratorsGeneral.svg
   :width: 500
   :align: center
   :alt: The chain of integrators ADC.

.. GENERATED FROM PYTHON SOURCE LINES 31-63

.. code-block:: default
   :lineno-start: 32


    # Setup analog system and digital control

    N = 6
    M = N
    beta = 6250.
    rho = - beta * 1e-2
    A = [[rho, 0, 0, 0, 0, 0],
         [beta, rho, 0, 0, 0, 0],
         [0, beta, rho, 0, 0, 0],
         [0, 0, beta, rho, 0, 0],
         [0, 0, 0, beta, rho, 0],
         [0, 0, 0, 0, beta, rho]]
    B = [[beta], [0], [0], [0], [0], [0]]
    CT = np.eye(N)
    Gamma = [[-beta, 0, 0, 0, 0, 0],
             [0, -beta, 0, 0, 0, 0],
             [0, 0, -beta, 0, 0, 0],
             [0, 0, 0, -beta, 0, 0],
             [0, 0, 0, 0, -beta, 0],
             [0, 0, 0, 0, 0, -beta]]
    Gamma_tildeT = np.eye(N)
    T = 1.0/(2 * beta)

    analog_system = AnalogSystem(A, B, CT, Gamma, Gamma_tildeT)
    digital_control = DigitalControl(T, M)

    # Summarize the analog system, digital control, and digital estimator.
    print(analog_system, "\n")
    print(digital_control)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ -62.5    0.     0.     0.     0.     0. ]
     [6250.   -62.5    0.     0.     0.     0. ]
     [   0.  6250.   -62.5    0.     0.     0. ]
     [   0.     0.  6250.   -62.5    0.     0. ]
     [   0.     0.     0.  6250.   -62.5    0. ]
     [   0.     0.     0.     0.  6250.   -62.5]],
    B =
    [[6250.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]],
    CT = 
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[-6250.     0.     0.     0.     0.     0.]
     [    0. -6250.     0.     0.     0.     0.]
     [    0.     0. -6250.     0.     0.     0.]
     [    0.     0.     0. -6250.     0.     0.]
     [    0.     0.     0.     0. -6250.     0.]
     [    0.     0.     0.     0.     0. -6250.]],
    and Gamma_tildeT =
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]] 

    The Digital Control is parameterized as:
    T = 8e-05,
    M = 6, and next update at
    t = 8e-05




.. GENERATED FROM PYTHON SOURCE LINES 64-75

Loading Control Signal from File
--------------------------------

Next, we will load an actual control signal to demonstrate the digital
estimator's capabilities. To this end, we will use the
`sinusodial_simulation.adc` file that was produced in
:doc:`./plot_b_simulate_a_control_bounded_adc`.

The control signal file is encoded as raw binary data so to unpack it
correctly we will use the :func:`cbadc.utilities.read_byte_stream_from_file`
and :func:`cbadc.utilities.byte_stream_2_control_signal` functions.

.. GENERATED FROM PYTHON SOURCE LINES 75-84

.. code-block:: default
   :lineno-start: 76


    byte_stream = read_byte_stream_from_file(
        '../a_getting_started/sinusodial_simulation.adc', M)
    control_signal_sequences1 = byte_stream_2_control_signal(byte_stream, M)

    byte_stream = read_byte_stream_from_file(
        '../a_getting_started/sinusodial_simulation.adc', M)
    control_signal_sequences2 = byte_stream_2_control_signal(byte_stream, M)








.. GENERATED FROM PYTHON SOURCE LINES 85-88

Oversampling
-------------


.. GENERATED FROM PYTHON SOURCE LINES 88-94

.. code-block:: default
   :lineno-start: 89


    OSR = 64

    omega_3dB = 2 * np.pi / (2 * T * OSR)









.. GENERATED FROM PYTHON SOURCE LINES 95-100

Oversampling = 1
----------------------------------------

First we initialize our default estimator without a downsampling parameter
which then defaults to 1, i.e., no downsampling.

.. GENERATED FROM PYTHON SOURCE LINES 100-118

.. code-block:: default
   :lineno-start: 101


    # Set the bandwidth of the estimator
    G_at_omega = np.linalg.norm(
        analog_system.transfer_function_matrix(np.array([omega_3dB])))
    eta2 = G_at_omega**2
    print(f"eta2 = {eta2}, {10 * np.log10(eta2)} [dB]")

    # Set the filter size
    L1 = 1 << 13
    L2 = L1

    # Instantiate the digital estimator.
    digital_estimator_ref = FIRFilter(
        control_signal_sequences1, analog_system, digital_control, eta2, L1, L2)

    print(digital_estimator_ref, "\n")






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    eta2 = 1184008941499.196, 120.73354982141205 [dB]
    FIR estimator is parameterized as 
    eta2 = 1184008941499.20, 121 [dB],
    Ts = 8e-05,
    K1 = 8192,
    K2 = 8192,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    h = 
    [[[-1.27932876e-48  1.00769090e-49  8.64918371e-51 -1.20240032e-51
       -4.21095945e-53  1.23128625e-53]]

     [[-1.33526689e-48  9.67777885e-50  9.29120268e-51 -1.18571015e-51
       -4.85629949e-53  1.23580556e-53]]

     [[-1.38939947e-48  9.24460942e-50  9.92724126e-51 -1.16568837e-51
       -5.50658105e-53  1.23742323e-53]]

     ...

     [[-1.38939371e-48 -1.20231718e-49  5.67374649e-51  1.63925652e-51
        5.88237654e-53 -1.25707358e-53]]

     [[-1.33526227e-48 -1.23480805e-49  4.88610173e-51  1.61635208e-51
        6.52723378e-53 -1.18830922e-53]]

     [[-1.27932527e-48 -1.26353393e-49  4.10681403e-51  1.59018015e-51
        7.14018077e-53 -1.11846062e-53]]]. 





.. GENERATED FROM PYTHON SOURCE LINES 119-122

Visualize Estimator's Transfer Function
---------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 122-156

.. code-block:: default
   :lineno-start: 123


    # Logspace frequencies
    frequencies = np.logspace(-3, 0, 100)
    omega = 4 * np.pi * beta * frequencies

    # Compute NTF
    ntf = digital_estimator_ref.noise_transfer_function(omega)
    ntf_dB = 20 * np.log10(np.abs(ntf))

    # Compute STF
    stf = digital_estimator_ref.signal_transfer_function(omega)
    stf_dB = 20 * np.log10(np.abs(stf.flatten()))

    # Signal attenuation at the input signal frequency
    stf_at_omega = digital_estimator_ref.signal_transfer_function(
        np.array([omega_3dB]))[0]

    # Plot
    plt.figure()
    plt.semilogx(frequencies, stf_dB, label='$STF(\omega)$')
    for n in range(N):
        plt.semilogx(frequencies, ntf_dB[0, n, :], label=f"$|NTF_{n+1}(\omega)|$")
    plt.semilogx(frequencies, 20 * np.log10(np.linalg.norm(
        ntf[0, :, :], axis=0)), '--', label="$ || NTF(\omega) ||_2 $")

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which='both')
    plt.title("Signal and noise transfer functions")
    plt.xlabel("$\omega / (4 \pi \\beta ) $")
    plt.ylabel("dB")
    plt.xlim((frequencies[1], frequencies[-1]))
    plt.gcf().tight_layout()




.. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_001.png
    :alt: Signal and noise transfer functions
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 157-161

FIR Filter With Downsampling
----------------------------

Next we repeat the initialization steps above but for a downsampled estimator

.. GENERATED FROM PYTHON SOURCE LINES 161-173

.. code-block:: default
   :lineno-start: 162


    digital_estimator_dow = FIRFilter(
        control_signal_sequences2,
        analog_system,
        digital_control,
        eta2,
        L1,
        L2,
        downsample=OSR)

    print(digital_estimator_dow, "\n")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    FIR estimator is parameterized as 
    eta2 = 1184008941499.20, 121 [dB],
    Ts = 8e-05,
    K1 = 8192,
    K2 = 8192,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    h = 
    [[[-1.27932876e-48  1.00769090e-49  8.64918371e-51 -1.20240032e-51
       -4.21095945e-53  1.23128625e-53]]

     [[-1.33526689e-48  9.67777885e-50  9.29120268e-51 -1.18571015e-51
       -4.85629949e-53  1.23580556e-53]]

     [[-1.38939947e-48  9.24460942e-50  9.92724126e-51 -1.16568837e-51
       -5.50658105e-53  1.23742323e-53]]

     ...

     [[-1.38939371e-48 -1.20231718e-49  5.67374649e-51  1.63925652e-51
        5.88237654e-53 -1.25707358e-53]]

     [[-1.33526227e-48 -1.23480805e-49  4.88610173e-51  1.61635208e-51
        6.52723378e-53 -1.18830922e-53]]

     [[-1.27932527e-48 -1.26353393e-49  4.10681403e-51  1.59018015e-51
        7.14018077e-53 -1.11846062e-53]]]. 





.. GENERATED FROM PYTHON SOURCE LINES 174-177

Estimating (Filtering)
----------------------


.. GENERATED FROM PYTHON SOURCE LINES 177-187

.. code-block:: default
   :lineno-start: 178


    # Set simulation length
    size = L2 << 4
    u_hat_ref = np.zeros(size)
    u_hat_dow = np.zeros(size // OSR)
    for index in range(size):
        u_hat_ref[index] = next(digital_estimator_ref)
    for index in range(size // OSR):
        u_hat_dow[index] = next(digital_estimator_dow)








.. GENERATED FROM PYTHON SOURCE LINES 188-193

Visualizing Results
-------------------

Finally, we summarize the comparision by visualizing the resulting estimate
in both time and frequency domain.

.. GENERATED FROM PYTHON SOURCE LINES 193-223

.. code-block:: default
   :lineno-start: 194


    # compensate the built in L1 delay of FIR filter.
    t = np.arange(-L1 + 1, size - L1 + 1)
    t_down = np.arange(-(L1) // OSR, (size - L1) // OSR) * OSR + 1
    plt.plot(t, u_hat_ref, label="$\hat{u}(t)$ Reference")
    plt.plot(t_down, u_hat_dow, label="$\hat{u}(t)$ Downsampled")
    plt.xlabel('$t / T$')
    plt.legend()
    plt.title("Estimated input signal")
    plt.grid(which='both')
    plt.xlim((-50, 1000))
    plt.tight_layout()

    plt.figure()
    u_hat_ref_clipped = u_hat_ref[(L1 + L2):]
    u_hat_dow_clipped = u_hat_dow[(L1 + L2) // OSR:]
    f_ref, psd_ref = compute_power_spectral_density(
        u_hat_ref_clipped)
    f_dow, psd_dow = compute_power_spectral_density(
        u_hat_dow_clipped, fs=1.0/OSR)
    plt.semilogx(f_ref, 10 * np.log10(psd_ref), label="$\hat{U}(f)$ Referefence")
    plt.semilogx(f_dow, 10 * np.log10(psd_dow), label="$\hat{U}(f)$ Downsampled")
    plt.legend()
    plt.ylim((-200, 50))
    plt.xlim((f_ref[1], f_ref[-1]))
    plt.xlabel('frequency [Hz]')
    plt.ylabel('$ \mathrm{V}^2 \, / \, (1 \mathrm{Hz})$')
    plt.grid(which='both')
    plt.show()




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_002.png
          :alt: Estimated input signal
          :class: sphx-glr-multi-img

    *

      .. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_003.png
          :alt: plot c downsample
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/scipy/signal/spectral.py:1961: UserWarning: nperseg = 16384 is greater than input length  = 1792, using nperseg = 1792
      warnings.warn('nperseg = {0:d} is greater than input length '





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  32.825 seconds)


.. _sphx_glr_download_auto_examples_b_general_plot_c_downsample.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_c_downsample.py <plot_c_downsample.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_c_downsample.ipynb <plot_c_downsample.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
