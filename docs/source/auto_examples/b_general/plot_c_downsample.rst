
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/b_general/plot_c_downsample.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_b_general_plot_c_downsample.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_b_general_plot_c_downsample.py:


=============
Downsampling
=============

In this tutorial we demonstrate how to configure the digital estimator
for downsampling.

.. GENERATED FROM PYTHON SOURCE LINES 11-23

Setting up the Analog System and Digital Control
------------------------------------------------

In this example, we assume that we have access to a control signal
s[k] generated by the interactions of an analog system and digital control.
Furthermore, we a chain-of-integrators converter with corresponding
analog system and digital control.

.. image:: /images/chainOfIntegratorsGeneral.svg
   :width: 500
   :align: center
   :alt: The chain of integrators ADC.

.. GENERATED FROM PYTHON SOURCE LINES 23-58

.. code-block:: default
   :lineno-start: 24


    # Setup analog system and digital control
    from cbadc.analog_system import AnalogSystem
    from cbadc.digital_control import DigitalControl
    import numpy as np

    N = 6
    M = N
    beta = 6250.
    rho = - beta * 1e-2
    A = [[rho, 0, 0, 0, 0, 0],
         [beta, rho, 0, 0, 0, 0],
         [0, beta, rho, 0, 0, 0],
         [0, 0, beta, rho, 0, 0],
         [0, 0, 0, beta, rho, 0],
         [0, 0, 0, 0, beta, rho]]
    B = [[beta], [0], [0], [0], [0], [0]]
    CT = np.eye(N)
    Gamma = [[-beta, 0, 0, 0, 0, 0],
             [0, -beta, 0, 0, 0, 0],
             [0, 0, -beta, 0, 0, 0],
             [0, 0, 0, -beta, 0, 0],
             [0, 0, 0, 0, -beta, 0],
             [0, 0, 0, 0, 0, -beta]]
    Gamma_tildeT = np.eye(N)
    T = 1.0/(2 * beta)

    analog_system = AnalogSystem(A, B, CT, Gamma, Gamma_tildeT)
    digital_control = DigitalControl(T, M)

    # Summarize the analog system, digital control, and digital estimator.
    print(analog_system, "\n")
    print(digital_control)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ -62.5    0.     0.     0.     0.     0. ]
     [6250.   -62.5    0.     0.     0.     0. ]
     [   0.  6250.   -62.5    0.     0.     0. ]
     [   0.     0.  6250.   -62.5    0.     0. ]
     [   0.     0.     0.  6250.   -62.5    0. ]
     [   0.     0.     0.     0.  6250.   -62.5]],
    B =
    [[6250.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]],
    CT = 
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[-6250.     0.     0.     0.     0.     0.]
     [    0. -6250.     0.     0.     0.     0.]
     [    0.     0. -6250.     0.     0.     0.]
     [    0.     0.     0. -6250.     0.     0.]
     [    0.     0.     0.     0. -6250.     0.]
     [    0.     0.     0.     0.     0. -6250.]],
    and Gamma_tildeT =
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]] 

    The Digital Control is parameterized as:
    T = 8e-05,
    M = 6, and next update at
    t = 8e-05




.. GENERATED FROM PYTHON SOURCE LINES 59-70

Loading Control Signal from File
--------------------------------

Next, we will load an actual control signal to demonstrate the digital
estimator's capabilities. To this end, we will use the
`sinusodial_simulation.adc` file that was produced in
:doc:`./plot_b_simulate_a_control_bounded_adc`.

The control signal file is encoded as raw binary data so to unpack it
correctly we will use the :func:`cbadc.utilities.read_byte_stream_from_file`
and :func:`cbadc.utilities.byte_stream_2_control_signal` functions.

.. GENERATED FROM PYTHON SOURCE LINES 70-80

.. code-block:: default
   :lineno-start: 70

    from cbadc.utilities import read_byte_stream_from_file, byte_stream_2_control_signal

    byte_stream = read_byte_stream_from_file(
        '../a_getting_started/sinusodial_simulation.adc', M)
    control_signal_sequences1 = byte_stream_2_control_signal(byte_stream, M)

    byte_stream = read_byte_stream_from_file(
        '../a_getting_started/sinusodial_simulation.adc', M)
    control_signal_sequences2 = byte_stream_2_control_signal(byte_stream, M)








.. GENERATED FROM PYTHON SOURCE LINES 81-84

Oversampling
-------------


.. GENERATED FROM PYTHON SOURCE LINES 84-90

.. code-block:: default
   :lineno-start: 85


    OSR = 64

    omega_3dB = 2 * np.pi / (2 * T * OSR)









.. GENERATED FROM PYTHON SOURCE LINES 91-96

Oversampling = 1
----------------------------------------

First we initialize our default estimator without a downsampling parameter
which then defaults to 1, i.e., no downsampling.

.. GENERATED FROM PYTHON SOURCE LINES 96-115

.. code-block:: default
   :lineno-start: 96

    from cbadc.digital_estimator import FIRFilter

    # Set the bandwidth of the estimator
    G_at_omega = np.linalg.norm(
        analog_system.transfer_function_matrix(np.array([omega_3dB])))
    eta2 = G_at_omega**2
    print(f"eta2 = {eta2}, {10 * np.log10(eta2)} [dB]")

    # Set the filter size
    L1 = 1 << 13
    L2 = L1

    # Instantiate the digital estimator.
    digital_estimator_ref = FIRFilter(
        control_signal_sequences1, analog_system, digital_control, eta2, L1, L2)

    print(digital_estimator_ref, "\n")






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    eta2 = 1184008941499.196, 120.73354982141205 [dB]
    [[-6.25000001e+01 -2.43204273e-06 -2.85647441e-05 -2.35173302e-04
      -1.28193300e-03 -3.66815487e-03]
     [ 6.25000000e+03 -6.25000607e+01 -8.48160782e-04 -7.79552505e-03
      -4.62928338e-02 -1.43569969e-01]
     [-2.85647441e-05  6.24999915e+03 -6.25132365e+01 -1.32421278e-01
      -8.49361824e-01 -2.86501699e+00]
     [-2.35173302e-04 -7.79552505e-03  6.24986758e+03 -6.39297005e+01
      -9.93225363e+00 -3.70923440e+01]
     [-1.28193300e-03 -4.62928338e-02 -8.49361824e-01  6.24006775e+03
      -1.38528479e+02 -3.29802817e+02]
     [-3.66815487e-03 -1.43569969e-01 -2.86501699e+00 -3.70923440e+01
       5.92019718e+03 -2.00406765e+03]] [[-6.24999997e+01 -6.73216835e-06  8.56115846e-05 -6.90821849e-04
       3.37066838e-03 -7.73727897e-03]
     [ 6.24999999e+03 -6.24998120e+01 -2.69606755e-03  2.36258836e-02
      -1.23501668e-01  3.03035896e-01]
     [ 8.56115846e-05  6.24999730e+03 -6.24580101e+01 -3.94286880e-01
       2.20438687e+00 -5.82520597e+00]
     [-6.90821849e-04  2.36258836e-02  6.24960571e+03 -5.85385365e+01
      -2.38932760e+01  6.95487643e+01]
     [ 3.37066838e-03 -1.23501668e-01  2.20438687e+00  6.22610672e+03
       9.67249284e+01 -5.40962751e+02]
     [-7.73727897e-03  3.03035896e-01 -5.82520597e+00  6.95487643e+01
       5.70903725e+03  2.54331050e+03]]
    FIR estimator is parameterized as 
    eta2 = 1184008941499.20, 121 [dB],
    Ts = 8e-05,
    K1 = 8192,
    K2 = 8192,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    h = 
    [[[-1.27932876e-48  1.00769090e-49  8.64918371e-51 -1.20240032e-51
       -4.21095945e-53  1.23128625e-53]]

     [[-1.33526689e-48  9.67777885e-50  9.29120268e-51 -1.18571015e-51
       -4.85629949e-53  1.23580556e-53]]

     [[-1.38939947e-48  9.24460942e-50  9.92724126e-51 -1.16568837e-51
       -5.50658105e-53  1.23742323e-53]]

     ...

     [[-1.38939371e-48 -1.20231718e-49  5.67374649e-51  1.63925652e-51
        5.88237654e-53 -1.25707358e-53]]

     [[-1.33526227e-48 -1.23480805e-49  4.88610173e-51  1.61635208e-51
        6.52723378e-53 -1.18830922e-53]]

     [[-1.27932527e-48 -1.26353393e-49  4.10681403e-51  1.59018015e-51
        7.14018077e-53 -1.11846062e-53]]]. 





.. GENERATED FROM PYTHON SOURCE LINES 116-119

Visualize Estimator's Transfer Function
---------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 119-154

.. code-block:: default
   :lineno-start: 119

    import matplotlib.pyplot as plt

    # Logspace frequencies
    frequencies = np.logspace(-3, 0, 100)
    omega = 4 * np.pi * beta * frequencies

    # Compute NTF
    ntf = digital_estimator_ref.noise_transfer_function(omega)
    ntf_dB = 20 * np.log10(np.abs(ntf))

    # Compute STF
    stf = digital_estimator_ref.signal_transfer_function(omega)
    stf_dB = 20 * np.log10(np.abs(stf.flatten()))

    # Signal attenuation at the input signal frequency
    stf_at_omega = digital_estimator_ref.signal_transfer_function(
        np.array([omega_3dB]))[0]

    # Plot
    plt.figure()
    plt.semilogx(frequencies, stf_dB, label='$STF(\omega)$')
    for n in range(N):
        plt.semilogx(frequencies, ntf_dB[0, n, :], label=f"$|NTF_{n+1}(\omega)|$")
    plt.semilogx(frequencies, 20 * np.log10(np.linalg.norm(
        ntf[0, :, :], axis=0)), '--', label="$ || NTF(\omega) ||_2 $")

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which='both')
    plt.title("Signal and noise transfer functions")
    plt.xlabel("$\omega / (4 \pi \\beta ) $")
    plt.ylabel("dB")
    plt.xlim((frequencies[1], frequencies[-1]))
    plt.gcf().tight_layout()




.. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_001.png
    :alt: Signal and noise transfer functions
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 155-159

FIR Filter With Downsampling
----------------------------

Next we repeat the initalization steps above but for a downsampled estimator

.. GENERATED FROM PYTHON SOURCE LINES 159-171

.. code-block:: default
   :lineno-start: 160


    digital_estimator_dow = FIRFilter(
        control_signal_sequences2,
        analog_system,
        digital_control,
        eta2,
        L1,
        L2,
        downsample = OSR)

    print(digital_estimator_dow, "\n")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [[-6.25000001e+01 -2.43204273e-06 -2.85647441e-05 -2.35173302e-04
      -1.28193300e-03 -3.66815487e-03]
     [ 6.25000000e+03 -6.25000607e+01 -8.48160782e-04 -7.79552505e-03
      -4.62928338e-02 -1.43569969e-01]
     [-2.85647441e-05  6.24999915e+03 -6.25132365e+01 -1.32421278e-01
      -8.49361824e-01 -2.86501699e+00]
     [-2.35173302e-04 -7.79552505e-03  6.24986758e+03 -6.39297005e+01
      -9.93225363e+00 -3.70923440e+01]
     [-1.28193300e-03 -4.62928338e-02 -8.49361824e-01  6.24006775e+03
      -1.38528479e+02 -3.29802817e+02]
     [-3.66815487e-03 -1.43569969e-01 -2.86501699e+00 -3.70923440e+01
       5.92019718e+03 -2.00406765e+03]] [[-6.24999997e+01 -6.73216835e-06  8.56115846e-05 -6.90821849e-04
       3.37066838e-03 -7.73727897e-03]
     [ 6.24999999e+03 -6.24998120e+01 -2.69606755e-03  2.36258836e-02
      -1.23501668e-01  3.03035896e-01]
     [ 8.56115846e-05  6.24999730e+03 -6.24580101e+01 -3.94286880e-01
       2.20438687e+00 -5.82520597e+00]
     [-6.90821849e-04  2.36258836e-02  6.24960571e+03 -5.85385365e+01
      -2.38932760e+01  6.95487643e+01]
     [ 3.37066838e-03 -1.23501668e-01  2.20438687e+00  6.22610672e+03
       9.67249284e+01 -5.40962751e+02]
     [-7.73727897e-03  3.03035896e-01 -5.82520597e+00  6.95487643e+01
       5.70903725e+03  2.54331050e+03]]
    FIR estimator is parameterized as 
    eta2 = 1184008941499.20, 121 [dB],
    Ts = 8e-05,
    K1 = 8192,
    K2 = 8192,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    h = 
    [[[-1.27932876e-48  1.00769090e-49  8.64918371e-51 -1.20240032e-51
       -4.21095945e-53  1.23128625e-53]]

     [[-1.33526689e-48  9.67777885e-50  9.29120268e-51 -1.18571015e-51
       -4.85629949e-53  1.23580556e-53]]

     [[-1.38939947e-48  9.24460942e-50  9.92724126e-51 -1.16568837e-51
       -5.50658105e-53  1.23742323e-53]]

     ...

     [[-1.38939371e-48 -1.20231718e-49  5.67374649e-51  1.63925652e-51
        5.88237654e-53 -1.25707358e-53]]

     [[-1.33526227e-48 -1.23480805e-49  4.88610173e-51  1.61635208e-51
        6.52723378e-53 -1.18830922e-53]]

     [[-1.27932527e-48 -1.26353393e-49  4.10681403e-51  1.59018015e-51
        7.14018077e-53 -1.11846062e-53]]]. 





.. GENERATED FROM PYTHON SOURCE LINES 172-175

Estimating (Filtering)
----------------------


.. GENERATED FROM PYTHON SOURCE LINES 175-185

.. code-block:: default
   :lineno-start: 176


    # Set simulation length
    size = L2 << 4
    u_hat_ref = np.zeros(size)
    u_hat_dow = np.zeros(size // OSR)
    for index in range(size):
        u_hat_ref[index] = next(digital_estimator_ref)
    for index in range(size // OSR):
        u_hat_dow[index] = next(digital_estimator_dow)








.. GENERATED FROM PYTHON SOURCE LINES 186-191

Visualizing Results
-------------------

Finally, we summarize the comparision by visualizing the resulting estimate
in both time and frequency domain.

.. GENERATED FROM PYTHON SOURCE LINES 191-223

.. code-block:: default
   :lineno-start: 191

    from cbadc.utilities import compute_power_spectral_density

    # compensate the built in L1 delay of FIR filter.
    t = np.arange(-L1 + 1, size - L1 + 1)
    t_down = np.arange(-(L1) // OSR, (size - L1) // OSR ) * OSR + 1
    plt.plot(t, u_hat_ref, label="$\hat{u}(t)$ Reference")
    plt.plot(t_down, u_hat_dow, label="$\hat{u}(t)$ Downsampled")
    plt.xlabel('$t / T$')
    plt.legend()
    plt.title("Estimated input signal")
    plt.grid(which='both')
    plt.xlim((-50, 1000))
    plt.tight_layout()

    plt.figure()
    u_hat_ref_clipped = u_hat_ref[(L1 + L2):]
    u_hat_dow_clipped = u_hat_dow[(L1 + L2) // OSR:]
    f_ref, psd_ref = compute_power_spectral_density(
      u_hat_ref_clipped)
    f_dow, psd_dow = compute_power_spectral_density(
        u_hat_dow_clipped, fs=1.0/OSR)
    plt.semilogx(f_ref, 10 * np.log10(psd_ref), label="$\hat{U}(f)$ Referefence")
    plt.semilogx(f_dow, 10 * np.log10(psd_dow), label="$\hat{U}(f)$ Downsampled")
    plt.legend()
    plt.ylim((-200, 50))
    plt.xlim((f_ref[1], f_ref[-1]))
    plt.xlabel('frequency [Hz]')
    plt.ylabel('$ \mathrm{V}^2 \, / \, (1 \mathrm{Hz})$')
    plt.grid(which='both')
    plt.show()





.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_002.png
          :alt: Estimated input signal
          :class: sphx-glr-multi-img

    *

      .. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_003.png
          :alt: plot c downsample
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/scipy/signal/spectral.py:1961: UserWarning: nperseg = 16384 is greater than input length  = 1792, using nperseg = 1792
      warnings.warn('nperseg = {0:d} is greater than input length '





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  34.185 seconds)


.. _sphx_glr_download_auto_examples_b_general_plot_c_downsample.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_c_downsample.py <plot_c_downsample.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_c_downsample.ipynb <plot_c_downsample.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
