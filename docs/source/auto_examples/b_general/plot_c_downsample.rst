
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/b_general/plot_c_downsample.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_b_general_plot_c_downsample.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_b_general_plot_c_downsample.py:


=============
Downsampling
=============

In this tutorial we demonstrate how to configure the digital estimator
for downsampling.

.. GENERATED FROM PYTHON SOURCE LINES 9-14

.. code-block:: default
   :lineno-start: 9

    import scipy.signal
    import numpy as np
    import cbadc as cbc
    import matplotlib.pyplot as plt








.. GENERATED FROM PYTHON SOURCE LINES 15-27

Setting up the Analog System and Digital Control
------------------------------------------------

In this example, we assume that we have access to a control signal
s[k] generated by the interactions of an analog system and digital control.
Furthermore, we a chain-of-integrators converter with corresponding
analog system and digital control.

.. image:: /images/chainOfIntegratorsGeneral.svg
   :width: 500
   :align: center
   :alt: The chain of integrators ADC.

.. GENERATED FROM PYTHON SOURCE LINES 27-54

.. code-block:: default
   :lineno-start: 28


    # Setup analog system and digital control

    # We fix the number of analog states.
    N = 6
    M = N
    # Set the amplification factor.
    beta = 6250.
    # In this example, each nodes amplification and local feedback will be set
    # identically.
    betaVec = beta * np.ones(N)
    rhoVec = -betaVec * 1e-2
    kappaVec = - beta * np.eye(N)

    # Instantiate a chain-of-integrators analog system.
    analog_system = cbc.analog_system.ChainOfIntegrators(betaVec, rhoVec, kappaVec)


    T = 1/(2 * beta)
    digital_control = cbc.digital_control.DigitalControl(T, M)


    # Summarize the analog system, digital control, and digital estimator.
    print(analog_system, "\n")
    print(digital_control)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ -62.5    0.     0.     0.     0.     0. ]
     [6250.   -62.5    0.     0.     0.     0. ]
     [   0.  6250.   -62.5    0.     0.     0. ]
     [   0.     0.  6250.   -62.5    0.     0. ]
     [   0.     0.     0.  6250.   -62.5    0. ]
     [   0.     0.     0.     0.  6250.   -62.5]],
    B =
    [[6250.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]],
    CT = 
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[-6250.    -0.    -0.    -0.    -0.    -0.]
     [   -0. -6250.    -0.    -0.    -0.    -0.]
     [   -0.    -0. -6250.    -0.    -0.    -0.]
     [   -0.    -0.    -0. -6250.    -0.    -0.]
     [   -0.    -0.    -0.    -0. -6250.    -0.]
     [   -0.    -0.    -0.    -0.    -0. -6250.]],
    Gamma_tildeT =
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]], and D=[[0.]
     [0.]
     [0.]
     [0.]
     [0.]
     [0.]] 

    The Digital Control is parameterized as:
    T = 8e-05,
    M = 6, and next update at
    t = 8e-05




.. GENERATED FROM PYTHON SOURCE LINES 55-66

Loading Control Signal from File
--------------------------------

Next, we will load an actual control signal to demonstrate the digital
estimator's capabilities. To this end, we will use the
`sinusodial_simulation.adc` file that was produced in
:doc:`./plot_b_simulate_a_control_bounded_adc`.

The control signal file is encoded as raw binary data so to unpack it
correctly we will use the :func:`cbadc.utilities.read_byte_stream_from_file`
and :func:`cbadc.utilities.byte_stream_2_control_signal` functions.

.. GENERATED FROM PYTHON SOURCE LINES 66-82

.. code-block:: default
   :lineno-start: 67


    byte_stream = cbc.utilities.read_byte_stream_from_file(
        '../a_getting_started/sinusodial_simulation.adc', M)
    control_signal_sequences1 = cbc.utilities.byte_stream_2_control_signal(
        byte_stream, M)

    byte_stream = cbc.utilities.read_byte_stream_from_file(
        '../a_getting_started/sinusodial_simulation.adc', M)
    control_signal_sequences2 = cbc.utilities.byte_stream_2_control_signal(
        byte_stream, M)

    byte_stream = cbc.utilities.read_byte_stream_from_file(
        '../a_getting_started/sinusodial_simulation.adc', M)
    control_signal_sequences3 = cbc.utilities.byte_stream_2_control_signal(
        byte_stream, M)








.. GENERATED FROM PYTHON SOURCE LINES 83-86

Oversampling
-------------


.. GENERATED FROM PYTHON SOURCE LINES 86-92

.. code-block:: default
   :lineno-start: 87


    OSR = 16

    omega_3dB = 2 * np.pi / (T * OSR)









.. GENERATED FROM PYTHON SOURCE LINES 93-98

Oversampling = 1
----------------------------------------

First we initialize our default estimator without a downsampling parameter
which then defaults to 1, i.e., no downsampling.

.. GENERATED FROM PYTHON SOURCE LINES 98-118

.. code-block:: default
   :lineno-start: 99


    # Set the bandwidth of the estimator
    G_at_omega = np.linalg.norm(
        analog_system.transfer_function_matrix(np.array([omega_3dB / 2])))
    eta2 = G_at_omega**2
    # eta2 = 1.0
    print(f"eta2 = {eta2}, {10 * np.log10(eta2)} [dB]")

    # Set the filter size
    L1 = 1 << 12
    L2 = L1

    # Instantiate the digital estimator.
    digital_estimator_ref = cbc.digital_estimator.FIRFilter(
        analog_system, digital_control, eta2, L1, L2)
    digital_estimator_ref(control_signal_sequences1)

    print(digital_estimator_ref, "\n")






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    eta2 = 87574.25572661227, 49.42376455036846 [dB]
    FIR estimator is parameterized as 
    eta2 = 87574.26, 49 [dB],
    Ts = 8e-05,
    K1 = 4096,
    K2 = 4096,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    h = 
    [[[ 3.55990445e-95  1.42412246e-95 -8.07811499e-96 -6.45762292e-97
        1.32955934e-96 -9.72617900e-98]
      [ 2.76240492e-95  1.82636990e-95 -7.62786724e-96 -1.33980733e-96
        1.38622941e-96 -1.24737454e-98]
      [ 1.76589627e-95  2.19922553e-95 -6.82068247e-96 -2.05614928e-96
        1.39325750e-96  8.21379656e-98]
      ...
      [ 1.76589627e-95 -2.16391013e-95 -7.69373510e-96  1.62200519e-96
        1.54381374e-96  4.50497165e-98]
      [ 2.76240492e-95 -1.77112250e-95 -8.34780716e-96  8.61459580e-97
        1.47844576e-96  1.38257124e-97]
      [ 3.55990446e-95 -1.35292339e-95 -8.63396392e-96  1.44959196e-97
        1.36586535e-96  2.17212387e-97]]]. 





.. GENERATED FROM PYTHON SOURCE LINES 119-122

Visualize Estimator's Transfer Function
---------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 122-156

.. code-block:: default
   :lineno-start: 123


    # Logspace frequencies
    frequencies = np.logspace(-3, 0, 100)
    omega = 4 * np.pi * beta * frequencies

    # Compute NTF
    ntf = digital_estimator_ref.noise_transfer_function(omega)
    ntf_dB = 20 * np.log10(np.abs(ntf))

    # Compute STF
    stf = digital_estimator_ref.signal_transfer_function(omega)
    stf_dB = 20 * np.log10(np.abs(stf.flatten()))

    # Signal attenuation at the input signal frequency
    stf_at_omega = digital_estimator_ref.signal_transfer_function(
        np.array([omega_3dB]))[0]

    # Plot
    plt.figure()
    plt.semilogx(frequencies, stf_dB, label='$STF(\omega)$')
    for n in range(N):
        plt.semilogx(frequencies, ntf_dB[0, n, :], label=f"$|NTF_{n+1}(\omega)|$")
    plt.semilogx(frequencies, 20 * np.log10(np.linalg.norm(
        ntf[:, 0, :], axis=0)), '--', label="$ || NTF(\omega) ||_2 $")

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which='both')
    plt.title("Signal and noise transfer functions")
    plt.xlabel("$\omega / (4 \pi \\beta ) $")
    plt.ylabel("dB")
    plt.xlim((frequencies[1], frequencies[-1]))
    plt.gcf().tight_layout()




.. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_001.png
    :alt: Signal and noise transfer functions
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /drives1/PhD/cbadc/docs/code_examples/b_general/plot_c_downsample.py:129: RuntimeWarning: divide by zero encountered in log10
      ntf_dB = 20 * np.log10(np.abs(ntf))
    /drives1/PhD/cbadc/docs/code_examples/b_general/plot_c_downsample.py:144: RuntimeWarning: divide by zero encountered in log10
      plt.semilogx(frequencies, 20 * np.log10(np.linalg.norm(




.. GENERATED FROM PYTHON SOURCE LINES 157-161

FIR Filter With Downsampling
----------------------------

Next we repeat the initialization steps above but for a downsampled estimator

.. GENERATED FROM PYTHON SOURCE LINES 161-173

.. code-block:: default
   :lineno-start: 162


    digital_estimator_dow = cbc.digital_estimator.FIRFilter(
        analog_system,
        digital_control,
        eta2,
        L1,
        L2,
        downsample=OSR)
    digital_estimator_dow(control_signal_sequences2)

    print(digital_estimator_dow, "\n")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    FIR estimator is parameterized as 
    eta2 = 87574.26, 49 [dB],
    Ts = 8e-05,
    K1 = 4096,
    K2 = 4096,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    h = 
    [[[ 3.55990445e-95  1.42412246e-95 -8.07811499e-96 -6.45762292e-97
        1.32955934e-96 -9.72617900e-98]
      [ 2.76240492e-95  1.82636990e-95 -7.62786724e-96 -1.33980733e-96
        1.38622941e-96 -1.24737454e-98]
      [ 1.76589627e-95  2.19922553e-95 -6.82068247e-96 -2.05614928e-96
        1.39325750e-96  8.21379656e-98]
      ...
      [ 1.76589627e-95 -2.16391013e-95 -7.69373510e-96  1.62200519e-96
        1.54381374e-96  4.50497165e-98]
      [ 2.76240492e-95 -1.77112250e-95 -8.34780716e-96  8.61459580e-97
        1.47844576e-96  1.38257124e-97]
      [ 3.55990446e-95 -1.35292339e-95 -8.63396392e-96  1.44959196e-97
        1.36586535e-96  2.17212387e-97]]]. 





.. GENERATED FROM PYTHON SOURCE LINES 174-177

Estimating (Filtering)
----------------------


.. GENERATED FROM PYTHON SOURCE LINES 177-187

.. code-block:: default
   :lineno-start: 178


    # Set simulation length
    size = 1 << 17
    u_hat_ref = np.zeros(size)
    u_hat_dow = np.zeros(size // OSR)
    for index in range(size):
        u_hat_ref[index] = next(digital_estimator_ref)
    for index in range(size // OSR):
        u_hat_dow[index] = next(digital_estimator_dow)








.. GENERATED FROM PYTHON SOURCE LINES 188-194

Aliasing
========

We compare the difference between the downsampled estimate and the default.
Clearly, we are suffering from aliasing as is also explained by considering
the PSD plot.

.. GENERATED FROM PYTHON SOURCE LINES 194-224

.. code-block:: default
   :lineno-start: 195


    # compensate the built in L1 delay of FIR filter.
    t = np.arange(-L1 + 1, size - L1 + 1)
    t_down = np.arange(-(L1) // OSR, (size - L1) // OSR) * OSR + 1
    plt.plot(t, u_hat_ref, label="$\hat{u}(t)$ Reference")
    plt.plot(t_down, u_hat_dow, label="$\hat{u}(t)$ Downsampled")
    plt.xlabel('$t / T$')
    plt.legend()
    plt.title("Estimated input signal")
    plt.grid(which='both')
    plt.xlim((-50, 1000))
    plt.tight_layout()

    plt.figure()
    u_hat_ref_clipped = u_hat_ref[(L1 + L2):]
    u_hat_dow_clipped = u_hat_dow[(L1 + L2) // OSR:]
    f_ref, psd_ref = cbc.utilities.compute_power_spectral_density(
        u_hat_ref_clipped, fs=1.0/T)
    f_dow, psd_dow = cbc.utilities.compute_power_spectral_density(
        u_hat_dow_clipped, fs=1.0/(T * OSR))
    plt.semilogx(f_ref, 10 * np.log10(psd_ref), label="$\hat{U}(f)$ Referefence")
    plt.semilogx(f_dow, 10 * np.log10(psd_dow), label="$\hat{U}(f)$ Downsampled")
    plt.legend()
    plt.ylim((-300, 50))
    plt.xlim((f_ref[1], f_ref[-1]))
    plt.xlabel('frequency [Hz]')
    plt.ylabel('$ \mathrm{V}^2 \, / \, (1 \mathrm{Hz})$')
    plt.grid(which='both')
    plt.show()




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_002.png
          :alt: Estimated input signal
          :class: sphx-glr-multi-img

    *

      .. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_003.png
          :alt: plot c downsample
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/scipy/signal/spectral.py:1961: UserWarning: nperseg = 16384 is greater than input length  = 7680, using nperseg = 7680
      warnings.warn('nperseg = {0:d} is greater than input length '




.. GENERATED FROM PYTHON SOURCE LINES 225-232

Prepending a Bandlimiting Filter
-------------------------------

To battle the aliasing we extend the current estimator by placing a
bandlimiting filter in front of the system. This has the wanted effect since
we now reconstruct a signal shaped by both the STF of the system in addition
to a bandlimiting filter.

.. GENERATED FROM PYTHON SOURCE LINES 232-309

.. code-block:: default
   :lineno-start: 233


    filter_order = 6
    filter1 = cbc.analog_system.Cauer(filter_order,  omega_3dB / 2.0, 1, 60)
    filter2 = cbc.analog_system.ChebyshevI(filter_order, omega_3dB / 2.0, 1)
    filter3 = cbc.analog_system.ChebyshevII(filter_order, omega_3dB / 2.0, 60)
    filter4 = cbc.analog_system.ButterWorth(filter_order,  omega_3dB / 2.0)

    b1, a1 = scipy.signal.ellip(
        filter_order, 1, 60, omega_3dB / 2.0, btype='low', analog=True)

    b3, a3 = scipy.signal.cheby2(
        filter_order, 60, omega_3dB/2.0, btype='low', analog=True)

    b2, a2 = scipy.signal.cheby1(
        filter_order, 1, omega_3dB/2.0, btype='low', analog=True)

    b4, a4 = scipy.signal.butter(
        filter_order, omega_3dB/2.0, btype='low', analog=True)

    w1, h1 = scipy.signal.freqs(b1, a1)
    w2, h2 = scipy.signal.freqs(b2, a2)
    w3, h3 = scipy.signal.freqs(b3, a3)
    w4, h4 = scipy.signal.freqs(b4, a4)

    print("Cauer", filter1)
    print("ChebyshevI", filter2)
    print("ChebyshevII", filter3)
    print("ButterWorth", filter4)
    print(omega_3dB, omega_3dB / np.pi / 2)

    # Compute transfer functions for each frequency in frequencies
    transfer_function_filter1 = filter1.transfer_function_matrix(w1)
    transfer_function_filter2 = filter2.transfer_function_matrix(w2)
    transfer_function_filter3 = filter3.transfer_function_matrix(w3)
    transfer_function_filter4 = filter4.transfer_function_matrix(w4)

    # Add the norm ||G(omega)||_2
    plt.semilogx(w1/(2 * np.pi), 20 * np.log10(np.abs(h1)), label="Cauer Ref")
    plt.semilogx(
        w1/(2 * np.pi),
        20 * np.log10(np.linalg.norm(
            transfer_function_filter1[:, 0, :],
            axis=0)),
        label="Cauer")
    plt.semilogx(w2/(2 * np.pi), 20 * np.log10(np.abs(h2)), label="ChebyshevI Ref")
    plt.semilogx(
        w2/(2 * np.pi),
        20 * np.log10(np.linalg.norm(
            transfer_function_filter2[:, 0, :],
            axis=0)),
        label="ChebyshevI")
    plt.semilogx(w3/(2 * np.pi), 20 * np.log10(np.abs(h3)),
                 label="ChebyshevII Ref")
    plt.semilogx(
        w3/(2 * np.pi),
        20 * np.log10(np.linalg.norm(
            transfer_function_filter3[:, 0, :],
            axis=0)),
        label="ChebyshevII")
    plt.semilogx(w4/(2 * np.pi), 20 * np.log10(np.abs(h4)),
                 label="ButterWorth Ref")

    plt.semilogx(
        w4/(2 * np.pi),
        20 * np.log10(np.linalg.norm(
            transfer_function_filter4[:, 0, :],
            axis=0)),
        label="ButterWorth")
    # Add labels and legends to figure
    plt.legend()
    plt.grid(which='both')
    plt.title("Filter Transfer Functions")
    plt.xlabel("f [Hz]")
    plt.ylabel("dB")
    plt.xlim((5e1, 1e4))
    plt.gcf().tight_layout()




.. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_004.png
    :alt: Filter Transfer Functions
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [5 2 4 1 3 0]
    [3 0 4 1 5 2]
    Two poles
    double zeros
    The analog system is parameterized as:
    A =
    [[ -100.64589754  2447.47724188]
     [-2447.47724188  -100.64589754]],
    B =
    [[0.10000465]
     [0.        ]],
    CT = 
    [[  -201.29179508 -44056.49768705]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.10000465]]
    Two poles
    double zeros
    The analog system is parameterized as:
    A =
    [[ -363.49219284  1971.49989964]
     [-1971.49989964  -363.49219284]],
    B =
    [[0.10000465]
     [0.        ]],
    CT = 
    [[ -726.98438568 -7294.12069634]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.10000465]]
    Two poles
    double zeros
    The analog system is parameterized as:
    A =
    [[-666.26444256  805.98580863]
     [-805.98580863 -666.26444256]],
    B =
    [[0.10000465]
     [0.        ]],
    CT = 
    [[ -1332.52888512 -13871.23044905]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.10000465]]
    [5 0 4 1 3 2]
    Two poles
    No zero
    The analog system is parameterized as:
    A =
    [[ -152.61519339 -2438.19791853]
     [ 2438.19791853  -152.61519339]],
    B =
    [[2376661.69903271]
     [      0.        ]],
    CT = 
    [[0.         0.00041014]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.]]
    Two poles
    No zero
    The analog system is parameterized as:
    A =
    [[ -416.95246235 -1784.88475527]
     [ 1784.88475527  -416.95246235]],
    B =
    [[2376661.69903271]
     [      0.        ]],
    CT = 
    [[0.         0.00056026]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.]]
    Two poles
    No zero
    The analog system is parameterized as:
    A =
    [[-569.56765574 -653.31316326]
     [ 653.31316326 -569.56765574]],
    B =
    [[2376661.69903271]
     [      0.        ]],
    CT = 
    [[0.         0.00153066]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.]]
    [5 0 4 1 3 2]
    [3 2 4 1 5 0]
    Two poles
    double zeros
    The analog system is parameterized as:
    A =
    [[ -288.09776886  1260.5866819 ]
     [-1260.5866819   -288.09776886]],
    B =
    [[0.1]
     [0. ]],
    CT = 
    [[  -576.19553773 -70142.22125169]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.1]]
    Two poles
    double zeros
    The analog system is parameterized as:
    A =
    [[ -894.62503084  1048.88123852]
     [-1048.88123852  -894.62503084]],
    B =
    [[0.1]
     [0. ]],
    CT = 
    [[ -1789.25006168 -11200.56170021]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.1]]
    Two poles
    double zeros
    The analog system is parameterized as:
    A =
    [[-1415.44826211   444.66374773]
     [ -444.66374773 -1415.44826211]],
    B =
    [[0.1]
     [0. ]],
    CT = 
    [[ -2830.89652421 -18580.77041107]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.1]]
    [5 0 4 1 3 2]
    Two poles
    No zero
    The analog system is parameterized as:
    A =
    [[ -635.23750836 -2370.73865608]
     [ 2370.73865608  -635.23750836]],
    B =
    [[6023928.46746176]
     [      0.        ]],
    CT = 
    [[0.         0.00042181]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.]]
    Two poles
    No zero
    The analog system is parameterized as:
    A =
    [[-1735.50114772 -1735.50114772]
     [ 1735.50114772 -1735.50114772]],
    B =
    [[6023928.46746176]
     [      0.        ]],
    CT = 
    [[0.        0.0005762]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.]]
    Two poles
    No zero
    The analog system is parameterized as:
    A =
    [[-2370.73865608  -635.23750836]
     [  635.23750836 -2370.73865608]],
    B =
    [[6023928.46746176]
     [      0.        ]],
    CT = 
    [[0.         0.00157421]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.]]
    Cauer The analog system is parameterized as:
    A =
    [[-1.00645898e+02  2.44747724e+03  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00]
     [-2.44747724e+03 -1.00645898e+02  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00]
     [-2.01301157e+01 -4.40585466e+03 -3.63492193e+02  1.97149990e+03
       0.00000000e+00  0.00000000e+00]
     [ 0.00000000e+00  0.00000000e+00 -1.97149990e+03 -3.63492193e+02
       0.00000000e+00  0.00000000e+00]
     [-2.01310519e+00 -4.40605957e+02 -7.27018196e+01 -7.29445993e+02
      -6.66264443e+02  8.05985809e+02]
     [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
      -8.05985809e+02 -6.66264443e+02]],
    B =
    [[0.10000465]
     [0.        ]
     [0.01000093]
     [0.        ]
     [0.00100014]
     [0.        ]],
    CT = 
    [[-2.01310519e+00 -4.40605957e+02 -7.27018196e+01 -7.29445993e+02
      -1.33252889e+03 -1.38712304e+04]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.00100014]]
    ChebyshevI The analog system is parameterized as:
    A =
    [[ -152.61519339 -2438.19791853     0.             0.
          0.             0.        ]
     [ 2438.19791853  -152.61519339     0.             0.
          0.             0.        ]
     [    0.           974.76159789  -416.95246235 -1784.88475527
          0.             0.        ]
     [    0.             0.          1784.88475527  -416.95246235
          0.             0.        ]
     [    0.             0.             0.          1331.54910535
       -569.56765574  -653.31316326]
     [    0.             0.             0.             0.
        653.31316326  -569.56765574]],
    B =
    [[2376661.69903271]
     [      0.        ]
     [      0.        ]
     [      0.        ]
     [      0.        ]
     [      0.        ]],
    CT = 
    [[0.         0.         0.         0.         0.         0.00153066]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.]]
    ChebyshevII The analog system is parameterized as:
    A =
    [[-2.88097769e+02  1.26058668e+03  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00]
     [-1.26058668e+03 -2.88097769e+02  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00]
     [-5.76195538e+01 -7.01422213e+03 -8.94625031e+02  1.04888124e+03
       0.00000000e+00  0.00000000e+00]
     [ 0.00000000e+00  0.00000000e+00 -1.04888124e+03 -8.94625031e+02
       0.00000000e+00  0.00000000e+00]
     [-5.76195538e+00 -7.01422213e+02 -1.78925006e+02 -1.12005617e+03
      -1.41544826e+03  4.44663748e+02]
     [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
      -4.44663748e+02 -1.41544826e+03]],
    B =
    [[0.1  ]
     [0.   ]
     [0.01 ]
     [0.   ]
     [0.001]
     [0.   ]],
    CT = 
    [[-5.76195538e+00 -7.01422213e+02 -1.78925006e+02 -1.12005617e+03
      -2.83089652e+03 -1.85807704e+04]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.001]]
    ButterWorth The analog system is parameterized as:
    A =
    [[ -635.23750836 -2370.73865608     0.             0.
          0.             0.        ]
     [ 2370.73865608  -635.23750836     0.             0.
          0.             0.        ]
     [    0.          2540.95003345 -1735.50114772 -1735.50114772
          0.             0.        ]
     [    0.             0.          1735.50114772 -1735.50114772
          0.             0.        ]
     [    0.             0.             0.          3471.00229544
      -2370.73865608  -635.23750836]
     [    0.             0.             0.             0.
        635.23750836 -2370.73865608]],
    B =
    [[6023928.46746176]
     [      0.        ]
     [      0.        ]
     [      0.        ]
     [      0.        ]
     [      0.        ]],
    CT = 
    [[0.         0.         0.         0.         0.         0.00157421]],
    Gamma =
    None,
    Gamma_tildeT =
    None, and D=[[0.]]
    4908.738521234051 781.25




.. GENERATED FROM PYTHON SOURCE LINES 310-313

New Analog System
-------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 313-344

.. code-block:: default
   :lineno-start: 314


    new_analog_system = cbc.analog_system.chain([filter1, analog_system])
    print(new_analog_system)

    transfer_function_analog_system = analog_system.transfer_function_matrix(omega)

    transfer_function_new_analog_system = new_analog_system.transfer_function_matrix(
        omega)

    plt.semilogx(
        omega/(2 * np.pi),
        20 * np.log10(np.linalg.norm(
            transfer_function_analog_system[:, 0, :],
            axis=0)),
        label="Default Analog System")
    plt.semilogx(
        omega/(2 * np.pi),
        20 * np.log10(np.linalg.norm(
            transfer_function_new_analog_system[:, 0, :],
            axis=0)),
        label="Combined Analog System")

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which='both')
    plt.title("Analog System Transfer Function")
    plt.xlabel("f [Hz]")
    plt.ylabel("$||\mathbf{G}(\omega)||_2$ dB")
    # plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()




.. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_005.png
    :alt: Analog System Transfer Function
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[-1.00645898e+02  2.44747724e+03  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]
     [-2.44747724e+03 -1.00645898e+02  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]
     [-2.01301157e+01 -4.40585466e+03 -3.63492193e+02  1.97149990e+03
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]
     [ 0.00000000e+00  0.00000000e+00 -1.97149990e+03 -3.63492193e+02
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]
     [-2.01310519e+00 -4.40605957e+02 -7.27018196e+01 -7.29445993e+02
      -6.66264443e+02  8.05985809e+02  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]
     [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
      -8.05985809e+02 -6.66264443e+02  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]
     [-1.25819074e+04 -2.75378723e+06 -4.54386372e+05 -4.55903745e+06
      -8.32830553e+06 -8.66951903e+07 -6.25000000e+01  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]
     [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  6.25000000e+03 -6.25000000e+01
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00]
     [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  6.25000000e+03
      -6.25000000e+01  0.00000000e+00  0.00000000e+00  0.00000000e+00]
     [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
       6.25000000e+03 -6.25000000e+01  0.00000000e+00  0.00000000e+00]
     [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
       0.00000000e+00  6.25000000e+03 -6.25000000e+01  0.00000000e+00]
     [ 0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  0.00000000e+00  0.00000000e+00
       0.00000000e+00  0.00000000e+00  6.25000000e+03 -6.25000000e+01]],
    B =
    [[1.00004651e-01]
     [0.00000000e+00]
     [1.00009302e-02]
     [0.00000000e+00]
     [1.00013953e-03]
     [0.00000000e+00]
     [6.25087205e+00]
     [0.00000000e+00]
     [0.00000000e+00]
     [0.00000000e+00]
     [0.00000000e+00]
     [0.00000000e+00]],
    CT = 
    [[0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[    0.     0.     0.     0.     0.     0.]
     [    0.     0.     0.     0.     0.     0.]
     [    0.     0.     0.     0.     0.     0.]
     [    0.     0.     0.     0.     0.     0.]
     [    0.     0.     0.     0.     0.     0.]
     [    0.     0.     0.     0.     0.     0.]
     [-6250.    -0.    -0.    -0.    -0.    -0.]
     [   -0. -6250.    -0.    -0.    -0.    -0.]
     [   -0.    -0. -6250.    -0.    -0.    -0.]
     [   -0.    -0.    -0. -6250.    -0.    -0.]
     [   -0.    -0.    -0.    -0. -6250.    -0.]
     [   -0.    -0.    -0.    -0.    -0. -6250.]],
    Gamma_tildeT =
    [[0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]], and D=[[0.]
     [0.]
     [0.]
     [0.]
     [0.]
     [0.]]




.. GENERATED FROM PYTHON SOURCE LINES 345-348

New Digital Estimator
--------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 348-360

.. code-block:: default
   :lineno-start: 349


    digital_estimator_dow_and_filtered = cbc.digital_estimator.FIRFilter(
        new_analog_system,
        digital_control,
        eta2,
        L1,
        L2,
        downsample=OSR)
    digital_estimator_dow_and_filtered(control_signal_sequences3)

    print(digital_estimator_dow_and_filtered)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    FIR estimator is parameterized as 
    eta2 = 87574.26, 49 [dB],
    Ts = 8e-05,
    K1 = 4096,
    K2 = 4096,
    and
    number_of_iterations = 9223372036854775808.
    Resulting in the filter coefficients
    h = 
    [[[-4.79732182e-20 -9.23126439e-20  8.91192594e-21  1.42985826e-20
       -1.55345108e-21 -1.88736644e-21]
      [-1.00585874e-21 -9.54285899e-20  1.59443568e-21  1.48932651e-20
       -4.40513579e-22 -1.97504054e-21]
      [ 4.68338331e-20 -9.48301609e-20 -5.91575634e-21  1.49101772e-20
        7.09554300e-22 -1.98625097e-21]
      ...
      [ 8.28577706e-19 -8.33175773e-19 -1.76357390e-19  1.21198001e-19
        3.34820048e-20 -1.47603704e-20]
      [ 1.22680484e-18 -7.34155015e-19 -2.33629184e-19  1.02523972e-19
        4.13166993e-20 -1.19353757e-20]
      [ 1.57047847e-18 -6.08363656e-19 -2.80835346e-19  8.01958634e-20
        4.74112657e-20 -8.69633004e-21]]].




.. GENERATED FROM PYTHON SOURCE LINES 361-364

Plotting the Estimator's Signal and Noise Transfer Function
-----------------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 364-413

.. code-block:: default
   :lineno-start: 365


    # Compute NTF
    ntf = digital_estimator_dow_and_filtered.noise_transfer_function(omega)
    ntf_dow = digital_estimator_dow.noise_transfer_function(omega)

    # Compute STF
    stf = digital_estimator_dow_and_filtered.signal_transfer_function(omega)
    stf_dB = 20 * np.log10(np.abs(stf.flatten()))
    stf_dow = digital_estimator_dow.signal_transfer_function(omega)
    stf_dow_dB = 20 * np.log10(np.abs(stf_dow.flatten()))

    # Plot
    plt.figure()
    plt.semilogx(omega/(2 * np.pi), stf_dB, label='$STF(\omega)$ New')
    plt.semilogx(omega/(2 * np.pi), stf_dow_dB, label='$STF(\omega)$ Old')
    plt.semilogx(omega/(2 * np.pi), 20 * np.log10(np.linalg.norm(
        ntf[:, 0, :], axis=0)), '--', label="$ || NTF(\omega) ||_2 $ New")
    plt.semilogx(omega/(2 * np.pi), 20 * np.log10(np.linalg.norm(
        ntf_dow[:, 0, :], axis=0)), '--', label="$ || NTF(\omega) ||_2 $ Old")

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which='both')
    plt.title("Signal and noise transfer functions")
    plt.xlabel("f [Hz]")
    plt.ylabel("dB")
    # plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()

    plt.figure()
    # Plot
    plt.figure()
    plt.semilogx(omega/(2 * np.pi), stf_dB, label='$STF(\omega)$ New')
    plt.semilogx(omega/(2 * np.pi), stf_dow_dB, label='$STF(\omega)$ Old')
    plt.semilogx(omega/(2 * np.pi), 20 * np.log10(np.linalg.norm(
        ntf[:, 0, :], axis=0)), '--', label="$ || NTF(\omega) ||_2 $ New")
    plt.semilogx(omega/(2 * np.pi), 20 * np.log10(np.linalg.norm(
        ntf_dow[:, 0, :], axis=0)), '--', label="$ || NTF(\omega) ||_2 $ Old")

    # Add labels and legends to figure
    plt.legend()
    plt.grid(which='both')
    plt.title("Signal and noise transfer functions")
    plt.xlabel("f [Hz]")
    plt.ylabel("dB")
    plt.ylim((-10, 1))
    # plt.xlim((frequencies[0], frequencies[-1]))
    plt.gcf().tight_layout()




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_006.png
          :alt: Signal and noise transfer functions
          :class: sphx-glr-multi-img

    *

      .. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_007.png
          :alt: plot c downsample
          :class: sphx-glr-multi-img

    *

      .. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_008.png
          :alt: Signal and noise transfer functions
          :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /drives1/PhD/cbadc/docs/code_examples/b_general/plot_c_downsample.py:379: RuntimeWarning: divide by zero encountered in log10
      plt.semilogx(omega/(2 * np.pi), 20 * np.log10(np.linalg.norm(
    /drives1/PhD/cbadc/docs/code_examples/b_general/plot_c_downsample.py:381: RuntimeWarning: divide by zero encountered in log10
      plt.semilogx(omega/(2 * np.pi), 20 * np.log10(np.linalg.norm(
    /drives1/PhD/cbadc/docs/code_examples/b_general/plot_c_downsample.py:398: RuntimeWarning: divide by zero encountered in log10
      plt.semilogx(omega/(2 * np.pi), 20 * np.log10(np.linalg.norm(
    /drives1/PhD/cbadc/docs/code_examples/b_general/plot_c_downsample.py:400: RuntimeWarning: divide by zero encountered in log10
      plt.semilogx(omega/(2 * np.pi), 20 * np.log10(np.linalg.norm(




.. GENERATED FROM PYTHON SOURCE LINES 414-417

Filtering Estimate
--------------------


.. GENERATED FROM PYTHON SOURCE LINES 417-438

.. code-block:: default
   :lineno-start: 418


    u_hat_dow_and_filt = np.zeros(size // OSR)
    for index in cbc.utilities.show_status(range(size // OSR)):
        u_hat_dow_and_filt[index] = next(digital_estimator_dow_and_filtered)

    plt.figure()
    u_hat_dow_and_filt_clipped = u_hat_dow_and_filt[(L1 + L2) // OSR:]
    _, psd_dow_and_filt = cbc.utilities.compute_power_spectral_density(
        u_hat_dow_and_filt_clipped, fs=1.0/(T * OSR))
    plt.semilogx(f_ref, 10 * np.log10(psd_ref), label="$\hat{U}(f)$ Referefence")
    plt.semilogx(f_dow, 10 * np.log10(psd_dow), label="$\hat{U}(f)$ Downsampled")
    plt.semilogx(f_dow, 10 * np.log10(psd_dow_and_filt),
                 label="$\hat{U}(f)$ Downsampled and Filtered")
    plt.legend()
    plt.ylim((-300, 50))
    plt.xlim((f_ref[1], f_ref[-1]))
    plt.xlabel('frequency [Hz]')
    plt.ylabel('$ \mathrm{V}^2 \, / \, (1 \mathrm{Hz})$')
    plt.grid(which='both')
    plt.show()




.. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_009.png
    :alt: plot c downsample
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

      0%|          | 0/8192 [00:00<?, ?it/s]      2%|1         | 151/8192 [00:00<00:05, 1500.58it/s]      5%|5         | 442/8192 [00:00<00:03, 2324.24it/s]      9%|9         | 751/8192 [00:00<00:02, 2671.38it/s]     13%|#2        | 1061/8192 [00:00<00:02, 2837.72it/s]     17%|#6        | 1370/8192 [00:00<00:02, 2925.74it/s]     20%|##        | 1678/8192 [00:00<00:02, 2977.15it/s]     24%|##4       | 1988/8192 [00:00<00:02, 3014.95it/s]     28%|##8       | 2299/8192 [00:00<00:01, 3042.58it/s]     32%|###1      | 2606/8192 [00:00<00:01, 3049.51it/s]     36%|###5      | 2911/8192 [00:01<00:01, 2758.78it/s]     39%|###8      | 3192/8192 [00:01<00:01, 2653.89it/s]     43%|####2     | 3498/8192 [00:01<00:01, 2766.21it/s]     46%|####6     | 3792/8192 [00:01<00:01, 2814.87it/s]     50%|####9     | 4082/8192 [00:01<00:01, 2839.42it/s]     53%|#####3    | 4380/8192 [00:01<00:01, 2879.85it/s]     57%|#####7    | 4680/8192 [00:01<00:01, 2910.06it/s]     61%|######    | 4973/8192 [00:01<00:01, 2717.56it/s]     64%|######4   | 5280/8192 [00:01<00:01, 2817.00it/s]     68%|######8   | 5588/8192 [00:01<00:00, 2891.61it/s]     72%|#######1  | 5898/8192 [00:02<00:00, 2949.92it/s]     76%|#######5  | 6208/8192 [00:02<00:00, 2993.43it/s]     80%|#######9  | 6521/8192 [00:02<00:00, 3032.18it/s]     83%|########3 | 6830/8192 [00:02<00:00, 3048.45it/s]     87%|########7 | 7142/8192 [00:02<00:00, 3068.34it/s]     91%|######### | 7453/8192 [00:02<00:00, 3080.29it/s]     95%|#########4| 7766/8192 [00:02<00:00, 3094.04it/s]     99%|#########8| 8079/8192 [00:02<00:00, 3102.34it/s]    100%|##########| 8192/8192 [00:02<00:00, 2909.29it/s]
    /home/hammal/anaconda3/envs/py38/lib/python3.8/site-packages/scipy/signal/spectral.py:1961: UserWarning: nperseg = 16384 is greater than input length  = 7680, using nperseg = 7680
      warnings.warn('nperseg = {0:d} is greater than input length '




.. GENERATED FROM PYTHON SOURCE LINES 439-442

In Time Domain
---------------


.. GENERATED FROM PYTHON SOURCE LINES 442-457

.. code-block:: default
   :lineno-start: 443


    t = np.arange(size)
    t_down = np.arange(size // OSR) * OSR
    plt.plot(t, u_hat_ref, label="$\hat{u}(t)$ Reference")
    plt.plot(t_down, u_hat_dow, label="$\hat{u}(t)$ Downsampled")
    plt.plot(t_down, u_hat_dow_and_filt,
             label="$\hat{u}(t)$ Downsampled and Pre-Filtered")
    plt.xlabel('$t / T$')
    plt.legend()
    plt.title("Estimated input signal")
    plt.grid(which='both')
    offset = (L1 + L2) * 4
    plt.xlim((offset, offset + 1000))
    plt.tight_layout()




.. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_010.png
    :alt: Estimated input signal
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 458-461

Compare Filter Coefficients
---------------------------


.. GENERATED FROM PYTHON SOURCE LINES 461-481

.. code-block:: default
   :lineno-start: 461

    impulse_response_dB_dow = 20 * \
        np.log10(np.linalg.norm(
            np.array(digital_estimator_dow.h[0, :, :]), axis=1))
    impulse_response_dB_dow_and_filt = 20 * \
        np.log10(np.linalg.norm(
            np.array(digital_estimator_dow_and_filtered.h[0, :, :]), axis=1))

    plt.figure()
    plt.plot(np.arange(0, L1),
             impulse_response_dB_dow[L1:],
             label="Ref")
    plt.plot(np.arange(0, L1),
             impulse_response_dB_dow_and_filt[L1:],
             label="Filtered")
    plt.legend()
    plt.xlabel("filter tap k")
    plt.ylabel("$|| \mathbf{h} [k]||_2$ [dB]")
    # plt.xlim((0, filter_lengths[-1]))
    plt.grid(which='both')




.. image:: /auto_examples/b_general/images/sphx_glr_plot_c_downsample_011.png
    :alt: plot c downsample
    :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 1 minutes  9.430 seconds)


.. _sphx_glr_download_auto_examples_b_general_plot_c_downsample.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_c_downsample.py <plot_c_downsample.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_c_downsample.ipynb <plot_c_downsample.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
