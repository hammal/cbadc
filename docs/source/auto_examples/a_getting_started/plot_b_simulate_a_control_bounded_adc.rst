
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/a_getting_started/plot_b_simulate_a_control_bounded_adc.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_a_getting_started_plot_b_simulate_a_control_bounded_adc.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_a_getting_started_plot_b_simulate_a_control_bounded_adc.py:


Simulating a Control-Bounded ADC
================================

This example shows how to simulate the interactions between an analog system
and a digital control while the former is excited by an analog signal.

.. GENERATED FROM PYTHON SOURCE LINES 9-17

The Analog System
-----------------

First we have to decide on an analog system. For this tutorial we will
commit to a chain-of-integrators ADC,
see :py:class:`cbadc.analog_system.ChainOfIntegrators`, as our analog
system. This is an arbitrary choice and all following steps could be
repeated for any relevant analog system.

.. GENERATED FROM PYTHON SOURCE LINES 17-41

.. code-block:: default
   :lineno-start: 17

    from cbadc.simulator import extended_simulation_result
    import matplotlib.pyplot as plt
    from cbadc.utilities import write_byte_stream_to_file
    from cbadc.utilities import control_signal_2_byte_stream
    from cbadc.simulator import StateSpaceSimulator
    from cbadc.analog_signal import Sinusodial
    from cbadc.digital_control import DigitalControl
    from cbadc.analog_system import ChainOfIntegrators
    import numpy as np
    # We fix the number of analog states.
    N = 6
    # Set the amplification factor.
    beta = 6250.
    # In this example, each nodes amplification and local feedback will be set
    # identically.
    betaVec = beta * np.ones(N)
    rhoVec = -betaVec * 1e-2
    kappaVec = - beta * np.eye(N)

    # Instantiate a chain-of-integrators analog system.
    analog_system = ChainOfIntegrators(betaVec, rhoVec, kappaVec)
    # print the analog system such that we can very it being correctly initalized.
    print(analog_system)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ -62.5    0.     0.     0.     0.     0. ]
     [6250.   -62.5    0.     0.     0.     0. ]
     [   0.  6250.   -62.5    0.     0.     0. ]
     [   0.     0.  6250.   -62.5    0.     0. ]
     [   0.     0.     0.  6250.   -62.5    0. ]
     [   0.     0.     0.     0.  6250.   -62.5]],
    B =
    [[6250.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]],
    CT = 
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[-6250.    -0.    -0.    -0.    -0.    -0.]
     [   -0. -6250.    -0.    -0.    -0.    -0.]
     [   -0.    -0. -6250.    -0.    -0.    -0.]
     [   -0.    -0.    -0. -6250.    -0.    -0.]
     [   -0.    -0.    -0.    -0. -6250.    -0.]
     [   -0.    -0.    -0.    -0.    -0. -6250.]],
    and Gamma_tildeT =
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]]




.. GENERATED FROM PYTHON SOURCE LINES 42-48

The Digital Control
-------------------

In addition to the analog system our simulation will require us to specify a
digital control. For this tutorial we will use
:py:class:`cbadc.digital_control.DigitalControl`.

.. GENERATED FROM PYTHON SOURCE LINES 48-59

.. code-block:: default
   :lineno-start: 49


    # Set the time period which determines how often the digital control updates.
    T = 1.0/(2 * beta)
    # Set the number of digital controls to be same as analog states.
    M = N
    # Initialize the digital control.
    digital_control = DigitalControl(T, M)
    # print the digital control to verify proper initialization.
    print(digital_control)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The Digital Control is parameterized as:
    T = 8e-05,
    M = 6, and next update at
    t = 8e-05




.. GENERATED FROM PYTHON SOURCE LINES 60-67

The Analog Signal
-----------------

The final and third component of the simulation is an analog signal.
For this tutorial we will choose a
:py:class:`cbadc.analog_signal.Sinusodial`. Again, this is one of several
possible choices.

.. GENERATED FROM PYTHON SOURCE LINES 67-83

.. code-block:: default
   :lineno-start: 68


    # Set the peak amplitude.
    amplitude = 0.5
    # Choose the sinusodial frequency via an oversampling ratio (OSR).
    OSR = 1 << 9
    frequency = 1.0 / (T * OSR)

    # We also specify a phase an offset these are hovewer optional.
    phase = np.pi / 3
    offset = 0.0

    # Instantiate the analog signal
    analog_signal = Sinusodial(amplitude, frequency, phase, offset)
    # print to ensure correct parametrization.
    print(analog_signal)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Sinusodial parameterized as:
    amplitude = 0.5,
    frequency = 24.414062499999996,
    phase = 1.0471975511965976, and
    offset = 0.0




.. GENERATED FROM PYTHON SOURCE LINES 84-92

Simulating
-------------

Next we setup the simulator. Here we use the
:py:class:`cbadc.simulator.StateSpaceSimulator` for simulating the
invloved differential equations as outlined in
:py:class:`cbadc.analog_system.AnalogSystem`.


.. GENERATED FROM PYTHON SOURCE LINES 92-113

.. code-block:: default
   :lineno-start: 93


    # Simulate for 2^17 control cycles.
    end_time = T * (1 << 17)

    # Instantiate the simulator.
    simulator = StateSpaceSimulator(analog_system, digital_control, [
                                    analog_signal], t_stop=end_time)
    # Depending on your analog system the step above might take some time to
    # compute as it involves precomputing solutions to initial value problems.

    # Let's print the first 20 control decisions.
    index = 0
    for s in simulator:
        if (index > 19):
            break
        print(f"step:{index} -> s:{np.array(s)}")
        index += 1

    # To verify the simulation parametrization we can
    print(simulator)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    step:0 -> s:[0 0 0 0 0 0]
    step:1 -> s:[1 1 1 1 1 1]
    step:2 -> s:[0 0 0 0 0 0]
    step:3 -> s:[1 1 0 0 0 0]
    step:4 -> s:[1 0 1 1 1 1]
    step:5 -> s:[1 1 1 0 0 0]
    step:6 -> s:[0 1 0 1 1 0]
    step:7 -> s:[1 0 1 0 0 1]
    step:8 -> s:[1 1 0 1 1 0]
    step:9 -> s:[0 0 1 0 0 1]
    step:10 -> s:[1 1 0 1 1 1]
    step:11 -> s:[1 1 1 1 1 0]
    step:12 -> s:[1 1 1 0 0 1]
    step:13 -> s:[0 0 0 1 1 0]
    step:14 -> s:[1 1 1 0 0 0]
    step:15 -> s:[1 1 0 1 1 1]
    step:16 -> s:[1 0 1 0 0 0]
    step:17 -> s:[0 1 0 1 1 1]
    step:18 -> s:[1 0 1 0 0 0]
    step:19 -> s:[1 1 0 1 1 1]
    t = 0.00168, (current simulator time)
    Ts = 8e-05,
    t_stop = 10.48576,
    rtol = 1e-12,
    atol = 1e-12, and
    max_step = 0.0008





.. GENERATED FROM PYTHON SOURCE LINES 114-144

Tracking the Analog State Vector
--------------------------------

Clearly the output type of the generator simulator above is the sequence of
control signals s[k]. Sometimes we are interested in also monitoring the
internal analog states of analog system during simulation.

To this end we use the
:func:`cbadc.simulator.StateSpaceSimulator.state_vector` and an
:func:`cbadc.simulator.extended_simulation_result`.

Note that the :func:`cbadc.simulator.extended_simulation_result` is
defined like this

.. code-block:: python

  def extended_simulation_result(simulator):
      for control_signal in simulator:
          analog_state = simulator.state_vector()
          yield {
              'control_signal': np.array(control_signal),
              'analog_state': np.array(analog_state)
          }

So in essence we are creating a new generator from the old with an extended
output.

.. note:: The convenience function extended_simulation_result that will be
   derived next is one of many such convenience functions found in the
   :py:mod:`cbadc.simulator` module.

.. GENERATED FROM PYTHON SOURCE LINES 144-158

.. code-block:: default
   :lineno-start: 145


    # We can achieve this by appending yet another generator to the control signal
    # stream as:

    # Repeating the steps above we now get for the following
    # ten control cycles.
    ext_simulator = extended_simulation_result(simulator)
    for res in ext_simulator:
        if (index > 29):
            break
        print(
            f"step:{index} -> s:{res['control_signal']}, x:{res['analog_state']}")
        index += 1





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    step:20 -> s:[0 0 0 1 1 1], x:[ 0.54823676  0.11670772  0.06484887 -0.46198384 -0.49102044 -0.40805782]
    step:21 -> s:[1 1 1 0 0 0], x:[ 0.28852725 -0.17409672 -0.44326187 -0.0494616  -0.10665245 -0.06475226]
    step:22 -> s:[1 0 0 0 0 0], x:[0.03084446 0.40503051 0.120886   0.35734484 0.45783131 0.51372721]
    step:23 -> s:[1 1 1 1 1 1], x:[-0.22485823 -0.14425853 -0.3083532  -0.17870181  0.01002218  0.13999188]
    step:24 -> s:[0 0 0 0 1 1], x:[ 0.51887684  0.4288167   0.24768119  0.29413081 -0.47129083 -0.48446615]
    step:25 -> s:[1 1 1 1 0 0], x:[ 0.2620199   0.12253093 -0.10960282 -0.16543731  0.06911753 -0.07384044]
    step:26 -> s:[1 1 0 0 1 0], x:[ 0.00702877 -0.30986756  0.34809795  0.40279187 -0.38008475  0.33569788]
    step:27 -> s:[1 0 1 1 0 1], x:[-0.24614276  0.13067341 -0.19163269 -0.06832882  0.21496712 -0.19582706]
    step:28 -> s:[0 1 0 0 1 0], x:[ 0.4999634  -0.30514404  0.24888018  0.45427765 -0.19748182  0.29719102]
    step:29 -> s:[1 0 1 1 0 1], x:[ 0.24531795  0.38086046 -0.22665437 -0.05565031  0.41130916 -0.13880886]




.. GENERATED FROM PYTHON SOURCE LINES 159-170

Saving to File
--------------------------------

In general simulating the analog system and digital control interaction
is a computationally much more intense procedure compared to the digital
estimation step. This is one reason, and there are more, why
you would want to store the intermediate control signal sequence to a file.

For this purpose use the
:func:`cbadc.utilities.control_signal_2_byte_stream` and
:func:`cbadc.utilities.write_byte_stream_to_file` functions.

.. GENERATED FROM PYTHON SOURCE LINES 170-192

.. code-block:: default
   :lineno-start: 171


    # Instantiate a new simulator and control.
    simulator = StateSpaceSimulator(analog_system, digital_control, [
                                    analog_signal], t_stop=end_time)
    digital_control = DigitalControl(T, M)

    # Construct byte stream.
    byte_stream = control_signal_2_byte_stream(simulator, M)


    def print_next_10_bytes(stream):
        global index
        for byte in stream:
            if (index < 40):
                print(f"{index} -> {byte}")
                index += 1
            yield byte


    write_byte_stream_to_file("sinusodial_simulation.adc",
                              print_next_10_bytes(byte_stream))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    30 -> b'\x13'
    31 -> b'\x13'
    32 -> b'\x13'
    33 -> b'\x13'
    34 -> b'\x13'
    35 -> b'\x13'
    36 -> b'\x13'
    37 -> b'\x13'
    38 -> b'\x13'
    39 -> b'\x13'




.. GENERATED FROM PYTHON SOURCE LINES 193-204

Evaluating the Analog State Vector in Between Control Signal Samples
--------------------------------------------------------------------

If we wish to simulate the analog state vector trajectory in between
control updates this can be achieved using the Ts parameter of the
:py:class:`cbadc.simulator.StateSpaceSimulator`. Technically you can scale
:math:`T_s = T / \alpha` for any postive number :math:`\alpha`. For such a
scaling the simulator will generate :math:`\alpha` more control signals per
unit of time. However, digital control is still restricted to only update
the control signals at multiples of :math:`T`.


.. GENERATED FROM PYTHON SOURCE LINES 204-259

.. code-block:: default
   :lineno-start: 205


    # Set sampling time three orders of magnitude smaller than the control period
    Ts = T / 1000.0

    # Simulate for 10000 control cycles.
    size = 15000
    end_time = size * Ts

    # Initialize a new digital control.
    new_digital_control = DigitalControl(T, M)

    # Instantiate a new simulator with a sampling time.
    simulator = StateSpaceSimulator(analog_system, new_digital_control, [
                                    analog_signal], t_stop=end_time, Ts=Ts)

    # Create data containers to hold the resulting data.
    time_vector = np.arange(size) * Ts / T
    states = np.zeros((N, size))
    control_signals = np.zeros((M, size), dtype=np.int8)

    # Iterate through and store states and control_signals.
    for index, res in enumerate(extended_simulation_result(simulator)):
        states[:, index] = res['analog_state']
        control_signals[:, index] = res['control_signal']

    # Plot all analog state evolutions.
    plt.figure()
    plt.title("Analog state vectors")
    for index in range(N):
        plt.plot(time_vector, states[index, :], label=f"$x_{index + 1}(t)$")
    plt.grid(b=True, which='major', color='gray', alpha=0.6, lw=1.5)
    plt.xlabel('$t/T$')
    plt.xlim((0, 10))
    plt.legend()

    # reset figure size and plot individual results.
    plt.rcParams['figure.figsize'] = [6.40, 6.40 * 2]
    fig, ax = plt.subplots(N, 2)
    for index in range(N):
        color = next(ax[0, 0]._get_lines.prop_cycler)['color']
        ax[index, 0].grid(b=True, which='major', color='gray', alpha=0.6, lw=1.5)
        ax[index, 1].grid(b=True, which='major', color='gray', alpha=0.6, lw=1.5)
        ax[index, 0].plot(time_vector, states[index, :], color=color)
        ax[index, 1].plot(time_vector, control_signals[index, :],
                          '--', color=color)
        ax[index, 0].set_ylabel(f"$x_{index + 1}(t)$")
        ax[index, 1].set_ylabel(f"$s_{index + 1}(t)$")
        ax[index, 0].set_xlim((0, 15))
        ax[index, 1].set_xlim((0, 15))
        ax[index, 0].set_ylim((-1, 1))
    fig.suptitle("Analog state and control contribution evolution")
    ax[-1, 0].set_xlabel("$t / T$")
    ax[-1, 1].set_xlabel("$t / T$")
    fig.tight_layout()




.. rst-class:: sphx-glr-horizontal


    *

      .. image:: /auto_examples/a_getting_started/images/sphx_glr_plot_b_simulate_a_control_bounded_adc_001.png
          :alt: Analog state vectors
          :class: sphx-glr-multi-img

    *

      .. image:: /auto_examples/a_getting_started/images/sphx_glr_plot_b_simulate_a_control_bounded_adc_002.png
          :alt: Analog state and control contribution evolution
          :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 260-267

Analog State Statistics
------------------------------------------------------------------

Producing time plots, as in the previous section, is a good way of
identifying problems and possible errors. Another way of making sure that
the analog states remain bounded is to estimate their correspoding densities
(assuming i.i.d samples).

.. GENERATED FROM PYTHON SOURCE LINES 267-288

.. code-block:: default
   :lineno-start: 268


    # Compute L_2 norm of analog state vector.
    L_2_norm = np.linalg.norm(states, ord=2, axis=0)
    # Similarly, compute L_infty (largest absolute value) of the analog state
    # vector.
    L_infty_norm = np.linalg.norm(states, ord=np.inf, axis=0)

    # Estimate and plot densities using matplotlib tools.
    bins = 150
    plt.rcParams['figure.figsize'] = [6.40, 4.80]
    fig, ax = plt.subplots(2, sharex=True)
    ax[0].grid(b=True, which='major', color='gray', alpha=0.6, lw=1.5)
    ax[1].grid(b=True, which='major', color='gray', alpha=0.6, lw=1.5)
    ax[0].hist(L_2_norm, bins=bins, density=True)
    ax[1].hist(L_infty_norm, bins=bins, density=True, color="orange")
    plt.suptitle("Estimated probability densities")
    ax[0].set_xlabel("$\|\mathbf{x}(t)\|_2$")
    ax[1].set_xlabel("$\|\mathbf{x}(t)\|_\infty$")
    ax[0].set_ylabel("$p ( \| \mathbf{x}(t) \|_2 ) $")
    ax[1].set_ylabel("$p ( \| \mathbf{x}(t) \|_\infty )$")
    fig.tight_layout()



.. image:: /auto_examples/a_getting_started/images/sphx_glr_plot_b_simulate_a_control_bounded_adc_003.png
    :alt: Estimated probability densities
    :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 13 minutes  27.460 seconds)


.. _sphx_glr_download_auto_examples_a_getting_started_plot_b_simulate_a_control_bounded_adc.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_b_simulate_a_control_bounded_adc.py <plot_b_simulate_a_control_bounded_adc.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_b_simulate_a_control_bounded_adc.ipynb <plot_b_simulate_a_control_bounded_adc.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
