
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/a_getting_started/plot_c_digital_estimator.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_a_getting_started_plot_c_digital_estimator.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_a_getting_started_plot_c_digital_estimator.py:


Digital Estimation (Post Filtering)
===================================

Converting a stream of control signals into a estimate samples.

.. GENERATED FROM PYTHON SOURCE LINES 8-20

Setting up the Analog System and Digital Control
------------------------------------------------

In this example, we assume that we have access to a control signal
s[k] generated by the interactions of an analog system and digital control.
Furthermore, we a chain-of-integrators converter with corresponding
analog system and digital control.

.. image:: /images/chainOfIntegratorsGeneral.svg
   :width: 500
   :align: center
   :alt: The chain of integrators ADC.

.. GENERATED FROM PYTHON SOURCE LINES 20-58

.. code-block:: default
   :lineno-start: 21


    # Setup analog system and digital control
    from cbadc.analog_system import AnalogSystem
    from cbadc.digital_control import DigitalControl
    from cbadc.digital_estimator import DigitalEstimator
    N = 6
    M = N
    beta = 6250.
    rho = - beta * 1e-2
    A = [[rho, 0, 0, 0, 0, 0],
         [beta, rho, 0, 0, 0, 0],
         [0, beta, rho, 0, 0, 0],
         [0, 0, beta, rho, 0, 0],
         [0, 0, 0, beta, rho, 0],
         [0, 0, 0, 0, beta, rho]]
    B = [[beta], [0], [0], [0], [0], [0]]
    CT = [[0, 0, 0, 0, 0, 1]]
    Gamma = [[-beta, 0, 0, 0, 0, 0],
             [0, -beta, 0, 0, 0, 0],
             [0, 0, -beta, 0, 0, 0],
             [0, 0, 0, -beta, 0, 0],
             [0, 0, 0, 0, -beta, 0],
             [0, 0, 0, 0, 0, -beta]]
    Gamma_tildeT = [[1, 0, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0, 0],
                    [0, 0, 1, 0, 0, 0],
                    [0, 0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 1, 0],
                    [0, 0, 0, 0, 0, 1]]
    T = 1.0/(2 * beta)

    analog_system = AnalogSystem(A, B, CT, Gamma, Gamma_tildeT)
    digital_control = DigitalControl(T, M)

    # Summarize the analog system, digital control, and digital estimator.
    print(analog_system, "\n")
    print(digital_control)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ -62.5    0.     0.     0.     0.     0. ]
     [6250.   -62.5    0.     0.     0.     0. ]
     [   0.  6250.   -62.5    0.     0.     0. ]
     [   0.     0.  6250.   -62.5    0.     0. ]
     [   0.     0.     0.  6250.   -62.5    0. ]
     [   0.     0.     0.     0.  6250.   -62.5]],
    B =
    [[6250.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]],
    CT = 
    [[0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[-6250.     0.     0.     0.     0.     0.]
     [    0. -6250.     0.     0.     0.     0.]
     [    0.     0. -6250.     0.     0.     0.]
     [    0.     0.     0. -6250.     0.     0.]
     [    0.     0.     0.     0. -6250.     0.]
     [    0.     0.     0.     0.     0. -6250.]],
    and Gamma_tildeT =
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]] 

    The Digital Control is parameterized as:
    T = 8e-05,
    M = 6, and next update at
    t = 8e-05




.. GENERATED FROM PYTHON SOURCE LINES 59-66

Creating a Placehold Control Signal
-----------------------------------

We could, of course, simulate the analog system and digital control above
for a given analog signal. However, this might not always be the use case;
instead, imagine we have acquired such a control signal from a previous
simulation.

.. GENERATED FROM PYTHON SOURCE LINES 66-88

.. code-block:: default
   :lineno-start: 66

    import numpy as np
    from cbadc.utilities import random_control_signal

    # In principle, we can create a dummy generator by just


    def dummy_control_sequence_signal():
        while(True):
            yield np.zeros(M, dtype=np.int8)
    # and then pass dummy_control_sequence_signal as the control_sequence
    # to the digital estimator.


    # Another way would be to use a random control signal. Such a generator
    # is already provided in the :func:`cbadc.utilities.random_control_signal` function.
    # Subsequently, a random (random 1-0 valued M tuples) control signal of length
    sequence_length = 10
    # can conveniently be created as
    control_signal_sequences = random_control_signal(
        M, stop_after_number_of_iterations=sequence_length, random_seed=42)
    # where random_seed and stop_after_number_of_iterations are fully optional








.. GENERATED FROM PYTHON SOURCE LINES 89-97

Setting up the Filter
------------------------------------

To produce estimates we need to compute the filter coefficients of the
digital estimator. This is part of the instantiation process of the
DigitalEstimator class. However, these computations require us to
specify both the analog system, the digital control and the filter parameters
such as eta2, the batch size K1, and possible the lookahead K2.

.. GENERATED FROM PYTHON SOURCE LINES 97-110

.. code-block:: default
   :lineno-start: 98


    # Set the bandwidth of the estimator
    eta2 = 1e7
    # Set the batch size
    K1 = sequence_length

    # Instantiate the digital estimator (this is where the filter coefficients are computed).
    digital_estimator = DigitalEstimator(
        control_signal_sequences, analog_system, digital_control, eta2, K1)

    print(digital_estimator, "\n")






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Digital estimator is parameterized as 
    eta2 = 10000000.00, 140 [dB],
    Ts = 8e-05,
    K1 = 10,
    K2 = 0,
    and
    number_of_iterations = 9223372036854775808
    Resulting in the filter coefficients
    Af = 
    [[ 9.95012474e-01 -6.52575462e-08 -6.42118440e-07 -5.01286977e-06
      -2.88559805e-05 -1.05886070e-04]
     [ 4.97506158e-01  9.95011508e-01 -9.56770627e-06 -7.48255323e-05
      -4.32040749e-04 -1.59582071e-03]
     [ 1.24375947e-01  4.97498960e-01  9.94940686e-01 -5.62457185e-04
      -3.25746716e-03 -1.21106393e-02]
     [ 2.07264917e-02  1.24341653e-01  4.97161510e-01  9.92306292e-01
      -1.57270281e-02 -5.89033604e-02]
     [ 2.58168848e-03  2.06164165e-02  1.23258540e-01  4.88705899e-01
       9.43632587e-01 -1.94333587e-01]
     [ 2.39289279e-04  2.35454851e-03  1.83814143e-02  1.05810395e-01
       3.88267759e-01  5.75078140e-01]],
    Ab = 
    [[ 1.00501251e+00  8.77436590e-08 -8.61621467e-07  6.70567894e-06
      -3.83956519e-05  1.39283979e-04]
     [-5.02506150e-01  1.00501121e+00  1.28385281e-05 -1.00096227e-04
       5.74907261e-04 -2.09960241e-03]
     [ 1.25625752e-01 -5.02496612e-01  1.00491755e+00  7.41774780e-04
      -4.27386936e-03  1.57156771e-02]
     [-2.09339839e-02  1.25581705e-01 -5.02064077e-01  1.00155130e+00
       2.00164295e-02 -7.41945627e-02]
     [ 2.60561741e-03 -2.07997590e-02  1.24263649e-01 -4.91806139e-01
       9.42815973e-01  2.33084553e-01]
     [-2.39289279e-04  2.34976272e-03 -1.82873280e-02  1.04710334e-01
      -3.79846967e-01  5.36673137e-01]],
    Bf = 
    [[-4.98752080e-01  5.50486500e-09  6.53125949e-08  6.42771566e-07
       5.01929749e-06  2.89061735e-05]
     [-1.24584108e-01 -4.98751999e-01  9.72039300e-07  9.57742666e-06
       7.49213066e-05  4.32789962e-04]
     [-2.07553203e-02 -1.24583500e-01 -4.98744795e-01  7.18658889e-05
       5.63175844e-04  3.26309892e-03]
     [-2.59356050e-03 -2.07524273e-02 -1.24549177e-01 -4.98407002e-01
       2.70963772e-03  1.57541245e-02]
     [-2.58651751e-04 -2.58427500e-03 -2.06422593e-02 -1.23464962e-01
      -4.89940549e-01  5.14680079e-02]
     [-2.01854843e-05 -2.39491133e-04 -2.35694342e-03 -1.84049837e-02
      -1.05994445e-01 -3.89327703e-01]],
    Bb = 
    [[ 5.01252085e-01  7.40170334e-09 -8.76696420e-08  8.60744770e-07
      -6.69707149e-06  3.83286812e-05]
     [-1.25417441e-01  5.01251976e-01  1.30478895e-06 -1.28254802e-05
       9.99679725e-05 -5.73907581e-04]
     [ 2.09115563e-02 -1.25416636e-01  5.01242446e-01  9.48714617e-05
      -7.40826065e-04  4.26646110e-03]
     [-2.61433338e-03  2.09078406e-02 -1.25372626e-01  5.00810351e-01
       3.45680789e-03 -1.99818615e-02]
     [ 2.60670299e-04 -2.60301071e-03  2.07737289e-02 -1.24055911e-01
       4.90565580e-01  6.20896833e-02]
     [-2.01854843e-05  2.39087424e-04 -2.34737185e-03  1.82638543e-02
      -1.04527695e-01  3.78801690e-01]],
    and WT = 
    [[ 8.39789066e-02  8.39789066e-04 -2.08312400e-03 -6.26616779e-05
       1.02954027e-04  5.18949821e-06]]. 





.. GENERATED FROM PYTHON SOURCE LINES 111-115

Producing Estimates
-------------------

At this point, we can produce estimates by simply calling the iterator

.. GENERATED FROM PYTHON SOURCE LINES 115-120

.. code-block:: default
   :lineno-start: 116


    for i in digital_estimator:
        print(i)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [-0.19364346]
    [-0.19162643]
    [-0.18828573]
    [-0.18366046]
    [-0.17780668]
    [-0.17079648]
    [-0.1627168]
    [-0.1536679]
    [-0.14376174]
    [-0.13312004]
    [-0.51926864]
    [-0.5136171]
    [-0.50524818]
    [-0.49425681]
    [-0.4807663]
    [-0.46492652]
    [-0.44691167]
    [-0.42691776]
    [-0.40515974]
    [-0.38186847]
    Warning: StopIteration recived by estimator.




.. GENERATED FROM PYTHON SOURCE LINES 121-125

Batch Size and Lookahead
------------------------

Note that batch and lookahead sizes are automatically handled such that for

.. GENERATED FROM PYTHON SOURCE LINES 125-138

.. code-block:: default
   :lineno-start: 125

    K1 = 5
    K2 = 1
    sequence_length = 11
    control_signal_sequences = random_control_signal(
        M, stop_after_number_of_iterations=sequence_length, random_seed=42)
    digital_estimator = DigitalEstimator(
        control_signal_sequences, analog_system, digital_control, eta2, K1, K2)

    # The iterator is still called the same way.
    for i in digital_estimator:
        print(i)
    # However, this time this iterator involves computing two batches each involving a lookahead of size one.





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [-0.24816274]
    [-0.25087817]
    [-0.25204345]
    [-0.2516448]
    [-0.24968787]
    [-0.13670625]
    [-0.12701198]
    [-0.11653482]
    [-0.10540392]
    [-0.09375593]
    [-0.28843043]
    [-0.27746176]
    [-0.26513901]
    [-0.25160526]
    [-0.23701516]
    Warning: StopIteration recived by estimator.




.. GENERATED FROM PYTHON SOURCE LINES 139-150

Loading Control Signal from File
--------------------------------

Next, we will load an actual control signal to demonstrate the digital
estimator's capabilities. To this end, we will use the
`sinusodial_simulation.adc` file that was produced in
:doc:`./plot_b_simulate_a_control_bounded_adc`.

The control signal file is encoded as raw binary data so to unpack it
correctly we will use the :func:`cbadc.utilities.read_byte_stream_from_file`
and :func:`cbadc.utilities.byte_stream_2_control_signal` functions.

.. GENERATED FROM PYTHON SOURCE LINES 150-155

.. code-block:: default
   :lineno-start: 150

    from cbadc.utilities import read_byte_stream_from_file, byte_stream_2_control_signal

    byte_stream = read_byte_stream_from_file('sinusodial_simulation.adc', M)
    control_signal_sequences = byte_stream_2_control_signal(byte_stream, M)








.. GENERATED FROM PYTHON SOURCE LINES 156-162

Estimating the input
--------------------

Fortunately, we used the same
analog system and digital controls as in this example so


.. GENERATED FROM PYTHON SOURCE LINES 162-189

.. code-block:: default
   :lineno-start: 162

    import matplotlib.pyplot as plt

    stop_after_number_of_iterations = 1 << 17
    u_hat = np.zeros(stop_after_number_of_iterations)
    K1 = 1 << 10
    K2 = 1 << 11
    digital_estimator = DigitalEstimator(
        control_signal_sequences,
        analog_system, digital_control,
        eta2,
        K1,
        K2,
        stop_after_number_of_iterations=stop_after_number_of_iterations
    )
    for index, u_hat_temp in enumerate(digital_estimator):
        u_hat[index] = u_hat_temp

    t = np.arange(u_hat.size)
    plt.plot(t, u_hat)
    plt.xlabel('$t / T$')
    plt.ylabel('$\hat{u}(t)$')
    plt.title("Estimated input signal")
    plt.grid()
    plt.xlim((0, 1500))
    plt.ylim((-1, 1))
    plt.tight_layout()




.. image:: /auto_examples/a_getting_started/images/sphx_glr_plot_c_digital_estimator_001.png
    :alt: Estimated input signal
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Warning: StopIteration recived by estimator.




.. GENERATED FROM PYTHON SOURCE LINES 190-195

Plotting the PSD
----------------

As is typical for delta-sigma modulators, we often visualize the performance
of the estimate by plotting the power spectral density (PSD).

.. GENERATED FROM PYTHON SOURCE LINES 195-205

.. code-block:: default
   :lineno-start: 195

    from cbadc.utilities import compute_power_spectral_density

    f, psd = compute_power_spectral_density(u_hat[K2:])
    plt.figure()
    plt.semilogx(f, 10 * np.log10(psd))
    plt.xlabel('frequency [Hz]')
    plt.ylabel('$ \mathrm{V}^2 \, / \, \mathrm{Hz}$')
    plt.xlim((f[1], f[-1]))
    plt.grid(which='both')




.. image:: /auto_examples/a_getting_started/images/sphx_glr_plot_c_digital_estimator_002.png
    :alt: plot c digital estimator
    :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  22.323 seconds)


.. _sphx_glr_download_auto_examples_a_getting_started_plot_c_digital_estimator.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_c_digital_estimator.py <plot_c_digital_estimator.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_c_digital_estimator.ipynb <plot_c_digital_estimator.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
