
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/a_getting_started/plot_c_digital_estimator.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_examples_a_getting_started_plot_c_digital_estimator.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_a_getting_started_plot_c_digital_estimator.py:


Digital Estimation (Post Filtering)
===================================

How to convert a stream of control signals into a signal estimate.

.. GENERATED FROM PYTHON SOURCE LINES 8-20

Setting up the Analog System and Digital Control
------------------------------------------------

In this example we are assuming that we have access to a control signal
s[k] generated by the iteractions of an analog system and digital control.
Furthermore, we assume the analog system to be a chain-of-integrators
converter with a standard digital control.

.. image:: /images/chainOfIntegratorsGeneral.svg
   :width: 500
   :align: center
   :alt: The chain of integrators ADC.

.. GENERATED FROM PYTHON SOURCE LINES 20-58

.. code-block:: default
   :lineno-start: 21


    # Setup analog system and digital control
    from cbadc.analog_system import AnalogSystem
    from cbadc.digital_control import DigitalControl
    from cbadc.digital_estimator import DigitalEstimator
    N = 6
    M = N
    beta = 6250.
    rho = - beta * 1e-2
    A = [[rho, 0, 0, 0, 0, 0],
         [beta, rho, 0, 0, 0, 0],
         [0, beta, rho, 0, 0, 0],
         [0, 0, beta, rho, 0, 0],
         [0, 0, 0, beta, rho, 0],
         [0, 0, 0, 0, beta, rho]]
    B = [[beta], [0], [0], [0], [0], [0]]
    CT = [[0, 0, 0, 0, 0, 1]]
    Gamma = [[-beta, 0, 0, 0, 0, 0],
             [0, -beta, 0, 0, 0, 0],
             [0, 0, -beta, 0, 0, 0],
             [0, 0, 0, -beta, 0, 0],
             [0, 0, 0, 0, -beta, 0],
             [0, 0, 0, 0, 0, -beta]]
    Gamma_tildeT = [[1, 0, 0, 0, 0, 0],
                    [0, 1, 0, 0, 0, 0],
                    [0, 0, 1, 0, 0, 0],
                    [0, 0, 0, 1, 0, 0],
                    [0, 0, 0, 0, 1, 0],
                    [0, 0, 0, 0, 0, 1]]
    T = 1.0/(2 * beta)

    analog_system = AnalogSystem(A, B, CT, Gamma, Gamma_tildeT)
    digital_control = DigitalControl(T, M)

    # Summarize the analog system, digital control, and digital estimator.
    print(analog_system, "\n")
    print(digital_control)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The analog system is parameterized as:
    A =
    [[ -62.5    0.     0.     0.     0.     0. ]
     [6250.   -62.5    0.     0.     0.     0. ]
     [   0.  6250.   -62.5    0.     0.     0. ]
     [   0.     0.  6250.   -62.5    0.     0. ]
     [   0.     0.     0.  6250.   -62.5    0. ]
     [   0.     0.     0.     0.  6250.   -62.5]],
    B =
    [[6250.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]
     [   0.]],
    CT = 
    [[0. 0. 0. 0. 0. 1.]],
    Gamma =
    [[-6250.     0.     0.     0.     0.     0.]
     [    0. -6250.     0.     0.     0.     0.]
     [    0.     0. -6250.     0.     0.     0.]
     [    0.     0.     0. -6250.     0.     0.]
     [    0.     0.     0.     0. -6250.     0.]
     [    0.     0.     0.     0.     0. -6250.]],
    and Gamma_tildeT =
    [[1. 0. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0. 0.]
     [0. 0. 1. 0. 0. 0.]
     [0. 0. 0. 1. 0. 0.]
     [0. 0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 0. 1.]] 

    The Digital Control is parameterized as:
    T = 8e-05,
    M = 6, and next update at
    t = 8e-05




.. GENERATED FROM PYTHON SOURCE LINES 59-66

Creating a Placehold Control Signal
-----------------------------------

We could of course simulate the analog system and digital control above
for a given analog signal. However, this might not always be the use case
instead imagine we have acquired such a control signal from a previous
simulation.

.. GENERATED FROM PYTHON SOURCE LINES 66-88

.. code-block:: default
   :lineno-start: 66

    import numpy as np
    from cbadc.utilities import random_control_signal

    # In principle, we can create a dummy generator by just


    def dummy_control_sequence_signal():
        while(True):
            yield np.zeros(M, dtype=np.int8)
    # and then pass dummy_control_sequence_signal as the control_sequence
    # to the digital estimator.


    # Another way would be to use a random control signal. Such a generator
    # is already provided in the :func:`cbadc.utilities.random_control_signal` function.
    # Subsequently, a random (random 1-0 valued M tuples) control signal of length
    sequence_length = 10
    # can conveniently be created as
    control_signal_sequences = random_control_signal(
        M, stop_after_number_of_iterations=sequence_length, random_seed=42)
    # where random_seed and stop_after_number_of_iterations are fully optional








.. GENERATED FROM PYTHON SOURCE LINES 89-97

Setting up the Filter
------------------------------------

To produce estimates we need to compute the filter coefficients of the
digital estimator. This is part of the instantiation process of the
DigitalEstimator class. However, these computations require us to
specify both the analog system, the digital control and the filter parameters
such as eta2, the batch size K1, and possible the lookahead K2.

.. GENERATED FROM PYTHON SOURCE LINES 97-110

.. code-block:: default
   :lineno-start: 98


    # Set the bandwidth of the estimator
    eta2 = 1e7
    # Set the batch size
    K1 = sequence_length

    # Instantiate the digital estimator (this is where the filter coefficients are computed).
    digital_estimator = DigitalEstimator(
        control_signal_sequences, analog_system, digital_control, eta2, K1)

    print(digital_estimator, "\n")






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Digital estimator is parameterized as 
    eta2 = 10000000.00, 140 [dB],
    Ts = 8e-05,
    K1 = 10,
    K2 = 0,
    estimator_type = quadratic,
    and
    number_of_iterations = 9223372036854775808. 





.. GENERATED FROM PYTHON SOURCE LINES 111-115

Producing Estimates
-------------------

At this point we can produce estimates by simply calling the iterator

.. GENERATED FROM PYTHON SOURCE LINES 115-120

.. code-block:: default
   :lineno-start: 116


    for i in digital_estimator:
        print(i)






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [-0.19364346]
    [-0.19162643]
    [-0.18828573]
    [-0.18366046]
    [-0.17780668]
    [-0.17079648]
    [-0.1627168]
    [-0.1536679]
    [-0.14376174]
    [-0.13312004]
    [-0.51926864]
    [-0.5136171]
    [-0.50524818]
    [-0.49425681]
    [-0.4807663]
    [-0.46492652]
    [-0.44691167]
    [-0.42691776]
    [-0.40515974]
    [-0.38186847]
    Warning: StopIteration recived by estimator.




.. GENERATED FROM PYTHON SOURCE LINES 121-126

Batch Size and Lookahead
------------------------

Note that batche sizes and lookahead sizes are automatically handled such that
for

.. GENERATED FROM PYTHON SOURCE LINES 126-139

.. code-block:: default
   :lineno-start: 126

    K1 = 5
    K2 = 1
    sequence_length = 11
    control_signal_sequences = random_control_signal(
        M, stop_after_number_of_iterations=sequence_length, random_seed=42)
    digital_estimator = DigitalEstimator(
        control_signal_sequences, analog_system, digital_control, eta2, K1, K2)

    # The iterator is still called the same way.
    for i in digital_estimator:
        print(i)
    # However, this time this iterator involves computing two batches each involving a lookahead of size one.





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [-0.24816274]
    [-0.25087817]
    [-0.25204345]
    [-0.2516448]
    [-0.24968787]
    [-0.13670625]
    [-0.12701198]
    [-0.11653482]
    [-0.10540392]
    [-0.09375593]
    [-0.28843043]
    [-0.27746176]
    [-0.26513901]
    [-0.25160526]
    [-0.23701516]
    Warning: StopIteration recived by estimator.




.. GENERATED FROM PYTHON SOURCE LINES 140-151

Loading Control Signal from File
--------------------------------

Next we will load an actual control signal to demonstrate the digital
estimators capabilities. To this end we will use the
`sinusodial_simulation.adc` file that was produced in
:doc:`./plot_b_simulate_a_control_bounded_adc`.

The control signal file is encoded as raw binary data so to unpack it
correctly we will use the :func:`cbadc.utilities.read_byte_stream_from_file`
and :func:`cbadc.utilities.byte_stream_2_control_signal` functions.

.. GENERATED FROM PYTHON SOURCE LINES 151-156

.. code-block:: default
   :lineno-start: 151

    from cbadc.utilities import read_byte_stream_from_file, byte_stream_2_control_signal

    byte_stream = read_byte_stream_from_file('sinusodial_simulation.adc', M)
    control_signal_sequences = byte_stream_2_control_signal(byte_stream, M)








.. GENERATED FROM PYTHON SOURCE LINES 157-163

Estimating the input
--------------------

Fortunately, we used the same
analog system, and digital controls as in this example so


.. GENERATED FROM PYTHON SOURCE LINES 163-189

.. code-block:: default
   :lineno-start: 163

    import matplotlib.pyplot as plt

    stop_after_number_of_iterations = 1 << 17
    u_hat = np.zeros(stop_after_number_of_iterations)
    K1 = 1 << 10
    K2 = 1 << 11
    digital_estimator = DigitalEstimator(
        control_signal_sequences,
        analog_system, digital_control,
        eta2,
        K1,
        K2,
        stop_after_number_of_iterations=stop_after_number_of_iterations
    )
    for index, u_hat_temp in enumerate(digital_estimator):
        u_hat[index] = u_hat_temp

    t = np.arange(u_hat.size)
    plt.plot(t, u_hat)
    plt.xlabel('$t / T$')
    plt.ylabel('$\hat{u}(t)$')
    plt.title("Estimated input signal")
    plt.grid()
    plt.xlim((0, 750))
    plt.tight_layout()




.. image:: /auto_examples/a_getting_started/images/sphx_glr_plot_c_digital_estimator_001.png
    :alt: Estimated input signal
    :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Warning: StopIteration recived by estimator.




.. GENERATED FROM PYTHON SOURCE LINES 190-195

Plotting the PSD
----------------

As is typical for delta-sigma modulators we often visualize the performance
of the estimate by plotting the power spectral density (PSD).

.. GENERATED FROM PYTHON SOURCE LINES 195-205

.. code-block:: default
   :lineno-start: 195

    from cbadc.utilities import compute_power_spectral_density

    f, psd = compute_power_spectral_density(u_hat[K2:])
    plt.figure()
    plt.semilogx(f, 10 * np.log10(psd))
    plt.xlabel('frequency [Hz]')
    plt.ylabel('$ \mathrm{V}^2 \, / \, \mathrm{Hz}$')
    plt.xlim((f[1], f[-1]))
    plt.grid(which='both')




.. image:: /auto_examples/a_getting_started/images/sphx_glr_plot_c_digital_estimator_002.png
    :alt: plot c digital estimator
    :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  18.623 seconds)


.. _sphx_glr_download_auto_examples_a_getting_started_plot_c_digital_estimator.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_c_digital_estimator.py <plot_c_digital_estimator.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_c_digital_estimator.ipynb <plot_c_digital_estimator.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
