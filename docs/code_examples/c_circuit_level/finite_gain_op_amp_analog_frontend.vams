// This file was autogenerated using the
// cbadc toolbox, see https://github.com/hammal/cbadc
// and is thereby valid under the
//
// GNU General Public License v3.0
// (see https://github.com/hammal/cbadc/blob/master/LICENCE)
//
// This file was generated at
//
// 2022-05-10T17:18:52.923404
//
// using the cbadc package version
//
// 0.2.1
//
`include "constants.vams"
`include "disciplines.vams"



// comparator
//
// Ports: vdd, vgd, vsgd, clk, s_tilde, s
//
// Parameters: dly, ttime
//
// Functional Description:
//
// A comparator implementation where
// the output signal s(t) is updated at the
// falling edge of the V(clk) signal depending
// on the input signal V(s_tilde) is above or
// below a given threshold.
//
// threshold determines the descision threshold.
// Furthermore, dly and ttime specifies how quickly the
// comparator can switch its output.
//
module comparator(vdd, vgd, vsgd, clk, s_tilde, s);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input clk; // clock signal
    input s_tilde;

    output s;

    parameter real dly;
    parameter real ttime = 10p;


    analog initial begin
        V(s) = 0;
    end

    analog begin
        @(cross(V(clk) - V(sgd), -1)) begin
        	if(V(s_tilde) > V(sgd))
        		V(s, vgd) <+ V(vdd, vgd) * transition(1, dly, ttime);
        	else
        		V(s, vgd) <+ V(vdd, vgd) * transition(0, dly, ttime);
        end
    end

endmodule


// digital_control
//
// Ports: vdd, vgd, vsgd, clk, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_0, s_1, s_2, s_3
//
// Parameters:
//
// Functional Description:
//
// A digital control which mainly connects
// M comparators to the input and outputs of
// the module itself.
//
module digital_control(vdd, vgd, vsgd, clk, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_0, s_1, s_2, s_3);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input clk; // clock signal
    input s_tilde_0;
    input s_tilde_1;
    input s_tilde_2;
    input s_tilde_3;

    output s_0;
    output s_1;
    output s_2;
    output s_3;



    comparator q_0 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_0),
            .s(s_0)
    );

    comparator q_1 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_1),
            .s(s_1)
    );

    comparator q_2 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_2),
            .s(s_2)
    );

    comparator q_3 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_3),
            .s(s_3)
    );

endmodule


// resistor_network_gamma_tildeT
//
// Ports: in_0, in_1, in_2, in_3, out_0, out_1, out_2, out_3
//
// Parameters:
//
// Functional Description:
//
// Resistor network connecting inputs and outputs according to the following matrix
//
// [out_0] ≈ [1.00e+12, inf, inf, inf] [in_0]
// [out_1] ≈ [inf, 1.00e+12, inf, inf] [in_1]
// [out_2] ≈ [inf, inf, 1.00e+12, inf] [in_2]
// [out_3] ≈ [inf, inf, inf, 1.00e+12] [in_3]
//
// note the resistors are specified by their resistive values in Ohms
//
module resistor_network_gamma_tildeT(in_0, in_1, in_2, in_3, out_0, out_1, out_2, out_3);


    inout in_0;
    inout in_1;
    inout in_2;
    inout in_3;
    inout out_0;
    inout out_1;
    inout out_2;
    inout out_3;


    analog begin
        I(in_0, out_0) <+ 1e-12 * V(in_0,out_0);
        I(in_1, out_1) <+ 1e-12 * V(in_1,out_1);
        I(in_2, out_2) <+ 1e-12 * V(in_2,out_2);
        I(in_3, out_3) <+ 1e-12 * V(in_3,out_3);
    end

endmodule


// resistor_network_gamma
//
// Ports: in_0, in_1, in_2, in_3, out_0, out_1, out_2, out_3
//
// Parameters:
//
// Functional Description:
//
// Resistor network connecting inputs and outputs according to the following matrix
//
// [out_0] ≈ [3.47e+04, -inf, -inf, -inf] [in_0]
// [out_1] ≈ [-inf, 3.47e+04, -inf, -inf] [in_1]
// [out_2] ≈ [-inf, -inf, 3.47e+04, -inf] [in_2]
// [out_3] ≈ [-inf, -inf, -inf, 3.47e+04] [in_3]
//
// note the resistors are specified by their resistive values in Ohms
//
module resistor_network_gamma(in_0, in_1, in_2, in_3, out_0, out_1, out_2, out_3);


    inout in_0;
    inout in_1;
    inout in_2;
    inout in_3;
    inout out_0;
    inout out_1;
    inout out_2;
    inout out_3;


    analog begin
        I(in_0, out_0) <+ 2.879949454270444e-05 * V(in_0,out_0);
        I(in_1, out_1) <+ 2.879949454270444e-05 * V(in_1,out_1);
        I(in_2, out_2) <+ 2.879949454270444e-05 * V(in_2,out_2);
        I(in_3, out_3) <+ 2.879949454270444e-05 * V(in_3,out_3);
    end

endmodule


// resistor_network_b
//
// Ports: in_0, out_0, out_1, out_2, out_3
//
// Parameters:
//
// Functional Description:
//
// Resistor network connecting inputs and outputs according to the following matrix
//
// [out_0] ≈ [3.47e+04] [in_0]
// [out_1] ≈ [-inf] [in_1]
// [out_2] ≈ [-inf] [in_2]
// [out_3] ≈ [-inf] [in_3]
//
// note the resistors are specified by their resistive values in Ohms
//
module resistor_network_b(in_0, out_0, out_1, out_2, out_3);


    inout in_0;
    inout out_0;
    inout out_1;
    inout out_2;
    inout out_3;


    analog begin
        I(in_0, out_0) <+ 2.879949454270444e-05 * V(in_0,out_0);
    end

endmodule


// resistor_network_a
//
// Ports: in_0, in_1, in_2, in_3, out_0, out_1, out_2, out_3
//
// Parameters:
//
// Functional Description:
//
// Resistor network connecting inputs and outputs according to the following matrix
//
// [out_0] ≈ [-inf, -2.86e+06, -inf, -inf] [in_0]
// [out_1] ≈ [3.47e+04, -inf, -2.86e+06, -inf] [in_1]
// [out_2] ≈ [-inf, 3.47e+04, -inf, -2.86e+06] [in_2]
// [out_3] ≈ [-inf, -inf, 3.47e+04, -inf] [in_3]
//
// note the resistors are specified by their resistive values in Ohms
//
module resistor_network_a(in_0, in_1, in_2, in_3, out_0, out_1, out_2, out_3);


    inout in_0;
    inout in_1;
    inout in_2;
    inout in_3;
    inout out_0;
    inout out_1;
    inout out_2;
    inout out_3;


    analog begin
        I(in_1, out_0) <+ -3.495888941600088e-07 * V(in_1,out_0);
        I(in_0, out_1) <+ 2.879949454270444e-05 * V(in_0,out_1);
        I(in_2, out_1) <+ -3.495888941600088e-07 * V(in_2,out_1);
        I(in_1, out_2) <+ 2.879949454270444e-05 * V(in_1,out_2);
        I(in_3, out_2) <+ -3.495888941600088e-07 * V(in_3,out_2);
        I(in_2, out_3) <+ 2.879949454270444e-05 * V(in_2,out_3);
    end

endmodule


// inverting_amplifier_int_3
//
// Ports: vdd, vgd, p_in, n_in, out
//
// Parameters: C
//
// Functional Description:
//
// Op-amp integrator configuration where
// a capacitor is connected as negative feedback
// i.e., between the output and negative input
// of the op-amp.
//
// The resulting differential equations are
// C ddt(V(out, n_in)) = I(out, n_in)
//
module inverting_amplifier_int_3(vdd, vgd, p_in, n_in, out);

    input vdd; // positive supply
    input vgd; // ground
    input p_in; // positive input

    output out; // output

    inout n_in; // negative input

    parameter real C = 1e-12;



    finite_gain_op_amp op_amp_int_3 (
            .vdd(vdd),
            .vgd(vgd),
            .p_in(p_in),
            .n_in(n_in),
            .out(out)
    );

    analog begin
        ddt(V(out, n_in)) <+ I(out, n_in) / C;
    end

endmodule


// inverting_amplifier_int_2
//
// Ports: vdd, vgd, p_in, n_in, out
//
// Parameters: C
//
// Functional Description:
//
// Op-amp integrator configuration where
// a capacitor is connected as negative feedback
// i.e., between the output and negative input
// of the op-amp.
//
// The resulting differential equations are
// C ddt(V(out, n_in)) = I(out, n_in)
//
module inverting_amplifier_int_2(vdd, vgd, p_in, n_in, out);

    input vdd; // positive supply
    input vgd; // ground
    input p_in; // positive input

    output out; // output

    inout n_in; // negative input

    parameter real C = 1e-12;



    finite_gain_op_amp op_amp_int_2 (
            .vdd(vdd),
            .vgd(vgd),
            .p_in(p_in),
            .n_in(n_in),
            .out(out)
    );

    analog begin
        ddt(V(out, n_in)) <+ I(out, n_in) / C;
    end

endmodule


// inverting_amplifier_int_1
//
// Ports: vdd, vgd, p_in, n_in, out
//
// Parameters: C
//
// Functional Description:
//
// Op-amp integrator configuration where
// a capacitor is connected as negative feedback
// i.e., between the output and negative input
// of the op-amp.
//
// The resulting differential equations are
// C ddt(V(out, n_in)) = I(out, n_in)
//
module inverting_amplifier_int_1(vdd, vgd, p_in, n_in, out);

    input vdd; // positive supply
    input vgd; // ground
    input p_in; // positive input

    output out; // output

    inout n_in; // negative input

    parameter real C = 1e-12;



    finite_gain_op_amp op_amp_int_1 (
            .vdd(vdd),
            .vgd(vgd),
            .p_in(p_in),
            .n_in(n_in),
            .out(out)
    );

    analog begin
        ddt(V(out, n_in)) <+ I(out, n_in) / C;
    end

endmodule


// finite_gain_op_amp
//
// Ports: vdd, vgd, p_in, n_in, out
//
// Parameters: A_DC
//
// Functional Description:
//
// A finite gain op-amp implementation
// where
// V(out) = A_DC * (V(p_in) - V(n_in))
//
module finite_gain_op_amp(vdd, vgd, p_in, n_in, out);

    input vdd; // positive supply
    input vgd; // ground
    input p_in; // positive input

    output out; // output

    inout n_in; // negative input

    parameter real A_DC = 100.0;


    analog begin
        V(out) <+  A_DC * V(p_in, n_in);
    end

endmodule


// inverting_amplifier_int_0
//
// Ports: vdd, vgd, p_in, n_in, out
//
// Parameters: C
//
// Functional Description:
//
// Op-amp integrator configuration where
// a capacitor is connected as negative feedback
// i.e., between the output and negative input
// of the op-amp.
//
// The resulting differential equations are
// C ddt(V(out, n_in)) = I(out, n_in)
//
module inverting_amplifier_int_0(vdd, vgd, p_in, n_in, out);

    input vdd; // positive supply
    input vgd; // ground
    input p_in; // positive input

    output out; // output

    inout n_in; // negative input

    parameter real C = 1e-12;



    finite_gain_op_amp op_amp_int_0 (
            .vdd(vdd),
            .vgd(vgd),
            .p_in(p_in),
            .n_in(n_in),
            .out(out)
    );

    analog begin
        ddt(V(out, n_in)) <+ I(out, n_in) / C;
    end

endmodule


// analog_system
//
// Ports: vdd, vgd, vsgd, u_0, s_0, s_1, s_2, s_3, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3
//
// Parameters:
//
// Functional Description
//
// An analog system enforcing the differential equations.
//
// ddt(x(t)) = A x(t) + B u(t) + Gamma s(t)
// s_tilde(t) = Gamma_tildeT x(t)
//
// where
//
// x(t) = [x_0, x_1, x_2, x_3]^T
// u(t) = [u_0]^T
// s(t) = [s_0, s_1, s_2, s_3]^T
// s_tilde(t) = [s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3]^T
//
// A ≈
// [-5.67e+05, 3.46e+05, 0.00e+00, 0.00e+00]
// [-2.85e+07, -5.67e+05, 3.46e+05, 0.00e+00]
// [0.00e+00, -2.85e+07, -5.67e+05, 3.46e+05]
// [0.00e+00, 0.00e+00, -2.85e+07, -5.70e+05]
//
// B ≈
// [-2.85e+07]
// [0.00e+00]
// [0.00e+00]
// [0.00e+00]
//
// Gamma ≈
// [-2.85e+07, -0.00e+00, -0.00e+00, -0.00e+00]
// [-0.00e+00, -2.85e+07, -0.00e+00, -0.00e+00]
// [-0.00e+00, -0.00e+00, -2.85e+07, -0.00e+00]
// [-0.00e+00, -0.00e+00, -0.00e+00, -2.85e+07]
//
// Gamma_tildeT ≈
// [1.00e+00, 0.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 1.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 1.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 0.00e+00, 1.00e+00]
// CT ≈
// [1.00e+00, 0.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 1.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 1.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 0.00e+00, 1.00e+00]
//
module analog_system(vdd, vgd, vsgd, u_0, s_0, s_1, s_2, s_3, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input u_0; // input channel 0
    input s_0; // control signal 0
    input s_1; // control signal 1
    input s_2; // control signal 2
    input s_3; // control signal 3

    output s_tilde_0; // control observation 0
    output s_tilde_1; // control observation 1
    output s_tilde_2; // control observation 2
    output s_tilde_3; // control observation 3



    inverting_amplifier_int_0 int_0 (
            .vdd(vdd),
            .vgd(vgd),
            .p_in(vsgd),
            .n_in(vgd_0),
            .out(x_0)
    );

    inverting_amplifier_int_1 int_1 (
            .vdd(vdd),
            .vgd(vgd),
            .p_in(vsgd),
            .n_in(vgd_1),
            .out(x_1)
    );

    inverting_amplifier_int_2 int_2 (
            .vdd(vdd),
            .vgd(vgd),
            .p_in(vsgd),
            .n_in(vgd_2),
            .out(x_2)
    );

    inverting_amplifier_int_3 int_3 (
            .vdd(vdd),
            .vgd(vgd),
            .p_in(vsgd),
            .n_in(vgd_3),
            .out(x_3)
    );

    resistor_network_a A (
            .in_0(x_0),
            .in_1(x_1),
            .in_2(x_2),
            .in_3(x_3),
            .out_0(vgd_0),
            .out_1(vgd_1),
            .out_2(vgd_2),
            .out_3(vgd_3)
    );

    resistor_network_b B (
            .in_0(u_0),
            .out_0(vgd_0),
            .out_1(vgd_1),
            .out_2(vgd_2),
            .out_3(vgd_3)
    );

    resistor_network_gamma Gamma (
            .in_0(s_0),
            .in_1(s_1),
            .in_2(s_2),
            .in_3(s_3),
            .out_0(vgd_0),
            .out_1(vgd_1),
            .out_2(vgd_2),
            .out_3(vgd_3)
    );

    resistor_network_gamma_tildeT Gamma_tildeT (
            .in_0(x_0),
            .in_1(x_1),
            .in_2(x_2),
            .in_3(x_3),
            .out_0(s_tilde_0),
            .out_1(s_tilde_1),
            .out_2(s_tilde_2),
            .out_3(s_tilde_3)
    );

endmodule


// analog_frontend
//
// Ports: vdd, vgd, vsgd, clk, u_0, s_0, s_1, s_2, s_3
//
// Parameters:
//
// Functional Description:
//
// An analog frontend comparise of an analog-system
// and digital control interfaced such that
// control signals can be generated given a clock signal
// and input stimuli.
//
module analog_frontend(vdd, vgd, vsgd, clk, u_0, s_0, s_1, s_2, s_3);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input clk; // clock signal
    input u_0; // input channel 0

    output s_0; // control signal 0
    output s_1; // control signal 1
    output s_2; // control signal 2
    output s_3; // control signal 3



    analog_system  (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .u_0(u_0),
            .s_0(s_0),
            .s_1(s_1),
            .s_2(s_2),
            .s_3(s_3),
            .s_tilde_0(s_tilde_0),
            .s_tilde_1(s_tilde_1),
            .s_tilde_2(s_tilde_2),
            .s_tilde_3(s_tilde_3)
    );

    digital_control  (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde_0(s_tilde_0),
            .s_tilde_1(s_tilde_1),
            .s_tilde_2(s_tilde_2),
            .s_tilde_3(s_tilde_3),
            .s_0(s_0),
            .s_1(s_1),
            .s_2(s_2),
            .s_3(s_3)
    );

endmodule
