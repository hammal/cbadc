// This file was autogenerated using the
// cbadc toolbox, see https://github.com/hammal/cbadc
// and is thereby valid under the
//
// GNU General Public License v3.0
// (see https://github.com/hammal/cbadc/blob/master/LICENCE)
//
// This file was generated at
//
// 2022-11-04T15:53:45.644908
//
// using the cbadc package version
//
// 0.2.2
//
`include "constants.vams"
`include "disciplines.vams"



// comparator
//
// Ports: vdd, vgd, vsgd, clk, s_tilde, s
//
// Parameters: dly, ttime
//
// Functional Description:
//
// A comparator implementation where
// the output signal s(t) is updated at the
// falling edge of the V(clk) signal depending
// on the input signal V(s_tilde) is above or
// below a given threshold.
//
// threshold determines the descision threshold.
// Furthermore, dly and ttime specifies how quickly the
// comparator can switch its output.
//
module comparator(vdd, vgd, vsgd, clk, s_tilde, s);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input clk; // clock signal
    input s_tilde;
    output s;

    parameter real dly = 0.0;
    parameter real ttime = 10p;

    electrical vdd; // positive supply
    electrical vgd; // ground
    electrical vsgd; // signal ground
    electrical clk; // clock signal
    electrical s_tilde;
    electrical s;

    real vout; // Output voltage value

    analog begin
        @(cross(V(clk) - V(vsgd), -1)) begin
        	if(V(s_tilde) > V(vsgd)) begin
        		vout=V(vdd, vgd);
        	end
        	else begin
        		vout = V(vgd);
        	end
        end
        V(s, vgd) <+ vout * transition(1.0, dly, ttime);
    end

endmodule


// digital_control
//
// Ports: vdd, vgd, vsgd, clk, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_tilde_4, s_tilde_5, s_tilde_6, s_0, s_1, s_2, s_3, s_4, s_5, s_6
//
// Parameters:
//
// Functional Description:
//
// A digital control which mainly connects
// M comparators to the input and outputs of
// the module itself.
//
module digital_control(vdd, vgd, vsgd, clk, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_tilde_4, s_tilde_5, s_tilde_6, s_0, s_1, s_2, s_3, s_4, s_5, s_6);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input clk; // clock signal
    input s_tilde_0;
    input s_tilde_1;
    input s_tilde_2;
    input s_tilde_3;
    input s_tilde_4;
    input s_tilde_5;
    input s_tilde_6;
    output s_0;
    output s_1;
    output s_2;
    output s_3;
    output s_4;
    output s_5;
    output s_6;

    electrical vdd; // positive supply
    electrical vgd; // ground
    electrical vsgd; // signal ground
    electrical clk; // clock signal
    electrical s_tilde_0;
    electrical s_tilde_1;
    electrical s_tilde_2;
    electrical s_tilde_3;
    electrical s_tilde_4;
    electrical s_tilde_5;
    electrical s_tilde_6;
    electrical s_0;
    electrical s_1;
    electrical s_2;
    electrical s_3;
    electrical s_4;
    electrical s_5;
    electrical s_6;


    comparator q_0 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_0),
            .s(s_0)
    );

    comparator q_1 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_1),
            .s(s_1)
    );

    comparator q_2 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_2),
            .s(s_2)
    );

    comparator q_3 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_3),
            .s(s_3)
    );

    comparator q_4 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_4),
            .s(s_4)
    );

    comparator q_5 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_5),
            .s(s_5)
    );

    comparator q_6 (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde(s_tilde_6),
            .s(s_6)
    );

endmodule


// analog_system
//
// Ports: vdd, vgd, vsgd, u_0, s_0, s_1, s_2, s_3, s_4, s_5, s_6, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_tilde_4, s_tilde_5, s_tilde_6
//
// Parameters:
//
// Functional Description
//
// The analog system directly modeled using differential
// equations.
//
// Specifically, we use the state space model equations
//
// ddt(x(t)) = A x(t) + B u(t) + Gamma s(t)
// s_tilde(t) = Gamma_tildeT x(t)
//
// where
//
// x(t) = [x_0, x_1, x_2, x_3, x_4, x_5, x_6]^T
// u(t) = [u_0]^T
// s(t) = [s_0, s_1, s_2, s_3, s_4, s_5, s_6]^T
// s_tilde(t) = [s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_tilde_4, s_tilde_5, s_tilde_6]^T
//
// A ≈
// [0.00e+00, 1.04e+07, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00]
// [-9.47e+07, 0.00e+00, 1.04e+07, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, -9.47e+07, 0.00e+00, 1.04e+07, 0.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, -9.47e+07, 0.00e+00, 1.04e+07, 0.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 0.00e+00, -9.47e+07, 0.00e+00, 1.04e+07, 0.00e+00]
// [0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, -9.47e+07, 0.00e+00, 1.04e+07]
// [0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, -9.47e+07, 0.00e+00]
//
// B ≈
// [-9.47e+07]
// [0.00e+00]
// [0.00e+00]
// [0.00e+00]
// [0.00e+00]
// [0.00e+00]
// [0.00e+00]
//
// Gamma ≈
// [-9.47e+07, -0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00]
// [-0.00e+00, -9.47e+07, -0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00]
// [-0.00e+00, -0.00e+00, -9.47e+07, -0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00]
// [-0.00e+00, -0.00e+00, -0.00e+00, -9.47e+07, -0.00e+00, -0.00e+00, -0.00e+00]
// [-0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00, -9.47e+07, -0.00e+00, -0.00e+00]
// [-0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00, -9.47e+07, -0.00e+00]
// [-0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00, -0.00e+00, -9.47e+07]
//
// Gamma_tildeT ≈
// [1.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 1.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 1.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 0.00e+00, 1.00e+00, 0.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 1.00e+00, 0.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 1.00e+00, 0.00e+00]
// [0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, 1.00e+00]
//
module analog_system(vdd, vgd, vsgd, u_0, s_0, s_1, s_2, s_3, s_4, s_5, s_6, s_tilde_0, s_tilde_1, s_tilde_2, s_tilde_3, s_tilde_4, s_tilde_5, s_tilde_6);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input u_0;
    input s_0;
    input s_1;
    input s_2;
    input s_3;
    input s_4;
    input s_5;
    input s_6;
    output s_tilde_0;
    output s_tilde_1;
    output s_tilde_2;
    output s_tilde_3;
    output s_tilde_4;
    output s_tilde_5;
    output s_tilde_6;

    electrical vdd; // positive supply
    electrical vgd; // ground
    electrical vsgd; // signal ground
    electrical u_0;
    electrical s_0;
    electrical s_1;
    electrical s_2;
    electrical s_3;
    electrical s_4;
    electrical s_5;
    electrical s_6;
    electrical s_tilde_0;
    electrical s_tilde_1;
    electrical s_tilde_2;
    electrical s_tilde_3;
    electrical s_tilde_4;
    electrical s_tilde_5;
    electrical s_tilde_6;
    electrical x_0;
    electrical x_1;
    electrical x_2;
    electrical x_3;
    electrical x_4;
    electrical x_5;
    electrical x_6;

    analog begin
        V(x_0, vsgd) <+ idt(+10425829.710590072*V(x_1, vsgd) -94664930.03491391*V(s_0, vsgd) -94664930.03491391*V(u_0, vsgd));
        V(x_1, vsgd) <+ idt(-94664930.03491391*V(x_0, vsgd) +10425829.710590072*V(x_2, vsgd) -94664930.03491391*V(s_1, vsgd));
        V(x_2, vsgd) <+ idt(-94664930.03491391*V(x_1, vsgd) +10425829.710590072*V(x_3, vsgd) -94664930.03491391*V(s_2, vsgd));
        V(x_3, vsgd) <+ idt(-94664930.03491391*V(x_2, vsgd) +10425829.710590072*V(x_4, vsgd) -94664930.03491391*V(s_3, vsgd));
        V(x_4, vsgd) <+ idt(-94664930.03491391*V(x_3, vsgd) +10425829.710590072*V(x_5, vsgd) -94664930.03491391*V(s_4, vsgd));
        V(x_5, vsgd) <+ idt(-94664930.03491391*V(x_4, vsgd) +10425829.710590072*V(x_6, vsgd) -94664930.03491391*V(s_5, vsgd));
        V(x_6, vsgd) <+ idt(-94664930.03491391*V(x_5, vsgd) -94664930.03491391*V(s_6, vsgd));
        V(s_tilde_0, vsgd) <+ +1.0*V(x_0, vsgd);
        V(s_tilde_1, vsgd) <+ +1.0*V(x_1, vsgd);
        V(s_tilde_2, vsgd) <+ +1.0*V(x_2, vsgd);
        V(s_tilde_3, vsgd) <+ +1.0*V(x_3, vsgd);
        V(s_tilde_4, vsgd) <+ +1.0*V(x_4, vsgd);
        V(s_tilde_5, vsgd) <+ +1.0*V(x_5, vsgd);
        V(s_tilde_6, vsgd) <+ +1.0*V(x_6, vsgd);
    end

endmodule


// analog_frontend
//
// Ports: vdd, vgd, vsgd, clk, u_0, s_0, s_1, s_2, s_3, s_4, s_5, s_6
//
// Parameters:
//
// Functional Description:
//
// An analog frontend comparise of an analog-system
// and digital control interfaced such that
// control signals can be generated given a clock signal
// and input stimuli.
//
module analog_frontend(vdd, vgd, vsgd, clk, u_0, s_0, s_1, s_2, s_3, s_4, s_5, s_6);

    input vdd; // positive supply
    input vgd; // ground
    input vsgd; // signal ground
    input clk; // clock signal
    input u_0; // input channel 0
    output s_0; // control signal 0
    output s_1; // control signal 1
    output s_2; // control signal 2
    output s_3; // control signal 3
    output s_4; // control signal 4
    output s_5; // control signal 5
    output s_6; // control signal 6

    electrical vdd; // positive supply
    electrical vgd; // ground
    electrical vsgd; // signal ground
    electrical clk; // clock signal
    electrical u_0; // input channel 0
    electrical s_0; // control signal 0
    electrical s_1; // control signal 1
    electrical s_2; // control signal 2
    electrical s_3; // control signal 3
    electrical s_4; // control signal 4
    electrical s_5; // control signal 5
    electrical s_6; // control signal 6
    electrical s_tilde_0; // control observation 0
    electrical s_tilde_1; // control observation 1
    electrical s_tilde_2; // control observation 2
    electrical s_tilde_3; // control observation 3
    electrical s_tilde_4; // control observation 4
    electrical s_tilde_5; // control observation 5
    electrical s_tilde_6; // control observation 6


    analog_system analog_system (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .u_0(u_0),
            .s_0(s_0),
            .s_1(s_1),
            .s_2(s_2),
            .s_3(s_3),
            .s_4(s_4),
            .s_5(s_5),
            .s_6(s_6),
            .s_tilde_0(s_tilde_0),
            .s_tilde_1(s_tilde_1),
            .s_tilde_2(s_tilde_2),
            .s_tilde_3(s_tilde_3),
            .s_tilde_4(s_tilde_4),
            .s_tilde_5(s_tilde_5),
            .s_tilde_6(s_tilde_6)
    );

    digital_control digital_control (
            .vdd(vdd),
            .vgd(vgd),
            .vsgd(vsgd),
            .clk(clk),
            .s_tilde_0(s_tilde_0),
            .s_tilde_1(s_tilde_1),
            .s_tilde_2(s_tilde_2),
            .s_tilde_3(s_tilde_3),
            .s_tilde_4(s_tilde_4),
            .s_tilde_5(s_tilde_5),
            .s_tilde_6(s_tilde_6),
            .s_0(s_0),
            .s_1(s_1),
            .s_2(s_2),
            .s_3(s_3),
            .s_4(s_4),
            .s_5(s_5),
            .s_6(s_6)
    );

endmodule
